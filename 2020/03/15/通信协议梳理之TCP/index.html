<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-next.png">
  <link rel="mask-icon" href="/uploads/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"icevil.cn","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"left","width":310,"display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。 TCP介绍传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。">
<meta property="og:type" content="article">
<meta property="og:title" content="通信协议梳理之TCP">
<meta property="og:url" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/index.html">
<meta property="og:site_name" content="Ives&#39;s Blog">
<meta property="og:description" content="上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。 TCP介绍传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/protocols.gif">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/tcp_ip.gif">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/ip.gif">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/tcp_head.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/conn.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/disconn.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/disconn2.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/tcp_status_trans.jpg">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/tcp_wnd1.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/tcp_wnd2.png">
<meta property="og:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/slowstart.jpg">
<meta property="article:published_time" content="2020-03-15T01:23:01.000Z">
<meta property="article:modified_time" content="2020-04-07T11:51:42.618Z">
<meta property="article:author" content="Ives">
<meta property="article:tag" content="tcp">
<meta property="article:tag" content="通信协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/protocols.gif">

<link rel="canonical" href="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>通信协议梳理之TCP | Ives's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Ives's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta custom-logo">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ives's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Reading maketh a full man; conference a ready man; and writing an exact man. --Fransis Bacon</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/" class="github-corner" title="去全球最大同性交友网站，走！" aria-label="去全球最大同性交友网站，走！" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Ives">
      <meta itemprop="description" content="当你开始满于现状时，你正在错失世界的美好。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ives's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          通信协议梳理之TCP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 09:23:01" itemprop="dateCreated datePublished" datetime="2020-03-15T09:23:01+08:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index">
                    <span itemprop="name">c/c++</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。</p>
<h2 id="TCP介绍"><a href="#TCP介绍" class="headerlink" title="TCP介绍"></a>TCP介绍</h2><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向<strong>连接的、可靠的、基于字节流的传输层通信协议</strong>，由IETF的RFC 793定义。</p>
<a id="more"></a>
<p>TCP是一个应用非常广泛的传输层协议，也有很多应用层协议栈是在TCP的基础上封装的。TCP是基于ICMP,IP协议之上的封装。如下图<br><img src="protocols.gif" alt="常用协议图表" title="常用协议图表"><br>TCP/IP协议簇也是非常丰富，如下图：<br><img src="tcp_ip.gif" alt="TCP/IP协议簇" title="TCP/IP协议簇"></p>
<h2 id="TCP协议头详解"><a href="#TCP协议头详解" class="headerlink" title="TCP协议头详解"></a>TCP协议头详解</h2><p>IP协议头（20字节）<br><img src="ip.gif" alt="ip协议头" title="ip协议头"></p>
<h3 id="tcp协议头（20字节）"><a href="#tcp协议头（20字节）" class="headerlink" title="tcp协议头（20字节）"></a>tcp协议头（20字节）</h3><p><img src="tcp_head.png" alt="tcp协议头" title="tcp协议头"></p>
<ul>
<li><p>2字节源端口号</p>
</li>
<li><p>2字节目的端口号</p>
</li>
<li><p>4字节序列号</p>
<blockquote>
<p>发送字节流的起始字节序列号</p>
</blockquote>
</li>
<li><p>4字节确认号</p>
<blockquote>
<p>接收端期望接收的下一个字节序列号</p>
</blockquote>
</li>
<li><p>2字节标志位 </p>
<blockquote>
<ol>
<li>TCP头长度：占4bit，以 <code>4Byte</code> 为单位显示TCP头长，TCP协议头固定20Byte，因此length最小为5（以4字节为一个单位），选项部分最长40Byte，加上固定头长总共60Byte，所以length最大值为15，4bit刚刚好；</li>
<li>Resv：占4bit，预留；</li>
<li>CWR（Congestion Window Reduce）：发送端收到ECE置位的数据后进行设置，用来通知接收端已收到ECE标志的数据，了解了拥塞情况，接收端收到CWR置位消息后，不再设置ECE标志，同时发送端发送CWR信息时，将开始减小拥塞窗口，以此减小数据发送量，避免拥塞；</li>
<li>ECE（ECN ECHO）：网络拥塞一般出现在路由交换时，在支持ECN功能情况下，发生拥塞时路由会设置IP中该标志位，接收端收到IP头中标志了ECN的报文后，在返回的数据ACK中设置ECE标志，表示链路发生拥塞，将拥塞消息通知发送端；</li>
<li>URG：紧急标志，置位后不需要按照正常报文按序处理，执行<code>优先处理</code>；</li>
<li>ACK：确认标志；</li>
<li>PSH：将缓存中的数据以及当前psh报文一起执行推送，从缓存区发出去；</li>
<li>RST：强行复位标志，发送数据包出现错误时，TCP会发送该状态包；</li>
<li>SYN：请求建立连接时置位该标志，第一个握手报文携带；</li>
<li>FIN：请求连接关闭时置位该标志。</li>
</ol>
</blockquote>
</li>
<li><p>2字节窗口大小</p>
<blockquote>
<p>表示接收端接收缓存剩余大小</p>
</blockquote>
</li>
<li><p>2字节校验和</p>
<blockquote>
<p>包括TCP协议头与数据整体的校验字段</p>
</blockquote>
</li>
<li><p>2字节紧急指针</p>
<blockquote>
<p>标志位URG置位后使用，为一个正的偏移量，表示当前报文中起始字节开始需要偏移的长度，这个偏移到的字节就是紧急数据的结束字节，也就是通过偏移量确定了数据中需要紧急发送的字节个数，16bit；</p>
</blockquote>
</li>
<li><p>Opention</p>
<blockquote>
<p>一般用于握手时接收端，发送端信息的交互，以及数据交互过程中；最大40Byte；</p>
</blockquote>
</li>
</ul>
<p>通过协议头，TCP即可通过五元组来确定哪个数据包来自哪个客户端。$五元组 = 四元组+协议类型（tcp/udp）$组成。</p>
<blockquote>
<p>四元组：源IP，源端口，目标IP，目标端口<br>五元组与socket的fd是对应的<br>send数据：是通过fd找到相应的五元组信息<br>recv数据：是通过五元组找到相应fd的信息</p>
</blockquote>
<h3 id="TCP分段"><a href="#TCP分段" class="headerlink" title="TCP分段"></a>TCP分段</h3><p><strong>最大报文段长度<code>MSS</code>（Maximum Segment Size）</strong><br>收发双方协商通信时每一个报文段所能承载的最大数据长度。</p>
<p>$MSS = MTU - TCP头 - IP头$</p>
<p><strong>最大传输单元<code>MTU</code>(Maximum Transmission Unit)</strong><br>是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看MTU值,通常Linux默认是1500字节</span></span><br><span class="line">cat /sys/class/net/eth0/mtu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.  修改MTU值，为1460字节</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1460"</span> &gt; /sys/class/net/eth0/mtu</span><br></pre></td></tr></table></figure>
<p>相比于UDP那样直接丢，TCP有自动分段的功能，TCP会根据实际MTU大小自动分包发送，这也是TCP<font color=red>连接可靠</font>的一个保证。</p>
<h3 id="TCP和MTU的关系"><a href="#TCP和MTU的关系" class="headerlink" title="TCP和MTU的关系"></a>TCP和MTU的关系</h3><ul>
<li>MTU（Maximum Transmission Unit）是指通信协议的链路层上面所能通过的最大数据包大小，LINUX默认1500字节。</li>
<li>单个UDP传输的最大内容 <font color=red>$1460 = 1500 - 20 - 20$</font> 字节，但由于不同的网络中转设备设置的MTU值并不相同。 </li>
<li><code>Internet</code>上的标准MTU值为 <font color=red>$576$</font> 字节，TCP的数据包长度控制在 <font color=red>$536 = 576-20-20$</font> 字节以内； </li>
<li>局域网环境下，UDP的数据长度控制在$1460$个字节以内。</li>
</ul>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP建立连接的过程是需要三次握手的，三次握手由客户端执行connect开始触发，服务器执行accept完成连接。代码太简单，我们分析代码层看不到的东西，三次握手是怎么进行的？先看下图<br><img src="conn.png" alt=""><br><strong>第一次握手</strong>：client将标志位<code>SYN=1</code> 生成一个随机序列号<code>seq=J</code>发送<br><strong>第二次握手</strong>：server将标志位<code>SYN=1</code>, <code>ACK=1</code>； 然后将收到的序列号加1赋值给确认号<code>ack=J+1</code>,并将自己的序列号发送给客户端<code>seq=K</code><br><strong>第三次握手</strong>：client将标志位<code>ACK=1</code>, 然后将收到的序列号加1赋值给确认号<code>ack=K+1</code>发送<br>完成三次握手后，客户端，服务器才能都进入ESTABLESHED(已确立的)状态，才能进行收发数据。</p>
<p><em>为何是三次握手？两次行不行？</em><br>答：两次不行，如果两次握手就建立连接，那客户端发完请求就关闭了，服务器还认为客户端已建立连接，显然这是一个无效的连接，又或者客户端连续发起了两次连接，显然只有一个有效请求，但服务器却分辨不出以为是两个有效连接。所以，TCP作为一个可靠连接协议必然是三次握手。<font color=red>另外在我个人看来，要确定连接只需确定彼此双方都能收发数据就行，而三次握手正好可以表明双方都能收发成功。两次握手不能证明客户端能收到数据</font></p>
<blockquote>
<p>好比如下情景：<br>A:在吗？<br>B:在，你在吗？<br>A:我在(试想一下如果A不回复这句，B如何确定A还在？)</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>前面我们已经知道了3次握手可以确定TCP的连接，那TCP是如何断开连接的呢？没错，四次挥手。先看下面两张图<br>客户端主动发起断开连接（服务器主动发起也是一样）<br><img src="disconn.png" alt=""><br>第一次挥手：Client发送一个FIN，<font color=red>用来关闭Client到Server的数据传送</font>，Client进入<code>FIN_WAIT_1</code>状态。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<code>CLOSE_WAIT</code>状态。<br>第三次挥手：Server发送一个FIN，<font color=red>用来关闭Server到Client的数据传送</font>，Server进入<code>LAST_ACK</code>状态。<br>第四次挥手：Client收到FIN后，Client进入<code>TIME_WAIT</code>状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入<code>CLOSED</code>状态，完成四次挥手。<br>双发同时发起断开连接<br><img src="disconn2.png" alt=""><br>后面这个图不再写每次挥手的作用，因为基本和上一个图一样。可以总结的是：4次挥手之后，无论客户端或是服务器都将进入<code>TIME_WAIT状态</code>或者<code>CLOSED状态</code>z,这两个状态都有关闭的意思，那区别是什么呢？为什么需要两个关闭状态呢一个不就行了吗或者说干嘛不直接进入<code>CLOSED状态</code>？带着这两个疑问继续往下看。</p>
<h2 id="TCP状态装换图"><a href="#TCP状态装换图" class="headerlink" title="TCP状态装换图"></a>TCP状态装换图</h2><p><img src="tcp_status_trans.jpg" alt="TCP状态装换图" title="TCP状态装换图"></p>
<ol>
<li>CLOSED：这是最开始的状态</li>
<li>LISTEN：服务器调用<code>listen()</code>之后的状态</li>
<li>SYN_SENT：客户端发起连接请求之后的状态</li>
<li>SYN_RECV：服务器收到客户端连接请求之后的状态</li>
<li>ESTABLISHED：这是双方建立连接之后的状态，该状态即可正常收发数据了。</li>
<li>FIN_WAIT_1：调用<code>close()</code>(发送完FIN)后的状态</li>
<li>CLOS_WAIT：等待关闭状态，在ESTABLISHED状态收到FIN后进入的状态，回发FIN，发完进入LAST_ASK</li>
<li>FIN_WAIT_2：在FIN_WAIT_1的状态先收到ack，然后收到FIN后的状态</li>
<li>LAST_ASK: 最后确认状态，在CLOS_WAIT状态回发FIN之后进入的状态</li>
<li>TIME_WAIT：由FIN_WAIT_1/FIN_WAIT_2发送ACK后的状态,或者在CLOSING接收到ACK后的状态。总之这是一个挥手完成后的状态</li>
<li>CLOSING：在FIN_WAIT_1状态的时候先收到FIN，然后收到ack的状态</li>
</ol>
<p>握手触发前5个状态，挥手触发后6个状态。有上图可知，TCP真正的关闭状态才是CLOSED,而TIME_WAIT并非关闭状态，TIME_WAIT需要经过2MSL(Maximum Segment Lifetime 报文最大生存时间)超时才会变成CLOSED状态。<br><font color=red>RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟（这个和操作系统有关，Solaris2.2MSL是2分钟，测试方法就是用netstat命令查看状态变化需要时间/2即可。）<br>2MSL TIME_WAIT状态的存在有两个理由：</font></p>
<ol>
<li>让4次挥手关闭流程更加可靠；<blockquote>
<p>4次挥手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</p>
</blockquote>
</li>
<li>防止<code>lost duplicate</code>对后续新建正常链接的传输造成破坏。<blockquote>
<p><code>lost duplicate</code>在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL（time to live的缩写，存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机），限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p>
</blockquote>
</li>
</ol>
<h2 id="TCP可靠性的保证"><a href="#TCP可靠性的保证" class="headerlink" title="TCP可靠性的保证"></a>TCP可靠性的保证</h2><p>TCP采用一种名为“带重传功能的肯定确认（positive acknowledge with retransmission）”的技术作为提供可靠数据传输服务的基础。这项技术要求接收方收到数据之后回发确认信息ACK。发送方对发出的每个分组都暂存着，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP译名传输控制协议，而tcpsocket叫流式套接字。流式也就是告诉我们tcp的数据包是有先后顺序的，先发先到而这又是由滑动窗口来处理的，滑动窗口又是如何保证顺序的呢？</p>
<p>滑动窗口由两个索引，一前，一后，中间部分即为滑动窗口大小。<br>对于发送端：前索引表示的是已发送的位置，后索引表示不允许发送的位置<br>对于接收端：前索引表示的是已确认的位置，后索引表示不允许接收的位置</p>
<h3 id="窗口边沿移动"><a href="#窗口边沿移动" class="headerlink" title="窗口边沿移动"></a>窗口边沿移动</h3><ol>
<li>左边沿右边沿靠近，叫窗口合拢。数据被发送和确认时</li>
<li>右边沿向右移动，叫窗口张开。接收端读取已经确认的数据并释放了TCP的接收缓存时</li>
<li>右边沿左边沿靠近，叫窗口收缩。<strong>不建议</strong>，一但出现零窗口（窗口大小为0），发送方将不能发送任何数据，却占用着资源，如何解决这种占坑不工作的现象？请看后面的坚持定时器。</li>
</ol>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>发送窗口的大小是由拥塞计算出来的，先小后大，最后趋于稳定波动，这是动态计算的，这将影响TCP性能。对于以太网，默认大小是4kb，当文件传输的时候，调到16kb可以增加40%左右的吞吐量。</p>
<p><img src="tcp_wnd1.png" alt=""></p>
<p><img src="tcp_wnd2.png" alt=""></p>
<h2 id="拥塞避免算法和慢启动算法"><a href="#拥塞避免算法和慢启动算法" class="headerlink" title="拥塞避免算法和慢启动算法"></a>拥塞避免算法和慢启动算法</h2><p><strong>拥塞</strong><br>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。如何解决拥塞？</p>
<p><font color=red>慢启动算法是一个在连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法就是一种处理丢失分组的方法。这是两个目的不同、独立的算法，前者目的是减少输入流大小；后者目的是判断中间网络是否发生分组丢失（通过发生超时和接收到重复的确认，以此来判断分组丢失）。所以这两个算法通常用于一起实现。</font></p>
<p>slow start算法，通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。<br>慢启动为发送方的TCP增加了另一个窗口：<strong>拥塞窗口</strong>，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中最小值作为发送上限。<strong>拥塞窗口是发送方使用的流量控制，而通告窗口是接收方使用的流量控制</strong>。<br>    拥塞窗口以指数方式增加，在某一时刻可能发送速率达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开的过大。</p>
<p>这两个算法对每个连接维持两个变量，<strong>一个拥塞窗口cwnd和一个慢启动阈值ssthresh</strong>.假设窗口大小变量为wnd_size,下面详细分析一下拥塞发生过程。</p>
<ol>
<li>给定的连接，初始化<code>cwnd=1;ssthresh=65535;</code></li>
<li>tcp输出不能超过cwnd和接收方通告窗口的大小。</li>
<li>当拥塞发生时（超时或者收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd&gt;=2）.此外如果是超时引起的拥塞，则<code>cwnd=1;</code></li>
<li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于正在进行慢启动还是拥塞避免，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人整理的伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line">cwnd = <span class="number">1</span>;</span><br><span class="line">ssthresh = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//慢启动</span></span><br><span class="line"><span class="keyword">if</span>( cwnd &lt;= ssthresh )</span><br><span class="line">&#123;</span><br><span class="line">    慢启动；</span><br><span class="line">    <span class="keyword">if</span>( cwnd &lt; <span class="number">2</span>*ssthresh )</span><br><span class="line">        cwnd = cwnd &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cwnd++;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//执行拥塞避免，增速急剧下降</span></span><br><span class="line">    <span class="comment">//当所有窗口数据全部发出并收到ACK的时候，cwnd += 1;</span></span><br><span class="line">    <span class="comment">//否则 cwnd += 0;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get</span>(ACK))</span><br><span class="line">        cwnd += <span class="number">1</span>/cwnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以假设 cwnd == 32 拥塞发生</span></span><br><span class="line"><span class="keyword">if</span>( cwnd&gt;? 拥塞发生)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(重复确认导致)</span><br><span class="line">    &#123;</span><br><span class="line">        ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line">        cwnd = ssthresh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(超时导致)</span><br><span class="line">    &#123;</span><br><span class="line">        cwnd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下图是慢启动和拥塞避免的一个可视化描述。我们以段为单位来显示cwnd和ssthresh，但它们实际上都是以字节为单位进行维护的。<br><img src="slowstart.jpg" alt=""><br>在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置 ssthresh为16个报文段，而cwnd为1个报文段。在时刻 0发送了一个报文段，并假定在时刻 1接收到它的 ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻 3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起， cwnd以线性方式增加，在<code>每个往返时间内</code>(窗口全部数据包被发出并收到ACK的时间)最多增加 1个报文段。<br>正如我们在这个图中看到的那样，术语“慢启动”并不完全正确。它只是采用了比引起拥塞更慢些的分组传输速率，但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。只有在达到ssthresh拥塞避免算法起作用时，这种增加的速率才会慢下来。</li>
</ol>
<h2 id="TCP的七种定时器"><a href="#TCP的七种定时器" class="headerlink" title="TCP的七种定时器"></a>TCP的七种定时器</h2><ol>
<li>建立连接定时器(connection-establishment timer)</li>
<li>重传定时器(retransmission timer)</li>
<li>延迟应答定时器(delayed ACK timer)</li>
<li>坚持定时器(persist timer)</li>
<li>保活定时器(keepalive timer)</li>
<li>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</li>
<li>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</li>
</ol>
<p>TCP的定时器是TCP协议很重呀的一个部分，我认为是TCP最难理解的地方了，搞清楚了定时器的运转，TCP的很多机制将会迎刃而解。<font color=red>个人理解的定时器的设计：连接时防止SYN丢失需要1个定时器，断开时FIN丢失和ACK丢失两个定时器，数据传输过程中4个定时器：包括窗口大小探测1个定时器，数据超时发送重传需要一个定时器，数据延时应答一个定时器（只有这个定时器是为了提升效率的，其他都是保证传输可靠的），防止长时间不工作的连接浪费资源需要一个保活定时器。</font></p>
<h3 id="建立连接定时器-connection-establishment-timer"><a href="#建立连接定时器-connection-establishment-timer" class="headerlink" title="建立连接定时器(connection-establishment timer)"></a>建立连接定时器(connection-establishment timer)</h3><p>顾名思义，这个定时器是在建立连接的时候使用的， 我们知道， TCP建立连接需要3次握手。<br>建立连接的过程中，在发送SYN时， 会启动一个定时器(默认应该是3秒)，如果SYN包丢失了， 那么3秒以后会重新发送SYN包的(当然还会启动一个新的定时器， 设置成6秒超时)，当然也不会一直没完没了的发SYN包， 在 <code>/proc/sys/net/ipv4/tcp_syn_retries</code> 可以设置到底要重新发送几次SYN包。</p>
<h3 id="重传定时器-retransmission-timer"><a href="#重传定时器-retransmission-timer" class="headerlink" title="重传定时器(retransmission timer)"></a>重传定时器(retransmission timer)</h3><p>重传定时器在TCP发送数据时设定，在计时器超时后没有收到返回的确认ACK，发送端就会重新发送队列中需要重传的报文段。使用RTO(Retransmission Timeout超时重传)超时重传计时器一般有如下规则：</p>
<ol>
<li>当TCP发送了位于发送队列最前端的报文段后就启动这个RTO计时器；</li>
<li>如果队列为空则停止计时器，否则重启计时器；</li>
<li>当计时器超时后，TCP会重传发送队列最前端的报文段；</li>
<li>当一个或者多个报文段被累计确认后，这个或者这些报文段会被清除出队列</li>
</ol>
<p>重传计时器保证了接收端能够接收到丢失的报文段，继而保证了接收端交付给接收进程的数据始终的有序完整的。因为接收端永远不会把一个失序不完整的报文段交付给接收进程。</p>
<h3 id="延迟应答定时器-delayed-ACK-timer"><a href="#延迟应答定时器-delayed-ACK-timer" class="headerlink" title="延迟应答定时器(delayed ACK timer)"></a>延迟应答定时器(delayed ACK timer)</h3><p>延迟应答也被成为捎带ACK， 这个定时器是在延迟应答的时候使用的。 为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。</p>
<p>举例说明，比如服务端收到客户端的数据后， 不是立刻回ACK给客户端， 而是等一段时间(一般最大200ms)，这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了， 这样比立即回给客户端一个ACK节省了一个数据包。</p>
<h3 id="坚持定时器-persist-timer"><a href="#坚持定时器-persist-timer" class="headerlink" title="坚持定时器(persist timer)"></a>坚持定时器(persist timer)</h3><p>我们已经知道TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。接收端窗口变为非0后，就会发送一个确认ACK指明需要的报文段序号以及窗口大小。</p>
<p>如果这个确认ACK丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 (window probe)。</p>
<h3 id="保活定时器-keepalive-timer"><a href="#保活定时器-keepalive-timer" class="headerlink" title="保活定时器(keepalive timer)"></a>保活定时器(keepalive timer)</h3><p>在TCP连接建立的时候指定了SO_KEEPALIVE，保活定时器才会生效。如果客户端和服务端长时间没有数据交互，那么需要保活定时器来判断是否对端还活着，但是这个其实很不实用，因为默认是2小时(<code>cat /proc/sys/net/ipv4/tcp_keepalive_time</code>)没有数据交互才探测，时间实在是太长了。如果你真的要确认对端是否活着， 那么应该自己实现心跳包，而不是依赖于这个保活定时器。</p>
<h3 id="FIN-WAIT-2定时器-FIN-WAIT-2-timer"><a href="#FIN-WAIT-2定时器-FIN-WAIT-2-timer" class="headerlink" title="FIN_WAIT_2定时器(FIN_WAIT_2 timer)"></a>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</h3><p>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN，主动关闭的一端总不能一直傻等着，占着资源不撒手吧？这个时候就需要FIN_WAIT_2定时器出马了， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么不好意思， 不等了， 直接释放这个链接。FIN_WAIT_2定时器的时间可以从<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>中查看和设置。</p>
<h3 id="TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer"><a href="#TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer" class="headerlink" title="TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)"></a>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</h3><p>TIME_WAIT是主动关闭连接的一端最后进入的状态， 而不是直接变成CLOSED的状态， 为什么呢？第一个原因是万一被动关闭的一端在超时时间内没有收到最后一个ACK， 则会重发最后的FIN，2MSL（报文段最大生存时间）等待时间保证了重发的FIN会被主动关闭的一端收到且重新发送最后一个ACK；另外一个原因是在2MSL等待时间时，任何迟到的报文段会被接收并丢弃，防止老的TCP连接的包在新的TCP连接里面出现。不可避免的，在这个2MSL等待时间内，不会建立同样(源IP, 源端口，目的IP，目的端口)的连接。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><em>1. 什么时候给对端发送确认消息？</em></p>
<blockquote>
<p>确认重传，接收端确认最小序号的包重传如：ack number=5,对方就会从5号包开始将窗口内的剩余数据全部重传一遍。这也导致了有些包被重传多次。</p>
</blockquote>
<p><em>2. 确认消息应该发送多少？</em></p>
<blockquote>
<p>只发送序号最小的包，但是回，却是回从最小序号开始到窗口尾端的包。</p>
</blockquote>
<p><em>3. 为何不只重传没收到的包，已收到的不重传？</em></p>
<blockquote>
<p>就TCP现有机制来说，实现难度太大。</p>
</blockquote>
<p><em>4. 有了TCP，为何还要UDP的可靠传输？</em></p>
<blockquote>
<p>也因为<code>延时确认</code>，tcp牺牲了一定量的实时性及带宽，对于游戏而言，UDP的可靠传输就应用更多了，UDP是实时性的。</p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechatpay.png" alt="Ives 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ives
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/" title="通信协议梳理之TCP">https://icevil.cn/2020/03/15/通信协议梳理之TCP/</a>                   
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="https://twitter.com/Ives">
                <span class="icon">
                  <i class="fa fa-twitter"></i>
                </span>

                <span class="label">Twitter</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/images/wechat.png">
                <span class="icon">
                  <i class="fa fa-wechat"></i>
                </span>

                <span class="label">WeChat</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/tcp/" rel="tag"><i class="fa fa-tag"></i> tcp</a>
              <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="fa fa-tag"></i> 通信协议</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/14/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BUDP/" rel="prev" title="通信协议梳理之UDP">
      <i class="fa fa-chevron-left"></i> 通信协议梳理之UDP
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/21/ubuntu16%E9%85%8D%E7%BD%AEsamba%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/" rel="next" title="ubuntu16配置samba共享文件夹">
      ubuntu16配置samba共享文件夹 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP介绍"><span class="nav-number">1.</span> <span class="nav-text">TCP介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP协议头详解"><span class="nav-number">2.</span> <span class="nav-text">TCP协议头详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp协议头（20字节）"><span class="nav-number">2.1.</span> <span class="nav-text">tcp协议头（20字节）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP分段"><span class="nav-number">2.2.</span> <span class="nav-text">TCP分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和MTU的关系"><span class="nav-number">2.3.</span> <span class="nav-text">TCP和MTU的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP三次握手"><span class="nav-number">3.</span> <span class="nav-text">TCP三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP四次挥手"><span class="nav-number">4.</span> <span class="nav-text">TCP四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP状态装换图"><span class="nav-number">5.</span> <span class="nav-text">TCP状态装换图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP可靠性的保证"><span class="nav-number">6.</span> <span class="nav-text">TCP可靠性的保证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口"><span class="nav-number">7.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#窗口边沿移动"><span class="nav-number">7.1.</span> <span class="nav-text">窗口边沿移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#窗口大小"><span class="nav-number">7.2.</span> <span class="nav-text">窗口大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞避免算法和慢启动算法"><span class="nav-number">8.</span> <span class="nav-text">拥塞避免算法和慢启动算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP的七种定时器"><span class="nav-number">9.</span> <span class="nav-text">TCP的七种定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立连接定时器-connection-establishment-timer"><span class="nav-number">9.1.</span> <span class="nav-text">建立连接定时器(connection-establishment timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重传定时器-retransmission-timer"><span class="nav-number">9.2.</span> <span class="nav-text">重传定时器(retransmission timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟应答定时器-delayed-ACK-timer"><span class="nav-number">9.3.</span> <span class="nav-text">延迟应答定时器(delayed ACK timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#坚持定时器-persist-timer"><span class="nav-number">9.4.</span> <span class="nav-text">坚持定时器(persist timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保活定时器-keepalive-timer"><span class="nav-number">9.5.</span> <span class="nav-text">保活定时器(keepalive timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FIN-WAIT-2定时器-FIN-WAIT-2-timer"><span class="nav-number">9.6.</span> <span class="nav-text">FIN_WAIT_2定时器(FIN_WAIT_2 timer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer"><span class="nav-number">9.7.</span> <span class="nav-text">TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">10.</span> <span class="nav-text">问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ives"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ives</p>
  <div class="site-description" itemprop="description">当你开始满于现状时，你正在错失世界的美好。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">144</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:somepure@foxmail.com" title="E-Mail → mailto:somepure@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
    <!--插入外链-->
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" height=240 src="//music.163.com/outchain/player?type=0&id=4866221043&auto=0&height=430"></iframe>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19149780号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">版权归原作者Ives所有，转载请标注。</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">196k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:58</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
        loader: {
          load: ['[tex]/mhchem']
        },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
