<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-next.png">
  <link rel="mask-icon" href="/uploads/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"icevil.cn","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"left","width":310,"display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="redis作为一个key-value存储系统，是如何做到高效的呢？在内存中维护一个hash表，hash表的操作时间复杂度是O(1),但是hash是由一定概率发生hash碰撞的，通常做法是还会维护一个list，以确保数据完整性。但是这个list一旦过长，速率必然明显下降，所以一定要有足够的空间分配来避免list过长，而redis是怎么灵活控制内存伸缩的呢？下面从源码着手查找原因。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码分析之数据库存储结构">
<meta property="og:url" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Ives&#39;s Blog">
<meta property="og:description" content="redis作为一个key-value存储系统，是如何做到高效的呢？在内存中维护一个hash表，hash表的操作时间复杂度是O(1),但是hash是由一定概率发生hash碰撞的，通常做法是还会维护一个list，以确保数据完整性。但是这个list一旦过长，速率必然明显下降，所以一定要有足够的空间分配来避免list过长，而redis是怎么灵活控制内存伸缩的呢？下面从源码着手查找原因。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/hash.jpg">
<meta property="og:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/empty_hash_table.png">
<meta property="og:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/hash_table_node.jpg">
<meta property="og:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/dict.png">
<meta property="og:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/urls_dict.jpg">
<meta property="article:published_time" content="2020-04-04T02:48:55.000Z">
<meta property="article:modified_time" content="2020-04-05T02:33:46.559Z">
<meta property="article:author" content="Ives">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="存储结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/hash.jpg">

<link rel="canonical" href="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Redis源码分析之数据库存储结构 | Ives's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Ives's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta custom-logo">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ives's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Reading maketh a full man; conference a ready man; and writing an exact man. --Fransis Bacon</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/" class="github-corner" title="去全球最大同性交友网站，走！" aria-label="去全球最大同性交友网站，走！" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Ives">
      <meta itemprop="description" content="当你开始满于现状时，你正在错失世界的美好。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ives's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis源码分析之数据库存储结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 10:48:55" itemprop="dateCreated datePublished" datetime="2020-04-04T10:48:55+08:00">2020-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index">
                    <span itemprop="name">c/c++</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>redis作为一个key-value存储系统，是如何做到高效的呢？在内存中维护一个hash表，hash表的操作时间复杂度是O(1),但是hash是由一定概率发生hash碰撞的，通常做法是还会维护一个list，以确保数据完整性。但是这个list一旦过长，速率必然明显下降，所以一定要有足够的空间分配来避免list过长，而redis是怎么灵活控制内存伸缩的呢？下面从源码着手查找原因。</p>
<a id="more"></a>
<h2 id="选择HASH算法"><a href="#选择HASH算法" class="headerlink" title="选择HASH算法"></a>选择HASH算法</h2><p>作为一个高效查找的数据库，从大量数据中查找一条数据，速度上来说的话，hash以O(1)的时间复杂度远胜于list，红黑树等现存数据结构。具体做法是怎样呢？</p>
<blockquote>
<p>hash为何是O(1)的时间复杂度，这里简单说明一下hash，hash是将给定的一串数字<code>sdafdf123123</code>，可以是字符串或者任意数字，通过<code>hash(&quot;sdafdf123123&quot;)</code>比如选择md5算法，得到一个散列值<code>7ce989929a0f0f862d71c8f67352a97d</code>,哪怕用时下优秀的MurmurHash算法，如下图：<br><img src="hash.jpg" alt=""><br>将图中的散列值作为索引，依然可以看出这是一个非常庞大的内存数组。所以通常我们会设置成固定大小的数组，然后以<code>hash(key)%size</code>作为索引，并在value加上key的list信息来报存完整数据，达到节省内存空间的目的。</p>
</blockquote>
<p><strong>例如</strong>：需要存储一个<code>key-value</code>结构，则实际存储的是<code>hash(key)%size-value</code>.</p>
<p>通过上述介绍，我们可以知道，我们不可能用上千万的TB内存去存储散列值，一定会选择类似取余的运算（redis选择的是直接位与运算<code>&amp;</code>），选择取余运算这就必然出现“碰撞”，所以每个键值对维护的列表必然会增长意味着时间必然上升，而且hash本身也会有碰撞，即使是再好的算法只是降低了碰撞率，所以我们必须在内存空间和时间空间上做一个优化选择，redis是如何权衡这种保证速度的情况下，还能对空间自由缩放的呢？</p>
<h2 id="redis的字典"><a href="#redis的字典" class="headerlink" title="redis的字典"></a>redis的字典</h2><p>redis的hash算法具体见<code>sha1.c</code>。每个redis字典有两个<code>hash table</code>(hash表)。</p>
<h3 id="redis的哈希表"><a href="#redis的哈希表" class="headerlink" title="redis的哈希表"></a>redis的哈希表</h3><p>首先我们介绍redis中的hash表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     </span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个<code>键值对</code>；</p>
</li>
<li><p>size 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（<code>键值对</code>）的数量；</p>
</li>
<li><p>sizemask 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面；</p>
</li>
<li><p>used属性，表示hash表里已有的数量。<br>如下图展示了一个空的hash表：<br><img src="empty_hash_table.png" alt="redis空的hash表"></p>
</li>
</ul>
<h3 id="hash表节点"><a href="#hash表节点" class="headerlink" title="hash表节点"></a>hash表节点</h3><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数，或者是double类型。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决<code>键冲突（collision）</code>的问题。</p>
<p>举个例子， 下图图就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。<br><img src="hash_table_node.jpg" alt="hash表节点"></p>
<h3 id="redis字典"><a href="#redis字典" class="headerlink" title="redis字典"></a>redis字典</h3><p>先来看字典的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字典类型</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典的私有数据,供type使用</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 两张哈希表，默认使用ht[0],当需要进行rehash的时候，会利用ht[1]进行</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash的索引，当没有进行rehash时其值为-1</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash表的迭代器，一般用于rehash和主从复制等等</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的，<strong>个人理解相当于C++的自定义类，你需要传入它的构造函数，比较函数，析构函数</strong>：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， <code>Redis</code> 会为用途不同的字典设置不同的类型特定函数。</li>
<li><code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 <code>rehash</code> 时使用。</p>
<blockquote>
<p>注解：</p>
<p><code>rehash</code>是什么？什么时候触发？<code>rehash</code>的步骤？</p>
<p><code>rehash</code>其实是一个从新分配空间的操作。hash表里的空间不够用或者空间空闲太多的时候，就利用ht[1]去进行扩容或者缩减空间。</p>
</blockquote>
<p>除了 ht[1] 之外， 另一个和 <code>rehash</code> 有关的属性就是 <code>rehashidx</code> ： 它记录了 <code>rehash</code> 目前的进度， 如果目前没有在进行 <code>rehash</code> ， 那么它的值为 -1 。</p>
<p>如下图展示了一个普通的字典：<br><img src="dict.png" alt="字典"></p>
<p>初始时，字典的hash表的大小只有4（<code>sizemask</code>为3），那么通过hash函数计算出的hash值可能会很大，此时hash值会与上（&amp;）<code>sizemask</code>，得到存储在hash表里的table[index]，见如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>比如我们dictFind的实现，通过key获取hash表的节点（即通过key获取value）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入键值对到字典</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果正在rehash，插入到ht[1],否则插入到ht[0]</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典中查找key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];<span class="comment">//这里只是找到索引，索引相同未必key相同</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//key比较，相同，返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，我们上文说到了4个url，那是如何存储到一个空的hash表里的呢？</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>hash</th>
<th>hash &amp; sizemask (index)</th>
</tr>
</thead>
<tbody><tr>
<td>baidu</td>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td>
<td>6912155183386829266</td>
<td>2</td>
</tr>
<tr>
<td>taobao</td>
<td><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></td>
<td>16210426838115629763</td>
<td>3</td>
</tr>
<tr>
<td>xinlang</td>
<td><a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></td>
<td>5168022858719342865</td>
<td>1</td>
</tr>
<tr>
<td>csdn</td>
<td><a href="http://www.csdn.com" target="_blank" rel="noopener">www.csdn.com</a></td>
<td>9700202312283457906</td>
<td>2</td>
</tr>
</tbody></table>
<p>插入到字典后，字典结构如下：<br><img src="urls_dict.jpg" alt="urls字典"></p>
<p><font color=red>总结下：hash表是随着K-V数量的增大而逐步增大的，并不直接以key的hash值为下标去取值得，而是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是一个链表，如果hash &amp; sizemask有冲突，则也把冲突key放在hash表的链表上，取值的时候还得遍历hash表里的链表。</font></p>
<h2 id="redis的数据库的结构"><a href="#redis的数据库的结构" class="headerlink" title="redis的数据库的结构"></a>redis的数据库的结构</h2><p>在redis的内部，有一个redisServer结构体的全局变量server，server保存了redis服务端所有的信息，包括当前进程的PID、服务器的端口号、数据库个数、统计信息等等。当然，它也包含了数据库信息，包括数据库的个数、以及一个redisDb数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="keyword">int</span> dbnum;    <span class="comment">/* Total number of configured DBs */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>显然，<code>dbnum</code>就是<code>redisDb</code>数组的长度，每一个数据库，都对应于一个<code>redisDb</code>，在redis的客户端中，可以通过select N来选择使用哪一个数据库，各个数据库之间互相独立。例如：可以在不同的数据库中同时存在名为“baidu”的key。</p>
<p>从上面的分析中可以看到，server是一个全局变量，它包含了若干个<code>redisDb</code>，每一个<code>redisDb</code>是一个<code>keyspace</code>(译作键空间)，各个<code>keyspace</code>互相独立，互不干扰。</p>
<p>下面来看一下redisDb的定义：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the 'id' field in the structure. */</span></span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict; </span>                <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    <span class="keyword">dict </span>*expires<span class="comment">;              /* Timeout of keys with a timeout set */</span></span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">blocking_keys; </span>       <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    <span class="keyword">dict </span>*ready_keys<span class="comment">;           /* Blocked keys that received a PUSH */</span></span><br><span class="line">    <span class="keyword">dict </span>*watched_keys<span class="comment">;         /* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    int id<span class="comment">;                     /* Database ID */</span></span><br><span class="line">    long long avg_ttl<span class="comment">;          /* Average TTL, just for stats */</span></span><br><span class="line">    list *defrag_later<span class="comment">;         /* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>redis的每一个数据库是一个独立的<code>keyspace</code>，因此，我们理所当然的认为，redis的数据库是一个hash表。但是，从redisDb的定义来看，它并不是一个hash表，而是一个包含了很多hash表的结构。之所以这样做，是因为redis还需要提供除了set、get以外更加丰富的功能(例如：键的超时机制)。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（ratio）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<blockquote>
<p>官方叫比率，可以认为是哈希表的使用率：ratio = ht[0].used / ht[0].size</p>
</blockquote>
<p>比如，hash表的size为4，如果已经插入了4个k-v的话，则ratio 为 1</p>
<blockquote>
<p>ratio = 4 / 4 = 1</p>
</blockquote>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的策略如下：</p>
<ul>
<li><ol>
<li>如果ratio小于0.1，则会对hash表进行收缩操作</li>
</ol>
</li>
<li><ol start="2">
<li>服务器目前没有在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令， 并且哈希表的负载因子大于等于 1 ，则扩容hash表，扩容大小为当前<code>ht[0].used*2</code>   </li>
</ol>
</li>
<li><ol start="3">
<li>服务器目前正在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令， 并且哈希表的负载因子大于等于 5，则扩容hash表，并且扩容大小为当前<code>ht[0].used*2</code></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE      4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHTABLE_MIN_FILL        10</span></span><br><span class="line"><span class="comment">//需要收缩条件判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">size</span>, used;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">size</span> &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/<span class="built_in">size</span> &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容条件判断</span></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dictExpand会调用下面这个函数计算扩容大小</span></span><br><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="built_in">size</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上文说的扩容为ht[0].uesd*2 是不严谨的，实际上是一个刚好大于等于该数的2的N次方,比如used=5,实际扩容不是2 * 5=10，而是2^4=8.</p>
<p>扩容的步骤如下：<br>1、为字典ht[1]哈希表分配合适的空间；<br>2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上；<br>3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>上一节说过， 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， <font color=red>为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</font></p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。  </li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。  </li>
<li><font color=red>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会额外花1毫秒的时间将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 。当 rehash 工作成功之后， 程序将 rehashidx 属性的值增一，一毫秒的时间其实是能rehash很多的，就算一次性rehash不完，下次更新操作的时候继续执行rehash。</font></li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上，甚至是后台启动一个定时器，每次时间循环时只工作一毫秒， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据迁移任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">databasesCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Perform hash tables rehashing if needed, but only if there are no</span></span><br><span class="line"><span class="comment">     * other processes saving the DB on disk. Otherwise rehashing is bad</span></span><br><span class="line"><span class="comment">     * as will cause a lot of copy-on-write of memory pages. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每调用一次最多迁移16条数据到新的hash表</span></span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;<span class="comment">//宏CRON_DBS_PER_CALL = 16</span></span><br><span class="line">        <span class="comment">/* Resize */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum);</span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rehash */</span></span><br><span class="line">        <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> work_done = incrementallyRehash(rehash_db);</span><br><span class="line">                <span class="keyword">if</span> (work_done) &#123;</span><br><span class="line">                    <span class="comment">/* If the function did some work, stop here, we'll do</span></span><br><span class="line"><span class="comment">                     * more at the next cron loop. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* If this db didn't need rehash, we'll try the next one. */</span></span><br><span class="line">                    rehash_db++;</span><br><span class="line">                    rehash_db %= server.dbnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our hash table implementation performs rehashing incrementally while</span></span><br><span class="line"><span class="comment"> * we write/read from the hash table. Still if the server is idle, the hash</span></span><br><span class="line"><span class="comment"> * table will use two tables for a long time. So we try to use 1 millisecond</span></span><br><span class="line"><span class="comment"> * of CPU time at every call of this function to perform some rehahsing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 1 if some rehashing was performed, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned. */</span></span><br><span class="line"><span class="comment">//每次读/写的时候花1毫秒的时间去执行rehash操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementallyRehash</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Keys dictionary */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].dict)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].dict,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Expires */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].expires)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].expires,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>那么hash表里的一个个对象都是什么呢？<br>下面请看C语言版“继承”的实现，是不是很有趣？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redis里的对象有11种，他们全都继承于redisObject。type属性，就是各对象的识别属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>
<p>本文参考了<a href="https://www.jianshu.com/p/bfecf4ccf28b" target="_blank" rel="noopener">wenmingxing Redis之字典</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechatpay.png" alt="Ives 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ives
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://icevil.cn/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" title="Redis源码分析之数据库存储结构">https://icevil.cn/2020/04/04/Redis源码分析之数据库存储结构/</a>                   
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="https://twitter.com/Ives">
                <span class="icon">
                  <i class="fa fa-twitter"></i>
                </span>

                <span class="label">Twitter</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/images/wechat.png">
                <span class="icon">
                  <i class="fa fa-wechat"></i>
                </span>

                <span class="label">WeChat</span>
              </a>
            </div>

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"><i class="fa fa-tag"></i> redis</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a>
              <a href="/tags/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 存储结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="prev" title="进程间通信与线程同步">
      <i class="fa fa-chevron-left"></i> 进程间通信与线程同步
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/06/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" rel="next" title="内存对齐">
      内存对齐 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#选择HASH算法"><span class="nav-number">1.</span> <span class="nav-text">选择HASH算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis的字典"><span class="nav-number">2.</span> <span class="nav-text">redis的字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis的哈希表"><span class="nav-number">2.1.</span> <span class="nav-text">redis的哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash表节点"><span class="nav-number">2.2.</span> <span class="nav-text">hash表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis字典"><span class="nav-number">2.3.</span> <span class="nav-text">redis字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis的数据库的结构"><span class="nav-number">3.</span> <span class="nav-text">redis的数据库的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rehash"><span class="nav-number">4.</span> <span class="nav-text">rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐进式rehash"><span class="nav-number">5.</span> <span class="nav-text">渐进式rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redisObject"><span class="nav-number">6.</span> <span class="nav-text">redisObject</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ives"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ives</p>
  <div class="site-description" itemprop="description">当你开始满于现状时，你正在错失世界的美好。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:somepure@foxmail.com" title="E-Mail → mailto:somepure@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
    <!--插入外链-->
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" height=240 src="//music.163.com/outchain/player?type=0&id=4866221043&auto=0&height=430"></iframe>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19149780号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">版权归原作者Ives所有，转载请标注。</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">190k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:53</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
