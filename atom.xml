<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ives&#39;s Blog</title>
  
  <subtitle>Reading maketh a full man; conference a ready man; and writing an exact man. --Fransis Bacon</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icevil.cn/"/>
  <updated>2020-03-05T09:43:27.105Z</updated>
  <id>https://icevil.cn/</id>
  
  <author>
    <name>Ives</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VS使用WSL开发Linux程序配置说明</title>
    <link href="https://icevil.cn/2020/03/05/VS%E4%BD%BF%E7%94%A8WSL%E5%BC%80%E5%8F%91Linux%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <id>https://icevil.cn/2020/03/05/VS%E4%BD%BF%E7%94%A8WSL%E5%BC%80%E5%8F%91Linux%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</id>
    <published>2020-03-05T08:57:15.000Z</published>
    <updated>2020-03-05T09:43:27.105Z</updated>
    
    <content type="html"><![CDATA[<p>自Visual Studio 2019（简称vs）16.1版本开始，vs已经能够很好的支持WSL了，我们可以通过ssh连接在WSL上开发并调试c/c++程序。</p><a id="more"></a><p>Windows Subsystem for Linux (WSL) 第一次出现是在2016年的微软开发者大会上。现在win10的应用商店已经有好几版本的WSL系统了，尤其Ubuntu LTS版本最为受欢迎，下面也以Ubuntu为例。</p><h2 id="安装WSL-ubuntu"><a href="#安装WSL-ubuntu" class="headerlink" title="安装WSL(ubuntu)"></a>安装WSL(ubuntu)</h2><ol><li>首先我们要在win10启用开发者模式</li><li>然后去应用商店下载即可，<br>安装完成后，会提升我们呢输入用户名密码如下图<br><img src="bash-install-500x282.png" alt=""></li><li>安装c/c++必要的编译调试环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment">#We’ll also need to install gdbserver, a program that allows you to debug with a remote GDB debugger.</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install -y gdbserver</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装-amp-配置SSH"><a href="#安装-amp-配置SSH" class="headerlink" title="安装&amp;配置SSH"></a>安装&amp;配置SSH</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装ssh</span></span><br><span class="line">$ sudo apt install -y openssh-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh</span></span><br><span class="line"></span><br><span class="line">$ sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到 “PasswordAuthentication” 设置成 “yes”然后保存退出,如下图。<br><img src="bash-nanosshd-454x350.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成ssh keys</span></span><br><span class="line"></span><br><span class="line">$ sudo ssh-keygen -A</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动ssh，如果已经启动可以用restar替换start</span></span><br><span class="line"></span><br><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure><h2 id="安装-amp-配置Visual-Studio"><a href="#安装-amp-配置Visual-Studio" class="headerlink" title="安装&amp;配置Visual Studio"></a>安装&amp;配置Visual Studio</h2><p>下载安装vs17版本以上，最好19以上，安装的时候注意选择<code>Visual C++ for Linux</code>，安装完成后打开vs就有一下界面<br><img src="bashinstalllinux-500x293.png" alt=""><br>现在就可以连接到WSL了，操作如下：<br><code>Tools &gt; Options &gt; Cross Platform &gt; Connection Manager</code>.<br>如下图让你输入ip，端口，用户名，密码远程连接Linux了。其实如果不是wsl，是其他的Linux系统如子网或者公网的Linux系统都是可以的，前提是我们配置正确。<br><img src="bashconnectionmanager-500x290.png" alt=""></p><p>如果连接成功，vs会下载一些系统头文件到本地，方便我们编码时的智能感知提醒。至此我们的编译器就可使用了，新建工程试试。<br><code>File &gt; New Project &gt; Visual C++ &gt; Cross Platform &gt; Linux</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自Visual Studio 2019（简称vs）16.1版本开始，vs已经能够很好的支持WSL了，我们可以通过ssh连接在WSL上开发并调试c/c++程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="https://icevil.cn/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="vs" scheme="https://icevil.cn/tags/vs/"/>
    
      <category term="visual studio" scheme="https://icevil.cn/tags/visual-studio/"/>
    
      <category term="wsl" scheme="https://icevil.cn/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>Docker介绍及使用</title>
    <link href="https://icevil.cn/2020/03/01/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://icevil.cn/2020/03/01/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-01T02:24:56.000Z</published>
    <updated>2020-03-01T07:16:49.058Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><a id="more"></a><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>Docker 包括三个基本概念: </p><ul><li><p>镜像（Image）：<br>Docker 镜像（Image），就相当于是一个 root 文件系统。 比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系 统的 root 文件系统。 </p></li><li><p>容器（Container）：<br>镜像（Image）和容器（Container）的关系，就像是 面向对象程序设计中的类和实例一样如下表，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建Docker 容器。</p><table><thead><tr><th align="center">docker概念</th><th align="center">面向对象概念</th></tr></thead><tbody><tr><td align="center">容器</td><td align="center">对象</td></tr><tr><td align="center">镜像</td><td align="center">类</td></tr></tbody></table></li><li><p>仓库（Repository）：<br>仓库可看着一个代码控制中心，用来保存镜像</p><h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><h3 id="1-安裝"><a href="#1-安裝" class="headerlink" title="1. 安裝"></a>1. 安裝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不到300M</span></span><br><span class="line"><span class="comment">#sudo apt-get install docker在Ubuntu16以上要加.io</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="comment">#查看docker版本</span></span><br><span class="line">docker –v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安裝必要的系統工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment">#安裝GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/dockerce/linux/ubuntu/gpg | sudo apt-key add – </span><br><span class="line"></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span> </span><br><span class="line"> </span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install docker-ce –y </span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看 docker-ce 版本 </span></span><br><span class="line">sudo apt-cache madison docker-ce </span><br><span class="line"><span class="comment">#安装指定版本的 Docker-CE </span></span><br><span class="line">sudo apt-get install docker-ce=17.06.0~ce-0~ubuntu</span><br></pre></td></tr></table></figure></li><li><p><em>docker安装成功后，后续docker操作基本都要root权限，所以建议干脆直接切root账号。*</em></p></li></ul><h3 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2. 镜像仓库"></a>2. 镜像仓库</h3><p>查看可用的 Ubuntu 版本 访问 <a href="https://hub.docker.com" target="_blank" rel="noopener">Ubuntu 镜像库地址</a>。 可以通过 Sort by 查 看 其 他 版 本 的 Ubuntu 。 默 认 是 最 新 版 本 ubuntu:latest 。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所以镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 拉取ubuntu14.04</span></span><br><span class="line">docker pull ubuntu:14.04</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 启动已停止运行的容器'df9c1758dde1'，命令如下： </span></span><br><span class="line">docker start df9c1758dde1</span><br><span class="line"><span class="comment"># 查看容器所以命令</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 停止容器的命令如下： </span></span><br><span class="line">docker stop df9c1758dde1</span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart df9c1758dde1</span><br><span class="line"><span class="comment"># 进入容器两种方式attach与exec</span></span><br><span class="line">docker attach df9c1758dde1</span><br><span class="line">docker <span class="built_in">exec</span> -it df9c1758dde1 /bin/bash </span><br><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> df9c1758dde1 &gt; ubuntu.tar</span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">cat ubuntu.tar | docker import - ubuntu:v1</span><br><span class="line"><span class="comment"># 删除容器 </span></span><br><span class="line">docker rm -f b87fcf19d529 </span><br><span class="line"><span class="comment"># 拉取最新版Nginx</span></span><br><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><p>容器不退出，返回宿主机快捷键：<kbd>ctrl</kbd>+<kbd>p</kbd>+<kbd>q</kbd>，进入容器推荐<code>exec</code>；如果使用<code>attach</code>，多个终端登入的话会相互影响。<br>安装完成后，我们可以使用以下命令来运行 nginx 容器：<br><code>docker run --name nginx-test -p 8080:80 -d nginx</code> </p><ul><li>–name nginx-test：容器名称。 </li><li>-p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。 </li><li>-d nginx： 设置容器在在后台一直运行。 </li></ul><h3 id="3-定制镜像-Dockerfile"><a href="#3-定制镜像-Dockerfile" class="headerlink" title="3. 定制镜像 Dockerfile"></a>3. 定制镜像 Dockerfile</h3><pre><code>编写`Dockerfile`，然后执行`docker build -t 名称:tag .` </code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定制nginx的Dockfile如下</span></span><br><span class="line"><span class="comment"># This is dockerfile for nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># base image</span></span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># author</span></span><br><span class="line">MAINTAINER 作者名 myname@email.com</span><br><span class="line"></span><br><span class="line">ADD nginx-1.13.7.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD pcre-8.41.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD zlib-1.2.11.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD openssl-1.1.0g.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line"></span><br><span class="line">ADD sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install build-essential -y</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span>/src/nginx-1.13.7</span><br><span class="line"></span><br><span class="line">RUN ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_realip_module --with-http_addition_module --with-http_gzip_static_module --with-http_secure_link_module --with-http_stub_status_module --with-stream --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 --with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 --with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.1.0g &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"daemon off;"</span> &gt;&gt; /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/usr/local/nginx/sbin/nginx"</span>, <span class="string">"-c"</span>, <span class="string">"/usr/local/nginx/conf/nginx.conf"</span>]</span><br></pre></td></tr></table></figure><h2 id="文件系统隔离"><a href="#文件系统隔离" class="headerlink" title="文件系统隔离"></a>文件系统隔离</h2><p>docker里面不能直接使用<code>apt</code>这些系统命令，需要在前面加<code>/usr/bin/</code>如：<code>/usr/bin/apt-get</code>,加环境变量也可以</p><h3 id="docker实现原理："><a href="#docker实现原理：" class="headerlink" title="docker实现原理："></a>docker实现原理：</h3><ol><li>Mount namespace:挂载隔离，可以将日志文件共享到物理机，也可以通过该机制从docker拷贝文件到物理机。</li><li>UTS namespace:主机名的隔离，进入docker后，我们能看到终端的主机名会发生改变，不再是宿主机的hostname。</li><li>IPC namespace:两个进程间不能通过ipc技术通信</li><li>PID namespace:单独的pid系统，各docker都是从1开始，相当于Linux的init进程</li><li>Network namespace:网络不复用，网络不共享</li><li>User namespace:用户名隔离，与系统用户不一样</li></ol><p>以上6种隔离技术原理推荐阅读链接</p><p><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（上）</a><br><a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（下）</a><br>下面详述一下复杂的<code>Network namespace</code>.内容是copy上述链接中的，如果原链接能访问建议访问原链接，感谢<code>作者陈皓</code>。<br>在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p><p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）<br><img src="networknamespace.jpg" alt="" title="network namespace"><br>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p><p>当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hchen@ubuntu:~$ ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...</span><br><span class="line">    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>那么，要做成这个样子应该怎么办呢？我们来看一组命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 接下来，我们要创建一个network namespace - ns1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1   ip link <span class="built_in">set</span> dev lo up </span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 <span class="built_in">type</span> veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1  ip link <span class="built_in">set</span> dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1     ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure><p>上面基本上就是docker网络的原理了，只不过，</p><ul><li>Docker的resolv.conf没有用这样的方式，而是用了<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">上篇中的Mount Namesapce的那种方式</a></li><li>另外，docker是用进程的PID来做Network Namespace的名称的。<br>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link add peerA <span class="built_in">type</span> veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link <span class="built_in">set</span> peerA up </span><br><span class="line">ip link <span class="built_in">set</span> peerB netns <span class="variable">$&#123;container-pid&#125;</span> </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> dev peerB name eth1 </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> eth1 up ; </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip addr add <span class="variable">$&#123;ROUTEABLE_IP&#125;</span> dev eth1 ;</span><br></pre></td></tr></table></figure>上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</li></ul><p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p><p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p><p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a href="https://lwn.net/Articles/620087/" target="_blank" rel="noopener">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="docker" scheme="https://icevil.cn/tags/docker/"/>
    
      <category term="容器" scheme="https://icevil.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="镜像" scheme="https://icevil.cn/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>搭建gitlab仓库</title>
    <link href="https://icevil.cn/2020/02/09/%E6%90%AD%E5%BB%BAgitlab%E4%BB%93%E5%BA%93/"/>
    <id>https://icevil.cn/2020/02/09/%E6%90%AD%E5%BB%BAgitlab%E4%BB%93%E5%BA%93/</id>
    <published>2020-02-09T10:30:56.000Z</published>
    <updated>2020-03-09T12:31:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>我们熟知github这个强大的源代码管理仓库，利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。但是介意外网访问速度的原因，以及企业安全的角度，我们通常考虑自己搭建自己的类似hub站点，其实个人使用的话，我觉得完全没必要搭建hub，在公网平台上搭一个远程仓库就够用了。而本文将主要以Ubuntu18为例讲解如何搭建一个自己的gitlab仓库，好了写本文的目的估计都猜到了，没错，就是出于练手。</p><a id="more"></a><h2 id="github的特点"><a href="#github的特点" class="headerlink" title="github的特点"></a>github的特点</h2><p>Repo：项目，绝大多数的开源项目都会放在github上，包括<code>Linus Torvalds</code>参与的linux内核，基于repo可以提<br>      issue，可以review code，可以有wiki，branch，tag等等都支持，还可以star和fork这样的repo。<br>Explore：基于兴趣显示了一些开源项目<br>Topics：按照主题显示的一些项目，可以选择某个主题继续观察<br>Trending：流行repo，可以选择语言和周期来显示<br>Events：显示github官方的一些活动</p><p>我们可以通过搜索关键字、stars:&gt;1000、fork:&gt;100、语言等来搜索高质量的仓库。</p><h2 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h2><p>GitLab是利用 <code>Ruby on Rails</code> 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。很多公司都是基于gitlab进行版本管理的。</p><h2 id="搭建gitlab"><a href="#搭建gitlab" class="headerlink" title="搭建gitlab"></a>搭建gitlab</h2><h3 id="第一步：安装一些依赖软件"><a href="#第一步：安装一些依赖软件" class="headerlink" title="第一步：安装一些依赖软件"></a>第一步：安装一些依赖软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br><span class="line">sudo apt-get install -y postfix  # postfix发送邮件，其它的邮件配置见：https://docs.gitlab.com/omnibus/settings/smtp.html</span><br></pre></td></tr></table></figure><h3 id="第二步：添加下载源："><a href="#第二步：添加下载源：" class="headerlink" title="第二步：添加下载源："></a>第二步：添加下载源：</h3><p>添加下载源之前，如果没有添加GPG信任，需要先信任 GitLab 的 GPG 公钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><p>已信任的可以跳过，如果不添加信任，更新源的时候会有如下错误提示<br><img src="GPG.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list.d/gitlab_gitlab-ee.list </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打开该文件添加：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：版本号别错ubuntu16是xenial,18是bionic</span></span><br><span class="line">deb https://mirrors.tencent.com/gitlab-ce/ubuntu bionic main</span><br><span class="line"><span class="meta">#</span><span class="bash">更新源列表</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>更新源成功如下图：<br><img src="addGPG.png" alt=""></p><h3 id="第三步：安装gitlab"><a href="#第三步：安装gitlab" class="headerlink" title="第三步：安装gitlab"></a>第三步：安装gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><p>安装成功后，如下图：<br><img src="gitlab.png" alt=""></p><h3 id="第四步：配置gitlab"><a href="#第四步：配置gitlab" class="headerlink" title="第四步：配置gitlab"></a>第四步：配置gitlab</h3><p>下面的命令基本要用root权限，所以建议提前<code>sudo -i</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">external_url ‘http://192.168.2.129’ <span class="comment"># 把external_url修改成访问的IP，当然更复杂的配置信息可以参考,</span></span><br><span class="line"><span class="comment">#https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab</span></span><br><span class="line"><span class="comment">#如果用nginx代理可以不配置这个。</span></span><br><span class="line">gitlab-ctl reconfigure  <span class="comment"># 开始配置</span></span><br></pre></td></tr></table></figure><h3 id="第五步：启动重启查看状态："><a href="#第五步：启动重启查看状态：" class="headerlink" title="第五步：启动重启查看状态："></a>第五步：启动重启查看状态：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl restart/start/status/stop     <span class="comment"># 通过gitlab-ctl help都能查看到该信息</span></span><br></pre></td></tr></table></figure><p>启动浏览器访问试试？<br><img src="502.png" alt=""><br>不慌，此时我们可以使用<code>gitlab-ctl tail</code>来查看gitlab的服务日志，通过日志可以看到8080端口被别的进程占用了，那就改个端口咯。</p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>此时需要修改gitlab的配置信息，如下：<br>由于默认gitlab使用80端口，所以，我们需要修改gitlab的默认端口（unicorn会占用8080端口，nginx会占用80端口）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line">nginx[<span class="string">'listen_port'</span>] = 8988 <span class="comment">#nginx外部访问的端口</span></span><br><span class="line">unicorn[<span class="string">'port'</span>] = 8989 <span class="comment">#这个端口是内部nginx跳转的端口这个可以随意设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新配置</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>如果不出意外应该可以看到站点已经可以访问，如下图：<br><img src="succeed.png" alt=""><br>这是第一次登录让你添加新密码的。输入完密码，你会发现要登录，用户名是啥？不要慌，试试：<code>root+您刚设置的新密码</code>。<br>惊喜过后，添加个test仓库试试玩玩？<br><img src="down.png" alt=""></p><h3 id="有没有疑问您的仓库存储在了哪里？"><a href="#有没有疑问您的仓库存储在了哪里？" class="headerlink" title="有没有疑问您的仓库存储在了哪里？"></a>有没有疑问您的仓库存储在了哪里？</h3><p>gitlab默认路径是：<code>/var/opt/gitlab/git-data/repositories</code><br>cd进去看看？看不出就对了，这是git的文件镜像，不是给人读的文件。<br>如果要进行git仓库的迁移,做如下操作</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 准备迁移之前要停止GitLab服务，防止用户写入数据。</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"><span class="meta"># 注意 'repositories'后面不带斜杠，而</span></span><br><span class="line"><span class="meta"># '/home/gitlab-data'后面是有斜杠的。</span></span><br><span class="line"> rsync -av /<span class="keyword">var</span>/opt/gitlab/git-data/repositories /home/gitlab-data/</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果需要修复权限设置，</span></span><br><span class="line"><span class="meta"># 可运行下面的命令进行修复。</span></span><br><span class="line"> gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="meta"># 再次检查下  /home/gitlab-data 的目录. 正常情况应该有下面这个子目录:</span></span><br><span class="line"><span class="meta"># repositories</span></span><br><span class="line"></span><br><span class="line"> ls /home/gitlab-data/</span><br><span class="line">repositories</span><br><span class="line"><span class="meta"># 完工! 启动GitLab，验证下是否能</span></span><br><span class="line"><span class="meta"># 通过web访问Git仓库。</span></span><br><span class="line"> gitlab-ctl start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们熟知github这个强大的源代码管理仓库，利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。但是介意外网访问速度的原因，以及企业安全的角度，我们通常考虑自己搭建自己的类似hub站点，其实个人使用的话，我觉得完全没必要搭建hub，在公网平台上搭一个远程仓库就够用了。而本文将主要以Ubuntu18为例讲解如何搭建一个自己的gitlab仓库，好了写本文的目的估计都猜到了，没错，就是出于练手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="git" scheme="https://icevil.cn/tags/git/"/>
    
      <category term="github" scheme="https://icevil.cn/tags/github/"/>
    
      <category term="gitlab" scheme="https://icevil.cn/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://icevil.cn/2020/02/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://icevil.cn/2020/02/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-02-04T02:34:40.000Z</published>
    <updated>2020-02-29T03:09:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。过滤器还能干啥？老东西为何又突然热了起来？假设我们要做一个爬虫程序，如何判断某个地址已经被爬过了？一个海量数据集中如何判断某个值是否存在？带着问题去思考，请看下面详解。</p><a id="more"></a><p>我们已经知道map（前面已经说过基于红黑树实现的）已经起到了很好的查找效率，如100w的数据量，我们也只需要20次查找即可。</p><p>就算嫌弃速度慢了，我们也可以用hashmap这样的数据结构，hashmap能保证我们O(1)查找，但是我们需要知道的是hashmap是一个空间换时间的数据结构，由一个巨大的hash(key)组成的数组，且每个数值下面还有一个列表用以保存hash碰撞的数据。4G内存空间也就是$2^{32}$字节。假设我们用的是32位hash算法也就10亿数据量，再留空一部分，以及保存hash碰撞的数据，我们一般不能存储超过5亿数据量，否则hash碰撞多了，效率会下降。</p><p><span style=color:red>那有没有省时省空间的算法呢？<span><br>那么这就算布隆过滤器又被人们热谈的原因了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>由一系列hash函数转换之后得到的值作为position的<code>bitmap数据结构</code></strong>——本人自定义，不嫌麻烦的还是去百度搜吧。</p><p>百度盗个图，以图解说bloom算法<br><img src="bloom.jpg" alt="布隆过滤器" title="布隆过滤器"><br>这是一个通过3个hash函数得到3个pos,将bitmap的这3个pos置1，即得到了集合S转化后的布隆过滤器B。<br>如图S中的元素a,b,c都是通过3个hash得到的值作为B的下标,然后将<code>相应位置的值 | 1</code>即可。这样当判断d,e是否在集合S中的时候，同样对d,e分别做3次hash得到的3个pos,是否都为1？</p><blockquote><ol><li>如果不全为1，必不在集合S中；</li><li>如果全为1，可能在集合S中</li></ol></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>速度快O(1)</li><li>占空间小<blockquote><p>与hashMap相比，<br>以100w数据量为例，k次hash，也就是 1/k（当然这里k肯定是一个很小的数，k这里绝不是一个线性递减的，而是当k大到一定程度，将趋于不变，而k越大时间开销会成倍增大。具体见文末链接） Mb空间,当然这样的空间是不合理的，碰撞率接近1了，但是与hashmap相比，hashmap碰撞率也将这么高.<br>而hashmap，32位hash算法为例，约用32M空间做key，还没算value对应的list空间。<br>占$&lt; 1/32k$.</p></blockquote></li></ol><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol><li>不能删除元素，只能增加元素</li><li>只能判断可能在，这是一个概率结果，该算法能优化的也就是在大概率存在。不能保证存在。</li></ol><h2 id="布隆过滤器具体参数关系参考"><a href="#布隆过滤器具体参数关系参考" class="headerlink" title="布隆过滤器具体参数关系参考"></a>布隆过滤器具体参数关系参考</h2><p><a href="https://hur.st/bloomfilter" target="_blank" rel="noopener">各参数对应假阳概率关系</a></p><blockquote><p>n为容量<br>p为假阳概率<br>m为所需内存空间<br>k为hash数量</p></blockquote><iframe src="https://hur.st/bloomfilter/?n=1000000&p=1.0E-7&m=&k=" width="100%" height="100%" frameborder="0">您的浏览器不支持iframe，请升级</iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;布隆过滤器（Bloom Filter）是1970年由布隆提出的。过滤器还能干啥？老东西为何又突然热了起来？假设我们要做一个爬虫程序，如何判断某个地址已经被爬过了？一个海量数据集中如何判断某个值是否存在？带着问题去思考，请看下面详解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://icevil.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="过滤器" scheme="https://icevil.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="bloom" scheme="https://icevil.cn/tags/bloom/"/>
    
      <category term="hash" scheme="https://icevil.cn/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>B树与B+树</title>
    <link href="https://icevil.cn/2020/02/02/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/"/>
    <id>https://icevil.cn/2020/02/02/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</id>
    <published>2020-02-02T03:40:00.000Z</published>
    <updated>2020-02-29T03:09:28.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>B树又写做B-树，做索引的时候，hash ，红黑树效率已经很高了，什么时候要用到B树？</p><a id="more"></a><p>B树的应用：当我们的内存不够支撑的时候，往往B树的效率更好。hash,红黑树都是基于内存内数据的高效查找。文件系统的索引，数据库的索引都是采用B树实现。<br>那为什么B树在磁盘访问的时候更高效呢？<br>原因：如果用二叉树，1024个节点，我们需要一个10层高的二叉树。10层高，就相当于我们需要访问10次磁盘才能找到相应值。磁盘的访问速度是远不如内存的。故二叉树性能会显得格外低，那我们必然会考虑到多叉树，如果是毫无约束的多叉树，<strong>树就可能变成一个链表，性能将降到最低状态。</strong>所以有必要对多叉树做适当的约束，而B树就是这样的一个<strong>自平衡的多叉树</strong>数据结构。</p><h3 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h3><p>一颗M阶B树T，满足以下条件 </p><ol><li>每个结点至多拥有M棵子树 </li><li>根结点至少拥有两棵子树 </li><li>除了根结点以外，其余每个分支结点至少拥有M/2棵子树 </li><li><span style=color:red> 所有的叶子结点都在同一层上 </span></li><li><span style=color:red>有k棵子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序</span> </li><li>关键字数量满足 ceil(M/2) - 1 &lt;= n &lt;= M-11</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义M的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEGREE5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KEY_VALUE;</span><br><span class="line"><span class="comment">//B树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> &#123;</span></span><br><span class="line">    KEY_VALUE *keys;<span class="comment">//key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> **<span class="title">childrens</span>;</span><span class="comment">//子结点地址</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//子结点长度应该是M-1</span></span><br><span class="line">    <span class="keyword">int</span> leaf;<span class="comment">//是否叶子结点</span></span><br><span class="line">&#125; btree_node;</span><br><span class="line"><span class="comment">//B树的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree</span> &#123;</span></span><br><span class="line">    btree_node *root;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="comment">//M值</span></span><br><span class="line">&#125; btree;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol><li>插入值，总是从根结点开始插入</li><li>插入结点长度 &lt;M 直接插入</li><li>等于M 需要裂变，裂变从根结点开始裂变<ol><li>创建一个空的结点</li><li>将裂变位置右边的给新结点，准备将裂变位置给父节点</li><li>遍历父节点从i位置开始全部右移一位，给裂变点空出位置</li><li>将裂变点赋值给父节点i位置</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//树T的x结点从i位置开始裂变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_split_child</span><span class="params">(btree *T, btree_node *x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = T-&gt;t;</span><br><span class="line"></span><br><span class="line">    btree_node *y = x-&gt;childrens[i];<span class="comment">//y是开始裂变的结点</span></span><br><span class="line">    btree_node *z = btree_create_node(t, y-&gt;leaf);<span class="comment">//创建一个空结点位置以便插入新值</span></span><br><span class="line"></span><br><span class="line">    z-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将i右边的值先移到新的结点z中</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t<span class="number">-1</span>;j ++) &#123;</span><br><span class="line">        z-&gt;keys[j] = y-&gt;keys[j+t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;leaf == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t;j ++) &#123;</span><br><span class="line">            z-&gt;childrens[j] = y-&gt;childrens[j+t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父结点x大于i的右移,给子结点y空出位置</span></span><br><span class="line">    y-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num;j &gt;= i+<span class="number">1</span>;j --) &#123;</span><br><span class="line">        x-&gt;childrens[j+<span class="number">1</span>] = x-&gt;childrens[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;childrens[i+<span class="number">1</span>] = z;</span><br><span class="line">    <span class="comment">//key值也右移</span></span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num<span class="number">-1</span>;j &gt;= i;j --) &#123;</span><br><span class="line">        x-&gt;keys[j+<span class="number">1</span>] = x-&gt;keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将y移向父节点x</span></span><br><span class="line">    x-&gt;keys[i] = y-&gt;keys[t<span class="number">-1</span>];</span><br><span class="line">    x-&gt;num += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在树T的x结点插入k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert_nonfull</span><span class="params">(btree *T, btree_node *x, KEY_VALUE k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = x-&gt;num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leaf == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) &#123;</span><br><span class="line">            x-&gt;keys[i+<span class="number">1</span>] = x-&gt;keys[i];</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;keys[i+<span class="number">1</span>] = k;</span><br><span class="line">        x-&gt;num += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在非叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) i --;</span><br><span class="line">        <span class="comment">//需要非叶子节点数满，需要裂变</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;childrens[i+<span class="number">1</span>]-&gt;num == (<span class="number">2</span>*(T-&gt;t))<span class="number">-1</span>) &#123;</span><br><span class="line">            btree_split_child(T, x, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; x-&gt;keys[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归插入</span></span><br><span class="line">        btree_insert_nonfull(T, x-&gt;childrens[i+<span class="number">1</span>], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int t = T-&gt;t;</span></span><br><span class="line"></span><br><span class="line">    btree_node *r = T-&gt;root;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;num == <span class="number">2</span> * T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//根结点裂变</span></span><br><span class="line">        <span class="comment">//1.为T创建一个根节点，T变成叶子节点</span></span><br><span class="line">        btree_node *node = btree_create_node(T-&gt;t, <span class="number">0</span>);</span><br><span class="line">        T-&gt;root = node;</span><br><span class="line">        <span class="comment">//2.将T加到根结点第一个位置</span></span><br><span class="line">        node-&gt;childrens[<span class="number">0</span>] = r;</span><br><span class="line">        <span class="comment">//3.将T当作叶子结点裂变</span></span><br><span class="line">        btree_split_child(T, node, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//4.在叶子结点插入新值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;keys[<span class="number">0</span>] &lt; key) i++;</span><br><span class="line">        btree_insert_nonfull(T, node-&gt;childrens[i], key);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接在叶子结点插入新值</span></span><br><span class="line">        btree_insert_nonfull(T, r, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol><li>找到删除节点位置</li><li>归并:把相邻两个节点+父节点的一个值 $\le M$,合二为一再删掉即可<br>当M为5的时候如下图：<br><img src="del1.png" alt="" title="归并删除"></li><li>借值:把相邻两个节点+父节点的一个值 $&gt; M$,将父节点拉下来，将子结点放父位置，再删除即可。<br>当M为5的时候如下图：<br><img src="del2.png" alt="" title="借值删除"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_merge</span><span class="params">(btree *T, btree_node *node, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">    btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////data merge</span></span><br><span class="line">    left-&gt;keys[T-&gt;t<span class="number">-1</span>] = node-&gt;keys[idx];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">        left-&gt;keys[T-&gt;t+i] = right-&gt;keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;leaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t;i ++) &#123;</span><br><span class="line">            left-&gt;childrens[T-&gt;t+i] = right-&gt;childrens[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;num += T-&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destroy right</span></span><br><span class="line">    btree_destroy_node(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node </span></span><br><span class="line">    <span class="keyword">for</span> (i = idx+<span class="number">1</span>;i &lt; node-&gt;num;i ++) &#123;</span><br><span class="line">        node-&gt;keys[i<span class="number">-1</span>] = node-&gt;keys[i];</span><br><span class="line">        node-&gt;childrens[i] = node-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;childrens[i+<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;num -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;root = left;</span><br><span class="line">        btree_destroy_node(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除树T的node节点的key值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_delete_key</span><span class="params">(btree *T, btree_node *node, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx &lt; node-&gt;num &amp;&amp; key &gt; node-&gt;keys[idx]) &#123;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; node-&gt;num &amp;&amp; key == node-&gt;keys[idx]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;leaf) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = idx;i &lt; node-&gt;num<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">                node-&gt;keys[i] = node-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node-&gt;keys[node-&gt;num - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            node-&gt;num--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123; <span class="comment">//root</span></span><br><span class="line">                <span class="built_in">free</span>(node);</span><br><span class="line">                T-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">            node-&gt;keys[idx] = left-&gt;keys[left-&gt;num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, left, left-&gt;keys[left-&gt;num - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx+<span class="number">1</span>]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line">            node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, right, right-&gt;keys[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            btree_merge(T, node, idx);</span><br><span class="line">            btree_delete_key(T, node-&gt;childrens[idx], key);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        btree_node *child = node-&gt;childrens[idx];</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Cannot del key = %d\n"</span>, key);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = <span class="literal">NULL</span>;</span><br><span class="line">            btree_node *right = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                left = node-&gt;childrens[idx<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (idx + <span class="number">1</span> &lt;= node-&gt;num) </span><br><span class="line">                right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((left &amp;&amp; left-&gt;num &gt;= T-&gt;t) ||</span><br><span class="line">                (right &amp;&amp; right-&gt;num &gt;= T-&gt;t)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> richR = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (right) richR = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; right) richR = (right-&gt;num &gt; left-&gt;num) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right &amp;&amp; right-&gt;num &gt;= T-&gt;t &amp;&amp; richR) &#123; <span class="comment">//borrow from next</span></span><br><span class="line">                    child-&gt;keys[child-&gt;num] = node-&gt;keys[idx];</span><br><span class="line">                    child-&gt;childrens[child-&gt;num+<span class="number">1</span>] = right-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; right-&gt;num - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">                        right-&gt;keys[i] = right-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">                        right-&gt;childrens[i] = right-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    right-&gt;keys[right-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    right-&gt;childrens[right-&gt;num<span class="number">-1</span>] = right-&gt;childrens[right-&gt;num];</span><br><span class="line">                    right-&gt;childrens[right-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    right-&gt;num --;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//borrow from prev</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (i = child-&gt;num;i &gt; <span class="number">0</span>;i --) &#123;</span><br><span class="line">                        child-&gt;keys[i] = child-&gt;keys[i<span class="number">-1</span>];</span><br><span class="line">                        child-&gt;childrens[i+<span class="number">1</span>] = child-&gt;childrens[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    child-&gt;childrens[<span class="number">1</span>] = child-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;childrens[<span class="number">0</span>] = left-&gt;childrens[left-&gt;num];</span><br><span class="line">                    child-&gt;keys[<span class="number">0</span>] = node-&gt;keys[idx<span class="number">-1</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    left-&gt;keys[left-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    left-&gt;childrens[left-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    left-&gt;num --;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!left || (left-&gt;num == T-&gt;t - <span class="number">1</span>))</span><br><span class="line">                &amp;&amp; (!right || (right-&gt;num == T-&gt;t - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; left-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx<span class="number">-1</span>);</span><br><span class="line">                    child = left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &amp;&amp; right-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btree_delete_key(T, child, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">btree_delete</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//调递归删除接口</span></span><br><span class="line">    btree_delete_key(T, T-&gt;root, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>首先简单说明一下B+树：<strong>B+树通常用于数据库和操作系统的文件系统中</strong>。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反，<strong>B+树只在叶子结点存储数据，其他结点只保存索引</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:<br>(1)每个结点至多有m个子女；<br>(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；<br>(3)有k个子女的结点必有k个关键字。<br>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。 </p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。 </li><li>如果没有节点处于违规状态则处理结束。 </li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。 </li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。 </li><li>如果没有节点处于违规状态则处理结束。 </li><li>如果节点处于违规状态则有两种可能情况： <ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。 </li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h2 id="B-树与B-树比较"><a href="#B-树与B-树比较" class="headerlink" title="B+树与B-树比较"></a>B+树与B-树比较</h2><blockquote><p>B+树的优势：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>B+树的劣势：<br>1.单点查询，B-树有可能O(1),而B+树永远是B-树的最糟糕情况O(log n).</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><div style=color:red>注意</div></h2><p>这也导致在通用sql数据库中B+树更合适<br>而在mongoDb中，B-树更合适，因为对范围查找要求较低</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B-树&quot;&gt;&lt;/a&gt;B-树&lt;/h2&gt;&lt;p&gt;B树又写做B-树，做索引的时候，hash ，红黑树效率已经很高了，什么时候要用到B树？&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="B树" scheme="https://icevil.cn/tags/B%E6%A0%91/"/>
    
      <category term="B-树" scheme="https://icevil.cn/tags/B-%E6%A0%91/"/>
    
      <category term="B+树" scheme="https://icevil.cn/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从二叉树到红黑树</title>
    <link href="https://icevil.cn/2020/01/28/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://icevil.cn/2020/01/28/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-01-28T03:05:00.000Z</published>
    <updated>2020-02-29T03:09:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>树有很多种，二叉树，多叉树(B-树，B+树)等，本文主要针对几种较为常用的树，做精要记录，梳理逻辑便于长时间之后的理解与记忆。</p><a id="more"></a><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（<code>left subtree</code>）和“右子树”（<code>right subtree</code>）。二叉树常被用于实现二叉查找树和二叉堆。</p><h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>由二叉树的定义，以及图中所示的二叉树的分析可以得出二叉树具有以下几个特点：</p><ol><li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<h3 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h3>除数据域外，主要区别体现形式是左右子树的表示不同</li><li>链式存储<br>用数组表示二叉树，左右子树用数组下标表示<ul><li>优点：查找速度更快</li><li>缺点：不为<code>满二叉树</code>时，浪费了空间，扩展性差或者说插入新数据慢。</li></ul></li><li>链表存储<br>用链表表示二叉树，左右子树用结点指针表示<ul><li>优点：无空间浪费，扩展性好，插入数据快。</li><li>缺点：查找速度略慢。</li></ul></li></ol><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>记住一句话即可。</p><blockquote><p>所有叶子结点都在最下层</p></blockquote><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的 <strong><code>满二叉树</code></strong> 中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><blockquote><p>所有叶子结点都在最下层与次下层</p></blockquote><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>左右子树的高度相差不超过1的树为平衡二叉树，也叫AVL树。<br>注意点：<strong>实现了树的自平衡以提升树的查找效率</strong><br>如何做到自平衡的：<br><img src="rotate.png" alt="" title="自平衡操作"></p><ol><li>左旋<blockquote><p>1.结点的右孩子替代此结点位置<br>2.右孩子的左子树变为该结点的右子树<br>3.结点本身变为右孩子的左子树</p></blockquote></li><li>右旋<blockquote><p>1.结点的左孩子代表此结点<br>2.结点的左孩子的右子树变为结点的左子树<br>3.将此结点作为左孩子结点的右子树</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//y是x的右子结点</span></span><br><span class="line">    rbtree_node *y = x-&gt;right;  <span class="comment">// x  --&gt; y  ,  y --&gt; x,   right --&gt; left,  left --&gt; right</span></span><br><span class="line"></span><br><span class="line">    x-&gt;right = y-&gt;left; <span class="comment">//1 1</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123; <span class="comment">//1 2</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent = x-&gt;parent; <span class="comment">//1 3</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == T-&gt;nil) &#123; <span class="comment">//1 4</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x; <span class="comment">//1 5</span></span><br><span class="line">    x-&gt;parent = y; <span class="comment">//1 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T, rbtree_node *y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//x为y的左子结点</span></span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>红黑树是一种非常重要且应用广泛的数据结构。它是在AVL树的基础上加以改进优化得出的一个高效算法。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：<strong>它可以在O(log n)时间内做查找，插入和删除</strong>。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3></li></ol><ul><li>Linux进程调度CFS</li><li>Nginx Timer事件管理</li><li>Epoll事件块的管理</li><li>STL中set, multiset, map, multimap的实现<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3></li></ul><ol><li>结点是红色或黑色</li><li>根结点是黑色</li><li>每个叶子结点(nil)是黑色</li><li>每个红色结点的两个子结点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色结点)</li><li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</strong><br>从性质5可以知道：如果一个结点存在黑子结点，那么该结点肯定有两个子结点<br>下图Nil为叶子结点，并且它的颜色一定是黑色的。<br><img src="2392382-4996bbfb4017a3b2.png" alt="一颗简单的红黑树" title="一颗简单的红黑树"><br>由图可见，红黑树并不是一个<code>完美平衡二叉查找树</code>,根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<code>黑高平衡</code>。<br>为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如下图<br><img src="2392382-abedf3ecc733ccd5.webp" alt="结点的叫法" title="结点的叫法"></li></ol><h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。从根结点开始查找；</p><blockquote><p>若根结点为空，那么插入结点作为根结点，结束。<br>若根结点不为空，那么把根结点作为当前结点；<br>若当前结点为null，返回当前结点的父结点，结束。<br>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。<br>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；<br>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p></blockquote><p><img src="2392382-7521866b50683a24.webp" alt="数据插入" title="数据插入"></p><p>插入完成后，但插入结点是应该设置成什么颜色呢？<br>答案是<strong>红色</strong>。<em>因为红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡</em>。</p><p><img src="2392382-fa2b78271263d2c8.webp" alt="插入操作脑图" title="插入操作脑图"></p><h3 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h3><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。<br>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡，最后调色。<br>二叉树删除结点找替代结点有3种情情景：</p><p>情景1：若删除结点无子结点，直接删除<br>情景2：若删除结点只有一个子结点，用子结点替换删除结点<br>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图所示。<br><img src="2392382-edaf96e55f08c198.webp" alt="插入操作脑图" title="插入操作脑图"></p><h3 id="红黑树插入删除代码："><a href="#红黑树插入删除代码：" class="headerlink" title="红黑树插入删除代码："></a>红黑树插入删除代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; <span class="comment">//z ---&gt; RED</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right;<span class="comment">//y是z的叔父结点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_left_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_right_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_left_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != T-&gt;nil) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//Exist</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    rbtree_insert_fixup(T, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_delete_fixup</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((x != T-&gt;root) &amp;&amp; (x-&gt;color == BLACK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">         <span class="comment">//w是x的叔父结点   </span></span><br><span class="line">            rbtree_node *w= x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_right_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            rbtree_node *w = x-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_left_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rbtree_node *<span class="title">rbtree_delete</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == T-&gt;nil) || (z-&gt;right == T-&gt;nil)) &#123;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = rbtree_successor(T, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left) &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) &#123;</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line">        z-&gt;value = y-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;color == BLACK) &#123;</span><br><span class="line">        rbtree_delete_fixup(T, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"><a href="#我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解" class="headerlink" title="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"></a>我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解</h3><p><span style=color:red><strong>红黑树有着目前算法中内存读写综合性能最好的数据结构</strong></span>代码要求：不要求能盲打，但是最好能对照定义敲出。另外红黑树的算法论证见算法导论。</p><ol><li>查询速度仅次于hash，但是比hash省空间，几乎等于AVL树</li><li>搜索稳定性能最佳，算法耗时稳定<code>O(long n)</code>（不会出现最长搜索时间，最短搜索时间）</li><li>伸缩性好，写操作也能很快</li><li>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较</li><li>红黑树在插入和删除上优于avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">红黑树图片引用原文链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树有很多种，二叉树，多叉树(B-树，B+树)等，本文主要针对几种较为常用的树，做精要记录，梳理逻辑便于长时间之后的理解与记忆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="tree" scheme="https://icevil.cn/tags/tree/"/>
    
      <category term="rbtree" scheme="https://icevil.cn/tags/rbtree/"/>
    
      <category term="红黑树" scheme="https://icevil.cn/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://icevil.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>几种经典排序算法</title>
    <link href="https://icevil.cn/2020/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://icevil.cn/2020/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-25T01:05:23.000Z</published>
    <updated>2020-02-28T09:32:40.666Z</updated>
    
    <content type="html"><![CDATA[<p>几种常见排序算法比较<br>排序算法有很多，下面统计几种经典排序算法并做比较。</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>个人认为是最简单的排序方式，越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><blockquote><p>每次循环都是为了去找未排序数组中最小的那个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])   <span class="comment">//后者比前者小就交换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = data[i];</span><br><span class="line">                data[i] = data[j];</span><br><span class="line">                data[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由<code>C. A. R. Hoare</code>在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。这和分治思想非常相似。</p><blockquote><p>对数组A[N]快速排序的算法是:</p><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1;</li><li>以第一个数组元素作为关键数据，赋值给key;</li><li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换; </li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换; </li><li>重复第3、4步，直到i=j。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = data[left];   <span class="comment">//找到关键数。这里以第一个为准</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0   </span></span><br><span class="line">    <span class="comment">/*这段代码比下面那段代码更精简，但是下面那段代码更易理解</span></span><br><span class="line"><span class="comment">    while (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">        //1.比key大的放右边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span></span><br><span class="line"><span class="comment">            j --;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[i] = data[j];</span></span><br><span class="line"><span class="comment">        //2.比key小的放左边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span></span><br><span class="line"><span class="comment">            i ++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[j] = data[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    data[i] = key;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//1.比key大的放右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = key;      </span><br><span class="line">        <span class="comment">//2.比key小的放左边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = data[i];</span><br><span class="line">        data[i] = key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    sort(data, left, i - <span class="number">1</span>);</span><br><span class="line">    sort(data, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    sort(data, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,算法适用于少量数据的排序。</p><blockquote><p>从第2个数开始，依次与前面的数比较。<br>如果比前面的数大，不用移动<br>如果比前面的数小，前面的数依次后移，直至出现不小于该值的数，或者位置已以至最前面。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历查找插入位置j</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos&gt;= <span class="number">1</span> &amp;&amp; tmpData &lt; data[pos<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                data[pos] = data[pos<span class="number">-1</span>];</span><br><span class="line">                pos--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[pos] = tmpData;<span class="comment">//找到插入位置，赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>基于插入排序的优化，类似的还有二分查找算法也叫折半查找算法。</p><blockquote><p>在直接插入排序的思维下，加快查找插入位置pos。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，返回该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_insert</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">int</span>* data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)   <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> npos = (left + right) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, left, npos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, npos+<span class="number">1</span>, right);<span class="comment">//注意这里是npos+1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b_insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> npos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            npos = b_insert(tmpData, data, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> n = i;</span><br><span class="line">            <span class="keyword">while</span>( n &gt; npos )</span><br><span class="line">            &#123;</span><br><span class="line">                data[n] = data[n<span class="number">-1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[npos] = tmpData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序法又称缩小增量法，按其设计者希尔（Donald Shell）的名字命名。</p><blockquote><p>先选定一个整数，把待排序文件中所有记录分成2个组，所有距离为 gap = length/2 的记录分在同一组内，并对每一组内的记录进行排序。<br>然后，取重复上述分组和排序的工作。当到达gap=1时，所有记录在同一组内排好序。<br>各组内的排序通常采用直接插入法。由于开始时gap的取值较大，每组内记录数较少，所以排序比较快。<br>随着gap不断减小，每组内的记录数逐步增多，但由于已经按排好序，因此排序速度也比较快</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//外层循环控制增量gap，每次缩减一倍</span></span><br><span class="line">    <span class="keyword">for</span> (gap = length / <span class="number">2</span>;gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对新的数组做 直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap;i &lt; length;i ++) &#123;</span><br><span class="line"></span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i-gap;j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; data[j];j = j - gap) &#123;</span><br><span class="line">                data[j+gap] = data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+gap] = temp;<span class="comment">//将 temp 插入 j+gap 位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（<code>Divide and Conquer</code>）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。</p><blockquote><p>归并操作的工作原理如下：<br>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复上一步直到某一指针超出序列尾,将另一序列剩下的所有元素直接复制到合并序列尾</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start, j = middle+<span class="number">1</span>, k = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start;i &lt;= <span class="built_in">end</span>;i ++) &#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        middle = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        merge_sort(data, temp, start, middle);</span><br><span class="line">        merge_sort(data, temp, middle+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        merge(data, temp, start, middle, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各路算法比较："><a href="#各路算法比较：" class="headerlink" title="各路算法比较："></a>各路算法比较：</h2><p>道不完的算法，最后采个图比较。<br><img src="20200225125447.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种常见排序算法比较&lt;br&gt;排序算法有很多，下面统计几种经典排序算法并做比较。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sort" scheme="https://icevil.cn/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>linux内核编译与升级</title>
    <link href="https://icevil.cn/2020/01/17/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8D%87%E7%BA%A7/"/>
    <id>https://icevil.cn/2020/01/17/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8D%87%E7%BA%A7/</id>
    <published>2020-01-17T06:50:23.000Z</published>
    <updated>2020-02-23T03:08:48.955Z</updated>
    
    <content type="html"><![CDATA[<p>一，Linux内核源码下载</p><p>在<a href="http://www.kernel.org/" target="_blank" rel="noopener">Linux官网</a>下载对应的内核代码<br><img src="20200117143333282.png" alt=""></p><a id="more"></a><p>建议下载文档版本源码，解压到当前目录。</p><p>二、编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.解压</span></span><br><span class="line">xd -d linux_xxx.tar.xd</span><br><span class="line"> </span><br><span class="line">tar -xvf linux_xxx.tar</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.拷贝配置文件到当前目录</span></span><br><span class="line">cp /boot/config-xxx ./.config</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3.编译图型菜单</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="20200117143836562.png" alt=""></p><p> save保存。退出后，即可开始编译内核。建议系统空闲空间在30g以上，因为编译后的系统有十多g。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译内核，j后面的数字是cpu总核心数。这样编译速度更快</span></span><br><span class="line">make -j8</span><br><span class="line"><span class="comment">#编译组件</span></span><br><span class="line">make modules</span><br><span class="line"><span class="comment">#安装组件</span></span><br><span class="line">make modules_install</span><br><span class="line"><span class="comment">#生成镜像3</span></span><br><span class="line">make bzImage</span><br></pre></td></tr></table></figure><p>三、安装内核步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp arch/x86/boot/bzImage /boot/vmlinux-4.xxx</span><br><span class="line">cp .config /boot/config-4.xxx</span><br><span class="line"><span class="built_in">cd</span> /lib/modules/4.xxx/</span><br><span class="line">update-initramfs -c -k 4.xxx</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure><p>四、依赖库安装</p><p>编译过程出现错误，可能需要安装一下库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符端处理库，显示菜单，需要这个依赖</span></span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"><span class="comment">#ssl库</span></span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line"><span class="comment">#bc</span></span><br><span class="line">sudo apt-get install bc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一，Linux内核源码下载&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.kernel.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux官网&lt;/a&gt;下载对应的内核代码&lt;br&gt;&lt;img src=&quot;20200117143333282.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="内核" scheme="https://icevil.cn/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>网络IO模型</title>
    <link href="https://icevil.cn/2020/01/02/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://icevil.cn/2020/01/02/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-01-02T07:38:33.000Z</published>
    <updated>2020-03-03T14:07:45.412Z</updated>
    
    <content type="html"><![CDATA[<p>网络 IO，会涉及到两个系统对象，<span style=color:#ff3366>一个是用户空间调用IO的进程或者线程，另一个是内核空间的内核系统</span>，比如发生 IO 操作 read 时，它会经历两个阶段： </p><ol><li>等待数据准备就绪 </li><li>将数据从内核拷贝到进程或者线程中。</li></ol><p>因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型 。本文主要介绍五种网络IO模型</p><a id="more"></a><h2 id="阻塞IO-blocking-io"><a href="#阻塞IO-blocking-io" class="headerlink" title="阻塞IO(blocking io)"></a>阻塞IO(blocking io)</h2><p>在 linux 中，默认情况下所有的 socket 都是 blocking，一个典型的读操作流程<br><img src="blocking.png" alt="" title="blocking io"><br>当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于 <code>network io</code> 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包）， 这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果， 用户进程才解除 block 的状态，重新运行起来。<br>所以，<span style=color:#ff3366>blocking IO 的特点就是在 IO 执行的两个阶段（等待数据和拷贝数据两个阶段）都被 block 了</span>。<br>一般程序员接触到的网络编程都是从 <code>listen()</code>、<code>send()</code>、<code>recv()</code> 等接口开始的， 这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一 个简单地“一问一答”的服务器。<br><img src="block.png" alt="" title="一问一答服务器"><br>大部分的 <code>socket</code> 接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是 IO 接口） 不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返 回。 实际上，除非特别指定，几乎所有的 IO 接口 ( 包括 <code>socket</code> 接口 ) 都是阻塞型的。这给 网络编程带来了一个很大的问题，如在调用 <code>send()</code>的同时，线程将被阻塞，在此期间，线程 将无法执行任何运算或响应任何的网络请求。 一个简单的改进方案是在服务器端使用多线程（或多进程）。<span style=color:#ff3366><strong>多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接</strong></span>。具体使用多进程还是多进程，并没有一个特定的模式。</p><blockquote><p>多线程还是多进程的选择：<br>传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问， 则进程较为安全。通常，使用 <code>pthread_create ()</code>创建新线程，<code>fork()</code>创建新进程。 </p></blockquote><p>我们让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型<br><img src="multiThreadsvr.png" alt=""></p><center>多线程服务器模型</center><blockquote><p>在上述的<code>线程/时间</code>图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。 很多初学者可能不明白为何一个 socket 可以 accept 多次。实际上 socket 的设计者 可能特意为多客户机的情况留下了伏笔，让 accept()能够返回一个新的 socket。下面是 accept 接口的原型：<code>int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</code><br> 输入参数 s 是从 <code>socket()</code>，<code>bind()</code>和 <code>listen()</code>中沿用下来的 socket 句柄。执行完 <code>bind()</code>和 <code>listen()</code>后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用 <code>accept()</code>接口正是从 <code>socket s</code> 的请求队列抽 取第一个连接信息，创建一个与 <code>s</code> 同类的新的 <code>socket</code> 返回句柄。新的 <code>socket</code> 句柄即是后 续 <code>read()</code>和 <code>recv()</code>的输入参数。如果请求队列当前没有请求，则 <code>accept()</code> 将进入阻塞 状态直到有请求进入队列。</p></blockquote><p> <strong>上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实 并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据 系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</strong> </p><p> 很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在<span style=color:#ff3366>减少创建和销毁线程的频率</span>，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接,<span style=color:#ff3366>减少创建和关闭连接的频率</span>。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如 <code>websphere</code>、<code>tomcat</code> 和各种<code>数据库</code>等。 但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用 <code>IO</code> 接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p><p>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。<strong>总之，多线程模型可以方便高效的 解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p><h2 id="非阻塞-IO（non-blocking-IO）"><a href="#非阻塞-IO（non-blocking-IO）" class="headerlink" title="非阻塞 IO（non-blocking IO）"></a>非阻塞 IO（non-blocking IO）</h2><p>Linux 下，可以通过设置 <code>socket</code> 使其变为 <code>non-blocking</code>。当对一个 <code>non-blocking socket</code> 执行读 操作时，流程是这个样子:<br><img src="non-blockingio.png" alt=""></p><center>非阻塞 IO</center><blockquote><p>从图中可以看出，当用户进程发出 read 操作时，如果 <code>kernel</code> 中的数据还没有准备好，那 么它并不会 <code>block</code> 用户进程，而是立刻返回一个 <code>error</code>。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 <code>error</code> 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 <code>kernel</code> 中的数据 准备好了，并且又再次收到了用户进程的 <code>system call</code>，那么它马上就将数据拷贝到了用 户内存，然后返回，所以，在<code>非阻塞式 IO</code> 中，用户进程其实是需要不断的主动询问 <code>kernel</code> 数据准备好了没有。 在非阻塞状态下，<code>recv()</code> 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中， </p></blockquote><ul><li>recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数； </li><li>recv() 返回 0，表示连接已经正常断开； </li><li>recv() 返回 -1，且 <code>errno</code> 等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作还没执行完成； </li><li>recv() 返回 -1，且 <code>errno</code> 不等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作遇到系统错误 <code>errno</code>。</li></ul><p><strong>非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。</strong>使用如下 的函数可以将某句柄 <code>fd</code> 设为非阻塞状态。<br><code>fcntl( fd, F_SETFL, O_NONBLOCK );</code><br>下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。<br><img src="non-blocking-single.png" alt=""></p><center>使用非阻塞io的单线程服务器</center><blockquote><p>可以看到服务器线程可以通过循环调用 <code>recv()</code>接口，可以在单个线程内实现对所有连 接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用 <code>recv()</code>将大幅度推高 CPU 占用率；此外，在这个方案中 <code>recv()</code>更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如 <code>select()多路复用模式</code>， 可以一次检测多个连接是否活跃。 </p></blockquote><h2 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h2><p><code>IO multiplexing</code> 这个词可能有点陌生，但是提到 <code>select/epoll</code>，大概就都能明白了。有些地方 也称这种 <code>IO</code> 方式为事件驱动 <code>IO</code>(<code>event driven IO</code>)。我们都知道，<code>select/epoll</code> 的好处就在于单个 <code>process</code> 就可以同时处理多个网络连接的 IO。它的基本原理就是 <code>select/epoll</code> 这个 <code>function</code> 会不断的轮询所负责的所有 <code>socket</code>，当某个 <code>socket</code> 有数据到达了，就通知用户进程。它的流程如图：<br><img src="io-multiplexing.png" alt=""></p><center>IO多路复用</center><blockquote><p>当用户进程调用了 <code>select</code>，那么整个进程会被 <code>block</code>，而同时，<code>kernel</code> 会“监视”所有 <code>select</code> 负责的 <code>socket</code>，当任何一个 <code>socket</code> 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从 <code>kernel</code> 拷贝到用户进程。 这个图和 <code>blocking IO</code> 的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(<code>select</code> 和 <code>read</code>)，而 <code>blocking IO</code> 只调用了一个系统调用(<code>read</code>)。 但是使用 <code>select</code> 以后最大的优势是用户可以在一个线程内同时处理多个 <code>socket</code> 的 <code>IO 请求</code>。用户可以注册多个 <code>socket</code>，然后不断地调用 <code>select</code> 读取被激活的 <code>socket</code>，即可达到 在同一个线程内同时处理多个 <code>IO</code> 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。（多说一句：所以，如果处理的连接数不是很高的话，使用 <code>select/epoll</code> 的 <code>web server</code> 不一定比使用 <code>multi-threading</code> + <code>blocking IO</code> 的 <code>web server</code> 性能更好，可能延迟还更大。<code>select/epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在多路复用模型中，对于每一个 <code>socket</code>，一般都设置成为 <code>non-blocking</code>，但是，上图所示，整个用户的 <code>process</code> 其实是一直被 <code>block</code> 的。只不过 <code>process</code> 是被 <code>select</code> 这 个函数 <code>block</code>，而不是被 <code>socket IO</code> 给 <code>block</code>。因此 <code>select()</code>与<code>非阻塞IO</code> 类似。<br>大部分 Unix/Linux 都支持 select 函数，该函数用于探测多个文件句柄的状态变化。 下面给出 select 接口的原型：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fds)     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds</span></span></span><br><span class="line"><span class="function"><span class="params">    , fd_set *exceptfds, struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><p>这里，<code>fd_set</code> 类型可以简单的理解为按 <code>bit</code> 位标记句柄的队列，例如要在某 <code>fd_set</code> 中标记一个值为 16 的句柄，则该 <code>fd_set</code> 的第 16 个 bit 位被标记为 1。具体的置位、验证 可使用 <code>FD_SET</code>、<code>FD_ISSET</code> 等宏实现。在 <code>select()</code>函数中，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 同时作为输入参数和输出参数。如果输入的 <code>readfds</code> 标记了 16 号句柄，则 <code>select()</code>将检测 16 号句柄是否可读。在 <code>select()</code>返回后，可以通过检查 <code>readfds</code> 有否标 记 16 号句柄，来判断该“可读”事件是否发生。另外，用户可以设置 <code>timeout</code> 时间。 下面将重新模拟上例中从多个客户端接收数据的模型。<br><img src="select.png" alt=""></p><center>select 模型</center><blockquote><p>上述模型只是描述了使用 <code>select()</code>接口同时从多个客户端接收数据的过程；由于 <code>select()</code> 接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个客户端提供独立问答服务的服务器系统。 </p></blockquote><p><img src="select-event.png" alt=""></p><center>基于事件驱动的select模型</center><blockquote><p>这里需要指出的是，客户端的一个 <code>connect()</code> 操作，将在服务器端激发一个“可读事件”，所以 <code>select()</code> 也能探测来自客户端的 <code>connect()</code> 行为。 </p></blockquote><p>上述模型中，最关键的地方是如何动态维护 <code>select()</code>的三个参数 <code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>。作为输入参数，<code>readfds</code> 应该标记所有的需要探测的“可读事件”的句柄， 其中永远包括那个探测 <code>connect()</code> 的那个“母”句柄；同时，<code>writefds</code> 和 <code>exceptfds</code> 应 该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 <code>FD_SET()</code> 标记 )。 作为输出参数，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 中的保存了 <code>select()</code> 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用 <code>FD_ISSET()</code>检查 )，以确定到底哪些句柄发生了事件。</p><p>上述模型主要模拟的是“一问一答”的服务流程，所以如果 <code>select()</code>发现某句柄捕捉到了“可读事件”，服务器程序应及时做<code>recv()</code>操作，并根据接收到的数据准备好待发送数据， 并将对应的句柄值加入 <code>writefds</code>，准备下一次的“可写事件”的 <code>select()</code>探测。同样，如果 <code>select()</code>发现某句柄捕捉到“可写事件”，则程序应及时做 <code>send()</code>操作，并准备好下一 次的“可读事件”探测准备。<br><strong>这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发 某个特定的响应。我们可以将这种模型归类为“事件驱动模型”。</strong><br>相比其他模型，使用 <code>select()</code> 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。 </p><p>但这个模型依旧有着很多问题。</p><ol><li>首先 <code>select()</code>接口并不是实现“事件驱动”的最好选择。 因为当需要探测的句柄值较大时，<code>select()</code>接口本身需要消耗大量时间去轮询各个句柄。 很多操作系统提供了更为高效的接口，如<code>linux</code>提供了<code>epoll</code>，<code>BSD</code>提供了<code>kqueue</code>，<code>Solaris</code> 提供了<code>/dev/poll</code>，…。如果需要实现更高效的服务器程序，类似 epoll 这样的接口更被推 荐。遗憾的是不同的操作系统特供的 epoll 接口有很大差异，所以使用类似于 epoll 的接 口实现具有较好跨平台能力的服务器会比较困难。 </li><li>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整 个模型是灾难性的。如，庞大的执行体 1 将直接导致响应事件 2 的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。 </li></ol><p>幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有 <code>libevent</code> 库，还有作为 <code>libevent</code> 替代者的 <code>libev</code> 库。这些库会根据操作系统的特点选择 最合适的事件探测接口，并且加入了信号(<code>signal</code>) 等技术以支持异步响应，这使得这些库成为构建事件驱动模型的不二选择。下章将介绍如何使用 <code>libev</code> 库替换 <code>select</code> 或 <code>epoll</code> 接口，实现高效稳定的服务器模型。<br>实际上，<code>Linux</code> 内核从 2.6 开始，也引入了支持异步响应的 IO 操作，如 <code>aio_read</code>, <code>aio_write</code>，这就是异步IO。</p><h2 id="异步IO（Asynchronous-I-O）"><a href="#异步IO（Asynchronous-I-O）" class="headerlink" title="异步IO（Asynchronous I/O）"></a>异步IO（Asynchronous I/O）</h2><p>Linux 下的 asynchronous IO 用在磁盘 IO 读写操作，不用于网络 IO，从内核 2.6 版本才开始引 入。先看一下它的流程<br><img src="asynchrIO.png" alt=""></p><center>异步IO</center><blockquote><p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 <code>kernel</code> 的角度，当它受到一个 <code>asynchronous read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何 <code>block</code>。然后，<code>kernel</code> 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 <code>signal</code>，告诉它 <code>read</code> 操作完成了。 </p></blockquote><p><strong>异步 IO 是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。</strong></p><p>到目前为止，已经将四个 IO 模型都介绍完了。<font size=4>现在回过头来回答最初的两个问题： <code>blocking</code> 和 <code>non-blocking</code> 的区别在哪?<code>synchronous IO</code> 和 <code>asynchronous IO</code> 的区别在哪?</font></p><blockquote><p>先回答最简单的这个：<code>blocking</code> 与 <code>non-blocking</code>。前面的介绍中其实已经很明确的 说明了这两者的区别。调用 <code>blocking IO</code> 会一直 <code>block</code> 住对应的进程直到操作完成，而 <code>non-blocking IO</code> 在 <code>kernel</code> 还在准备数据的情况下会立刻返回。<br>两者的区别就在于 <code>synchronous IO</code> 做<font color=red>“IO operation”</font>的时候会将 <code>process</code> 阻塞。 按照这个定义，之前所述的 <code>blocking IO</code>，<code>non-blocking IO</code>，<code>IO multiplexing</code> 都属于 <code>synchronous IO</code>。有人可能会说，<code>non-blocking IO</code>并没有被 <code>block</code> 啊。这里有个非常 “狡猾”的地方，<font color=red>定义中所指的”IO operation”是指真实的 IO 操作，就是例子中的 read 这个系统调用。</font><code>non-blocking IO</code> 在执行 <code>read</code> 这个系统调用的时候，如果 <code>kernel</code> 的数据没有准备好，这时候不会 <code>block</code> 进程。但是当 <code>kernel</code> 中数据准备好的时候，<code>read</code> 会将数据 从 <code>kernel</code> 拷贝到用户内存中，这个时候进程是被 <code>block</code> 了，在这段时间内进程是被 <code>block</code> 的。而 <code>asynchronous IO</code> 则不一样，当进程发起 IO 操作之后，就直接返回再也不理睬了， 直到<code>kernel</code>发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被<code>block</code>。</p></blockquote><h2 id="信号驱动IO（signal-driven-I-O，-SIGIO）"><a href="#信号驱动IO（signal-driven-I-O，-SIGIO）" class="headerlink" title="信号驱动IO（signal driven I/O， SIGIO）"></a>信号驱动IO（signal driven I/O， SIGIO）</h2><p>首先我们允许套接口进行信号驱动 I/O,并安装一个信号处理函数，进程继续运行并不阻 塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函 数处理数据。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后既可 以在信号处理函数中调用 read 读取数据报，并通知主循环数据已准备好待处理，也可以立 即通知主循环，让它来读取数据报。无论如何处理 SIGIO 信号，这种模型的优势在于等待数 据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了 select 的阻塞与轮询，当 有活跃套接字时，由注册的 handler 处理。<br><img src="singalIO.png" alt=""></p><center>信号驱动IO</center><blockquote><p>经过上面的介绍，会发现 <code>non-blocking IO</code> 和 <code>asynchronous IO</code> 的区别还是很明显的。在 <code>non-blocking IO</code> 中，虽然进程大部分时间都不会被 <code>block</code>，但是它仍然要求进程去主动的 <code>check，</code> 并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而 <code>asynchronous IO</code> 则完全不同。它就像是用户进程将整个 <code>IO</code> 操作交给了他人（<code>kernel</code>）完 成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 IO 操作的状态，也不需要主动的去拷贝数据.</p></blockquote><h2 id="服务器模型-Reactor-与-Proactor"><a href="#服务器模型-Reactor-与-Proactor" class="headerlink" title="服务器模型 Reactor 与 Proactor"></a>服务器模型 Reactor 与 Proactor</h2><p>对高并发编程，网络连接上的消息处理，可以分为两个阶段：等待消息准备、消息处理。当使用默认的阻塞套接字时（例如上面提到的 1 个线程捆绑处理 1 个连接），往往是把 这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了高并发下线程会频繁的睡眠、唤醒，从而影响了 CPU 的使用效率。<br>高并发编程方法当然就是把两个阶段分开处理。即，等待消息准备好的代码段，与处理消息的代码段是分离的。当然，这也要求套接字必须是非阻塞的，否则，处理消息的代码段 很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。那么问题来了，<strong>等待消息准备好这个阶段怎么实现？</strong>它毕竟还是等待，这意味着线程还是要睡眠的！解决办法就是，线程主动查询，或者让 1 个线程为所有连接而等待！这就是 IO 多路复用了。多路复用就是处理 等待消息准备好这件事的，但它可以同时处理多个连接！它也可能“等待”，所以它也会导致 线程睡眠，然而这不要紧，因为它一对多、它可以监控所有连接。这样，当我们的线程被唤醒执行时，就一定是有一些连接准备好被我们的代码执行了。<br>作为一个高性能服务器程序通常需要考虑处理三类事件： <strong>I/O 事件，定时事件及信号</strong>。 下面介绍两种高效的事件处理模型：Reactor 和 Proactor。</p><h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><p>首先来回想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将 结果和控制权返回给程序，程序继续处理。Reactor 释义“反应堆”，是一种事件驱动机制。 和普通函数调用的不同之处在于：应用程序不是主动的调用某个 API 完成处理，而是恰恰相反，Reactor 逆置了事件处理流程，<font color=red>应用程序需要提供相应的接口并注册到 Reactor 上， 如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</font><br><img src="reactor-class.png" alt=""></p><center>reactor模式uml图</center>Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，中心思想是将所有要处理的 I/O 事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上； 一旦有 I/O 事件到来或是准备就绪(文件描述符或 socket 可读、写)，多路复用器返回并将事 先注册的相应 I/O 事件分发到对应的处理器中。 <p><strong>Reactor 模型有三个重要的组件：</strong> </p><ul><li>多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。 </li><li>事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。 </li><li>事件处理器：负责处理特定事件的处理函数。 </li></ul><p><img src="reactor.png" alt=""></p><center>reactor模式时序图</center><p>具体流程如下： </p><ol><li>注册读就绪事件和相应的事件处理器；  </li><li>事件分离器等待事件； </li><li>事件到来，激活分离器，分离器调用事件对应的处理器； </li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><p>Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点： </p><ul><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的； </li><li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进 程的切换开销；</li><li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源； </li><li>可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；</li></ul><p>Reactor 模型开发效率上比起直接使用 IO 复用要高，它通常是单线程的，设计目标是希望单线程使用一颗 CPU 的全部资源，但也有附带优点，即每个事件处理中很多时候可以不考虑共享资源的互斥访问。可是缺点也是明显的，现在的硬件发展，已经不再遵循摩尔定律，CPU 的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，当程序需要使用多核资源时，Reactor 模型就会悲剧, 为什么呢？<br>如果程序业务很简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开启多个反应堆，每个反应堆对应一颗 CPU 核心，这些反应堆上跑的请求互不相关，这是完全可以利用多核的。例如: Nginx 这样的 http 静态服务器。 </p><h3 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h3><p><img src="proactor_uml.jpg" alt=""></p><center>proactor模式uml图</center><p><img src="proactor_flow.png" alt=""></p><center>proactor模式时序图</center><p><code>Proactor</code>译作“前摄器模式”是设计模式中重要的一种，具体流程如下： </p><ol><li>处理器发起异步操作，并关注 I/O 完成事件 </li><li>事件分离器等待操作完成事件 </li><li>分离器等待过程中，内核并行执行实际的 I/O 操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成 </li><li>I/O 完成后，通过事件分离器呼唤处理器 </li><li>事件处理器处理用户自定义缓冲区中的数据 </li></ol><p>从上面的处理流程，我们可以发现 <code>proactor</code> 模型最大的特点就是 <code>Proactor</code> 最大的特点是使用异步 I/O。所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操 作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。       </p><blockquote><p><code>Proactor</code> 增加了编程的复杂度，但给工作线程带来了更高的效率。<code>Proactor</code> 可以在 系统态将读写优化，利用 I/O 并行能力，提供一个高性能单线程模型。在 <code>windows</code> 上， 由于没有 <code>epoll</code> 这样的机制，因此提供了 <code>IOCP</code> 来支持高并发， 由于操作系统做了较好的优化，<code>windows</code> 较常采用 <code>Proactor</code> 的模型利用完成端口来实现服务器。在 <code>linux</code> 上，在 2.6 内核出现了 <code>aio</code> 接口，但 <code>aio</code> 实际效果并不理想，它的出现，主要是解决 <code>poll</code> 性能不佳的问题，但实际上经过测试，<code>epoll</code> 的性能高于 <code>poll+aio</code>，并且 <code>aio</code> 不能处理 <code>accept</code>， 因此 linux 主要还是以 <code>Reactor</code> 模型为主。</p></blockquote><p>在不使用操作系统提供的异步 I/O 接口的情况下，还可以使用 <code>Reactor</code> 来模拟 <code>Proactor</code>， 差别是：使用异步接口可以利用系统提供的读写并行能力，而在模拟的情况下，这需要在用户态实现。具体的做法如下： </p><ol><li>注册读事件（同时再提供一段缓冲区） </li><li>事件分离器等待可读事件 </li><li>事件到来，激活分离器，分离器（立即读数据，写缓冲区）调用事件处理器 </li><li>事件处理器处理数据，删除事件(需要再用异步接口注册)            </li></ol><p>我们知道，<code>Boost.asio</code> 库采用的即为 <code>Proactor</code> 模型。不过 <code>Boost.asio</code> 库在 <code>Linux</code> 平台采用 <code>epoll</code> 实现的 <code>Reactor</code> 来模拟 <code>Proactor</code>，并且另外开了一个线程来完成读写调度。 </p><h3 id="同步-I-O-模拟-Proactor-模型"><a href="#同步-I-O-模拟-Proactor-模型" class="headerlink" title="同步 I/O 模拟 Proactor 模型"></a>同步 I/O 模拟 Proactor 模型</h3><p><img src="11.png" alt=""></p><center>proactor模式流程图</center><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 </li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。 </li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据， 直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后 往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。 </li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户 请求的结果。 </li></ol><p>两个模式的相同点，<font color=red>都是对某个 IO 事件的事件通知(即告诉某个模块，这个 IO 操作可以进行或已经完成)。在结构上两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、 查询设备是否可操作(同步)，然后当条件满足时，就回调注册处理函数。</font> </p><p>不同点在于，<font color=red>异步情况下(Proactor)，当回调注册的处理函数时，表示 IO 操作已经完成；同步情况下(Reactor)，回调注册的处理函数时，表示 IO 设备可以进行某个操作(can read or can write)，注册的处理函数这个时候开始提交操作。 </font></p><p><strong>本文参考链接</strong></p><p>本文reactor/proactor盗图自<a href="https://tech.youzan.com/yi-bu-wang-luo-mo-xing/" target="_blank" rel="noopener">xieshuang-异步网络模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络 IO，会涉及到两个系统对象，&lt;span style=color:#ff3366&gt;一个是用户空间调用IO的进程或者线程，另一个是内核空间的内核系统&lt;/span&gt;，比如发生 IO 操作 read 时，它会经历两个阶段： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待数据准备就绪 &lt;/li&gt;
&lt;li&gt;将数据从内核拷贝到进程或者线程中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型 。本文主要介绍五种网络IO模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="https://icevil.cn/tags/c-c/"/>
    
      <category term="socket" scheme="https://icevil.cn/tags/socket/"/>
    
      <category term="io" scheme="https://icevil.cn/tags/io/"/>
    
      <category term="select" scheme="https://icevil.cn/tags/select/"/>
    
      <category term="poll" scheme="https://icevil.cn/tags/poll/"/>
    
      <category term="epoll" scheme="https://icevil.cn/tags/epoll/"/>
    
      <category term="iocp" scheme="https://icevil.cn/tags/iocp/"/>
    
      <category term="network" scheme="https://icevil.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>表达式计算</title>
    <link href="https://icevil.cn/2019/12/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>https://icevil.cn/2019/12/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</id>
    <published>2019-12-24T01:05:23.000Z</published>
    <updated>2020-02-24T02:47:26.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题：计算数学表达式-color-green-1-2-times-3-5-2"><a href="#题：计算数学表达式-color-green-1-2-times-3-5-2" class="headerlink" title="题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$"></a>题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$</h2><a id="more"></a><h2 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h2><h3 id="我们先了解两个概念"><a href="#我们先了解两个概念" class="headerlink" title="我们先了解两个概念"></a>我们先了解两个概念</h3><p>   任意一个数学表达式都可以用二叉树来表示，根节点表示运算符，叶子节点表示数值。</p><p><img src="image.png" alt=""></p><p>根据二叉树遍历方式，那么就有<code>前缀表达式</code>，<code>中缀表达式</code>与<code>后缀表达式</code>三种，人们常习惯用中缀表达式来表示，是因为其较好的可阅读性比较符合人类的思维习惯。但后缀表达式更有利于我们使用计算机来运算。</p><ul><li>中缀表达式：<br>   $a+b$</li><li>后缀表达式：<br>   $ab+$<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3>遍历将中缀表达式，<span style=color:red><strong>准备一个队列和一个临时空栈–&gt;遍历表达式–&gt;数值入队列–&gt;运算符入栈–&gt;匹配右边括号符`)`的时候需要将栈依次出栈到队列中直至出现左边括号符`(`-&gt;最后将栈2的所有符号都出栈到队列</strong></span>，最后就会得到一个队列即为后缀表达式，操作流程如下图，注意<code>括号是不入队列表达式的也就是说待计算的后缀表达式中是没有括号的</code>。<br><img src="image-1.png" alt=""><br><img src="image-2.png" alt=""><br><img src="image-3.png" alt=""><br><img src="image-4.png" alt=""><h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3>后缀表达式计算就比较简单了，如下图：<br><span style=color:red><strong>准备一个空栈–&gt;表达式依次入栈–&gt;数值直接入栈–&gt;遇到运算符就出栈两个数运算-&gt;将计算出新的数值入栈</strong></span>，最后就会得到一个数值即为运算结果。<br><img src="image-5.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题：计算数学表达式-color-green-1-2-times-3-5-2&quot;&gt;&lt;a href=&quot;#题：计算数学表达式-color-green-1-2-times-3-5-2&quot; class=&quot;headerlink&quot; title=&quot;题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$&quot;&gt;&lt;/a&gt;题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$&lt;/h2&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://icevil.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu及QT注意事项-笔记</title>
    <link href="https://icevil.cn/2019/11/25/Ubuntu%E5%8F%8AQT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%AC%94%E8%AE%B0/"/>
    <id>https://icevil.cn/2019/11/25/Ubuntu%E5%8F%8AQT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-25T02:44:15.000Z</published>
    <updated>2020-02-29T07:20:29.908Z</updated>
    
    <content type="html"><![CDATA[<ol><li>E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系</li></ol><p>Ubuntu关闭软件更新，会导致网络安装软件失败，要想安装新软件，需打开网络更新。</p><a id="more"></a><ol start="2"><li>安装ftp服务器vsftpd，配置完后，系统重启服务器用不了</li></ol><p>禁用ipv6即可</p><ol start="3"><li>系统断电记录关机</li></ol><p>这个问题其实没有根本解决办法，拿系统关机日志很麻烦，所以只能另辟蹊径了，加定时器每秒写时间到文件，下次软件启动时先读取文件是否是正常关机，如果不是，则补充断电关机日志，时间可以保持在文件也可以直接取文件修改时间，建议前者。</p><ol start="4"><li>qt如何失去焦点关闭窗口</li></ol><p>在主窗口中重写event事件，关机代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event-&gt;type() == QEvent::ActivationChange)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(QApplication::activeWindow() != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> QWidget::event(event);</span><br></pre></td></tr></table></figure><ol start="5"><li>qt调用shell,比如启用Ubuntu的虚拟键盘</li></ol><p>使用QProcess类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QProcess::execute(<span class="string">"onboard"</span>);<span class="comment">//静态调用</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"onboard"</span>);<span class="comment">//C方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上两种都是在当前进程调用，会导致阻塞。若想多任务</span></span><br><span class="line"></span><br><span class="line">QProcess* proc = <span class="keyword">new</span> QProcess;</span><br><span class="line"></span><br><span class="line">proc-&gt;start(<span class="string">"onboard"</span>);</span><br></pre></td></tr></table></figure><ol><li>Model/View结构中表格可编辑问题</li></ol><p>view能直接setEditTriggers来设置可编辑模式及进入编辑状态的触发条件，单击，双击等。</p><p>需要注意的是Model是也可以控制的，在重写的<code>Qt::ItemFlags flags(const QModelIndex &amp;index) const;</code>函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> QAbstractItemModel::flags(index) | Qt::ItemIsEditable;<span class="comment">//即可设置item为可编辑项</span></span><br></pre></td></tr></table></figure><p>且model设置不可编辑的话，view的editTrigger是不会触发的。</p><ol start="7"><li><p>Shell替换文件内容</p><p> 1、将当前目录下包含jack串的文件中，jack字符串替换为tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> `grep <span class="string">"jack"</span> -rl ./`</span><br></pre></td></tr></table></figure><p> 2、将某个文件中的jack字符串替换为tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> test.txt</span><br></pre></td></tr></table></figure></li><li><p>访问不了串口COM问题</p></li></ol><p>当前用户不能访问串口，其实是Linux权限问题，将当前用户添加到dialout用户组即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd --add yourname dialout</span><br></pre></td></tr></table></figure><p>添加完毕后可以用groups yourname查看是否添加成功</p><ol start="9"><li><p>关闭系统错误报告</p><p> 临时关闭：<code>sudo service apport stop</code></p><p> 永久关闭：将<code>/etc/default/apport</code>文件中的enable=1改成0即可。</p><p> 移除该功能：<code>sudo apt-get purge apport</code> （感觉没必要，常用第二种）</p></li><li><p>关闭/启用系统图形显示服务lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span>/<span class="built_in">enable</span> lightdm.service</span><br></pre></td></tr></table></figure><p>lightdm是一个全新的轻量级的显示管理器，在Ubuntu16.04上面已经使用。</p></li></ol><p>从图形界面进入到命令行界面 <code>systemctl disable lightdm.service</code></p><p>从命令行进入到图形界面 <code>systemctl enable lightdm.service</code> 然后 <code>systemctl start lightdm.service</code></p><ol start="11"><li>Qt数据模型Model与组件委托（delegate）数据同步问题</li></ol><p>在model中又setData，data两个接口需要重写的。参数role==Qt::EditorRole时，即是同步两种数据交互的时期，比如：comboBox与model：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">CMyModel::data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> QVariant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Implement me!</span></span><br><span class="line">    QString strTemp;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::DisplayRole)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步显示数据到combo的currenIndex</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nIndex = m_data[index.row()].DeviceAddr - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> nIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QVariant();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMyModel::setData</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步combo的currenIndex到显示数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[index.row()].DeviceAddr = value.toInt() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>qt工具栏按钮无法隐藏</li></ol><p><code>QAction *QToolBar::addWidget(QWidget *widget)</code>，widget使用setVisible无效，若需隐藏，You should use QAction::setVisible() to change the visibility of the widget.</p><ol start="13"><li>QListView移植到触屏下,手势上下翻滚实现<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QListView *p;</span><br><span class="line"></span><br><span class="line">QScroller-&gt;grabGesture(p, QScroller::TouchGesture);</span><br></pre></td></tr></table></figure></li><li>QListView设置行高</li></ol><p>某度搜了半天,qss啥都不好使,唯有这句有用,view,widget通杀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item-&gt;setSizeHint(QSize(item-&gt;sizeHint().<span class="built_in">width</span>(), <span class="number">32</span>));</span><br></pre></td></tr></table></figure><ol start="15"><li>qt怎样做才能既可以执行那些耗时的操作，又不会阻塞事件循环呢？</li></ol><p>一般会有三种解决方案：第一，我们将任务移到另外的线程；第二，我们手动强制运行事件循环。想要强制运行事件循环，我们需要在耗时的任务中一遍遍地调用<code>QCoreApplication::processEvents()</code>函数(该函数是告诉系统不用等本事件返回了,系统可以处理其他的事件了,所以长时间事件处理时,时而调用该函数,可以清理消息队列,来达到系统不因某个事件而阻塞卡死的目的)。<code>QCoreApplication::processEvents()</code>函数会发出事件队列中的所有事件，并且立即返回到调用者。仔细想一下，我们在这里所做的，就是模拟了一个事件循环。另外一种解决方案：使用<code>QEventLoop</code>类重新进入新的事件循环。通过调用<code>QEventLoop::exec()</code>函数，我们重新进入新的事件循环，给<code>QEventLoop::quit()</code>槽函数发送信号则退出这个事件循环。通过“其它的入口”进入事件循环要特别小心：因为它会导致递归调用！现在我们可以看看为什么会导致递归调用了。回过头来看看按钮的例子。当我们在<code>Worker::doWork()</code>槽函数中调用了<code>QCoreApplication::processEvents()</code>函数时，用户再次点击按钮，槽函数<code>Worker::doWork()</code>又一次被调用,<code>doWork-&gt;processEvents-&gt;doWork-&gt;....</code></p><p>当然，这种情况也有解决的办法：我们可以在调用<code>QCoreApplication::processEvents()</code>函数时传入<code>QEventLoop::ExcludeUserInputEvents</code>参数，意思是不要再次派发用户输入事件（这些事件仍旧会保留在事件队列中）。参考链接</p><ol start="16"><li>设置窗口border宽度及颜色<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有solid，显示不出来，QDialog为作用域，不加会影响所有子窗口</span></span><br><span class="line">setStyleSheet(<span class="string">"QDialog&#123;border: 1px solid rgb(185,185,185);&#125;"</span>);</span><br></pre></td></tr></table></figure></li><li>QMessageBox定制图标及文字样式</li></ol><p>常用的静态函数如果不满足要求，可以使用QMessageBox dlgMsg；dlgMsg.exec();来定制。</p><ol start="18"><li>修改用户名密码过短提示时</li></ol><p>使用：<code>sudo passwd 用户名</code></p><p>可以解决密码过简单设置不成功的问题。</p><ol start="19"><li>&amp; 放在命令后面表示设置此进程为后台进程</li></ol><p>默认情况下，进程是前台进程，这时此进程（命令执行相当于本质是开启一个进程）就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。</p><ol start="20"><li>自动更新检测不出，命令行检测升级系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo   update-manager   -c</span><br></pre></td></tr></table></figure></li><li>sudo不能执行gui程序，报不能使用XDG_RUNTIME_DIR错误<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmg3</span><br></pre></td></tr></table></figure>重启可解决</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ubuntu关闭软件更新，会导致网络安装软件失败，要想安装新软件，需打开网络更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="防坑笔记" scheme="https://icevil.cn/categories/%E9%98%B2%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="Ubuntu" scheme="https://icevil.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>run文件打包</title>
    <link href="https://icevil.cn/2019/11/09/run%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <id>https://icevil.cn/2019/11/09/run%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</id>
    <published>2019-11-09T04:02:46.000Z</published>
    <updated>2020-02-29T07:55:40.626Z</updated>
    
    <content type="html"><![CDATA[<p>run程序安装包实质上是一个安装脚本+程序，为了简单起见，要安装的程序就是helloworld程序，安装它的过程就是把它拷贝到<code>/bin</code>目录下.</p><a id="more"></a><p>install.sh代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">cp helloworld /bin</span><br></pre></td></tr></table></figure><p><code>tar cvf helloworld.tar.gz helloworld</code><br>现在修改一个安装脚本<code>install.sh</code>改为： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">lines=7 <span class="comment">#这个值是指这个脚本的行数加1，这个脚本共有6行 </span></span><br><span class="line">tail +<span class="variable">$lines</span> <span class="variable">$0</span> &gt;/tmp/helloworld.tar.gz <span class="comment"># $0表示脚本本身，这个命令用来把从$lines开始的内容写入一个/tmp目录的helloworld.tar.gz文件里。 </span></span><br><span class="line">tar xvf /tmp/hellowrold.tar.gz </span><br><span class="line">cp helloworld /bin  <span class="comment">#该行代码不变</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>然后使用cat命令连接安装脚本<code>install.sh</code>和<code>helloworld.tar.gz</code>。<br><code>cat install.sh helloworld.tar.gz &gt; myinstall.run</code><br>这样就得到了<code>myinstall.run</code>文件，它的结构如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">------------------</span>|<span class="string"> 第1行 </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> install.sh </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第6行 </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第7行 </span></span><br><span class="line">|<span class="string">helloworld.tar.gz</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> 结尾</span></span><br></pre></td></tr></table></figure><p>运行<code>myinstall.run</code>时，运行到第6行的<code>exit 0</code>脚本就退出了，所以不会去运行第7行以下的二进制数据(即 <code>helloworld.tar.gz</code>文件)，而我们用了<code>tail</code>巧妙地把第7行以下的数据重新生成了一个<code>helloworld.tar.gz</code>文件。再执行安装。<br><code>run</code>安装包制作较小的程序包是很好的选择，但是它也有缺点，做逻辑比较复杂的安装包，写的安装脚本将会很麻烦。因此此时还是用其他的安装包更好。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;run程序安装包实质上是一个安装脚本+程序，为了简单起见，要安装的程序就是helloworld程序，安装它的过程就是把它拷贝到&lt;code&gt;/bin&lt;/code&gt;目录下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="打包" scheme="https://icevil.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="run" scheme="https://icevil.cn/tags/run/"/>
    
  </entry>
  
  <entry>
    <title>Linux gdb 调试core dump</title>
    <link href="https://icevil.cn/2019/10/18/Linux%20gdb%20%E8%B0%83%E8%AF%95core%20dump/"/>
    <id>https://icevil.cn/2019/10/18/Linux%20gdb%20%E8%B0%83%E8%AF%95core%20dump/</id>
    <published>2019-10-18T03:27:47.000Z</published>
    <updated>2020-02-23T02:25:38.579Z</updated>
    
    <content type="html"><![CDATA[<p>gdb使用两个推荐链接：<a href="https://www.cnblogs.com/mister-lv/p/6022841.html" target="_blank" rel="noopener">GDB中文手册</a> <a href="https://www.jianshu.com/p/b7896e9afeb7" target="_blank" rel="noopener">GDB常用命令</a></p><a id="more"></a><ol start="0"><li>关于core文件的设置</li></ol><p>两种方式设置core文件名，默认系统是生成名为core的文件，但是当我们为了方便调试，需要生成带pid，time等信息的core文件时候，就需要自己设置一下了。以下命令一般都要root权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/kernel/core_uses_pid</span><br></pre></td></tr></table></figure><p>如果以上命令执行无权限，可以使用下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w kernel.core_uses_pid=1</span><br></pre></td></tr></table></figure><p>都是一个意思，设置core文件名带进程id。另外我们也可以修改core文件统一生成到一个自定义默认路径，比如：“<code>/corefile</code>”更详细可以参考下面说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行如下命令的一条即可</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/corefile/core-%e-%p-%t"</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment">#标识生成的core文件格式是 core-%e-%p-%t,保存路径为/corefile</span></span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure><blockquote><p>%p - insert pid into filename 添加pid(进程id)<br>%u - insert current uid into filename 添加当前uid(用户id)<br>%g - insert current gid into filename 添加当前gid(用户组id)<br>%s - insert signal that caused the coredump into the filename 添加导致产生core的信号<br>%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间<br>%h - insert hostname where the coredump happened into filename 添加主机名<br>%e - insert coredumping executable name into filename 添加导致产生core的命令名</p></blockquote><ol><li><p>在终端使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c</span><br></pre></td></tr></table></figure><p>查看你当前终端是否打开了core dump。系统一半默认输出0，此时我们需要设置一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>将终端设置成无限dump文件大小。也可以设置成一个值比如1000，dump文件超过1000字节就不会继续生成。所以通常使用无限制大小。</p></li><li><p>编写测试demo,text.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ -o text text.cpp</code>，生成text可执行文件，然后运行，就会得到<code>core.*</code>文件了。</p></li><li><p>gdb调试</p></li></ol><p>当我们发布程序后，拿到core文件了，怎么调试？答案就是gdb。</p><p>使用源代码，如果是用makefile的话也一样，编译的时候加 -g 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">g++ -g -o textd text.cpp</span><br><span class="line"><span class="comment">#调试</span></span><br><span class="line">gdb textd core.*</span><br></pre></td></tr></table></figure><p>此时我们就会发现输出信息很直观了，如下图。<br><img src="20191018112559275.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gdb使用两个推荐链接：&lt;a href=&quot;https://www.cnblogs.com/mister-lv/p/6022841.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB中文手册&lt;/a&gt; &lt;a href=&quot;https://www.jianshu.com/p/b7896e9afeb7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB常用命令&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="gdb" scheme="https://icevil.cn/tags/gdb/"/>
    
      <category term="core dump" scheme="https://icevil.cn/tags/core-dump/"/>
    
  </entry>
  
  <entry>
    <title>用Qt5编写压缩解压缩文件(夹)</title>
    <link href="https://icevil.cn/2019/08/02/%E7%94%A8Qt5%E7%BC%96%E5%86%99%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6(%E5%A4%B9)/"/>
    <id>https://icevil.cn/2019/08/02/%E7%94%A8Qt5%E7%BC%96%E5%86%99%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6(%E5%A4%B9)/</id>
    <published>2019-08-02T07:21:15.000Z</published>
    <updated>2020-02-23T03:12:00.922Z</updated>
    
    <content type="html"><![CDATA[<p>全网居然没找到一个能直接压缩整个文件夹的c/c++库,就算找到了zlib，karchive，archive等开源库，基本也是在Linux下支持的较好，在win下只有zlib还算是编译过了。而且不能全文件夹压缩的，都是buffer或者单文件压缩，这就好奇了，标准zip怎么搞？原来zip是有一个特定archive的，<a href="http://www.fileformat.info/format/zip/corion.htm" target="_blank" rel="noopener">链接在此</a>。</p><a id="more"></a><p>由此思路，如果自己要压缩文件夹，那就自己遍历，然后自己定义压缩文件的格式就好了，当然不是标准化的压缩格式而已了。但是够自己使用就行。这么理解，实现文件夹的压缩就显得不那么重要了，重要的是压缩算法，而提供压缩算法的库就多了去了，也容易找到。下面就用qt5简单实现一个文件的压缩与解压缩。注意，没有全文件一次读取再压缩，是考虑到文件太大，比如4g，会直接冲爆你的内存。下面测试代码已使用MD5验证通过。show code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUFFER 10240</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;output)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            QByteArray <span class="built_in">read</span> = file.<span class="built_in">read</span>(READ_BUFFER);</span><br><span class="line">            QByteArray comp = qCompress(<span class="built_in">read</span>);</span><br><span class="line">            <span class="keyword">int</span> nsize = comp.<span class="built_in">size</span>();</span><br><span class="line">            ds&lt;&lt;nsize&lt;&lt;comp;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"Input:"</span>&lt;&lt;nsize;</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uncompress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        QByteArray <span class="built_in">read</span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">            ds&gt;&gt;<span class="built_in">size</span>&gt;&gt;<span class="built_in">read</span>;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"out:"</span>&lt;&lt;<span class="built_in">size</span>;</span><br><span class="line">            QByteArray comp = qUncompress(<span class="built_in">read</span>);</span><br><span class="line">            output.<span class="built_in">write</span>(comp);</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"compress...."</span>;</span><br><span class="line">    compress(<span class="string">"data.db"</span>, <span class="string">"data.zip"</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"uncompress...."</span>;</span><br><span class="line">    uncompress(<span class="string">"data.zip"</span>, <span class="string">"dt.db"</span>);</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全网居然没找到一个能直接压缩整个文件夹的c/c++库,就算找到了zlib，karchive，archive等开源库，基本也是在Linux下支持的较好，在win下只有zlib还算是编译过了。而且不能全文件夹压缩的，都是buffer或者单文件压缩，这就好奇了，标准zip怎么搞？原来zip是有一个特定archive的，&lt;a href=&quot;http://www.fileformat.info/format/zip/corion.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接在此&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://icevil.cn/categories/Qt/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="压缩" scheme="https://icevil.cn/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="解压缩" scheme="https://icevil.cn/tags/%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://icevil.cn/2019/07/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://icevil.cn/2019/07/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2019-07-22T11:13:21.000Z</published>
    <updated>2020-02-29T08:05:21.505Z</updated>
    
    <content type="html"><![CDATA[<p>关于线程同步主要有四种方式：临界区/互斥量/信号量/事件</p><a id="more"></a><h2 id="临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"><a href="#临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）" class="headerlink" title="临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"></a>临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）</h2><p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p><p>可以将临界区比作旅馆的房卡，调用<code>EnterCriticalSection()</code>即申请房卡，得到房卡后自己当然是可以多次进出房间的，在你调用<code>LeaveCriticalSection()</code>交出房卡之前，别人自然是无法进入该房间,在经典线程同步问题上，主线程正是由于拥有“线程所有权”即房卡，所以它可以重复进入关键代码区域从而导致子线程在接收参数之前主线程就已经修改了这个参数。所以关键段可以用于线程间的互斥，但不可以用于同步。</p><h2 id="互斥量（Mutex）（可以跨进程，实现互斥）"><a href="#互斥量（Mutex）（可以跨进程，实现互斥）" class="headerlink" title="互斥量（Mutex）（可以跨进程，实现互斥）"></a>互斥量（Mutex）（可以跨进程，实现互斥）</h2><p>互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。<br>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</p><h2 id="信号量（Semaphores）（主要是实现同步，可以跨进程）"><a href="#信号量（Semaphores）（主要是实现同步，可以跨进程）" class="headerlink" title="信号量（Semaphores）（主要是实现同步，可以跨进程）"></a>信号量（Semaphores）（主要是实现同步，可以跨进程）</h2><p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出</p><h2 id="事件（Event）（实现同步，可以跨进程）"><a href="#事件（Event）（实现同步，可以跨进程）" class="headerlink" title="事件（Event）（实现同步，可以跨进程）"></a>事件（Event）（实现同步，可以跨进程）</h2><p>事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。</p><p>互斥量也是一个特殊的信号量（无计数能力或者说计数就是1的信号量）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于线程同步主要有四种方式：临界区/互斥量/信号量/事件&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="临界区" scheme="https://icevil.cn/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="互斥量" scheme="https://icevil.cn/tags/%E4%BA%92%E6%96%A5%E9%87%8F/"/>
    
      <category term="信号量" scheme="https://icevil.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="事件" scheme="https://icevil.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="线程同步" scheme="https://icevil.cn/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用windeployqt打包</title>
    <link href="https://icevil.cn/2019/06/11/%E4%BD%BF%E7%94%A8windeployqt%E6%89%93%E5%8C%85/"/>
    <id>https://icevil.cn/2019/06/11/%E4%BD%BF%E7%94%A8windeployqt%E6%89%93%E5%8C%85/</id>
    <published>2019-06-11T05:36:48.000Z</published>
    <updated>2020-02-22T14:44:23.753Z</updated>
    
    <content type="html"><![CDATA[<p>使用QT5自带的windeployqt打包程序</p><a id="more"></a><ol><li>从开始菜单找到qt程序目录如下图，我安装了vs版和mingw版本，根据需要选择即可。<br><img src="20190611132725707.png" alt=""></li></ol><ol start="2"><li>执行两条关键命令</li></ol><p>cd 到exe所在的目录</p><p>执行<code>windeployqt *.exe</code></p><p>会在当前目录生成exe依赖的所有文件（含库，语言包，插件等信息，部分非必须文件也会被拷贝过来）。<br>此时程序即可打包了。</p><p><img src="20190611133144365.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用QT5自带的windeployqt打包程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://icevil.cn/categories/Qt/"/>
    
    
      <category term="打包" scheme="https://icevil.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="windeployqt" scheme="https://icevil.cn/tags/windeployqt/"/>
    
  </entry>
  
  <entry>
    <title>deb文件打包</title>
    <link href="https://icevil.cn/2019/04/10/deb%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <id>https://icevil.cn/2019/04/10/deb%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</id>
    <published>2019-04-10T12:44:17.000Z</published>
    <updated>2020-02-29T07:51:54.135Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/drfxiaoliuzi/p/4873670.html" target="_blank" rel="noopener">参考链接</a></p><p><strong>deb包结构的目录以及文件：</strong></p><a id="more"></a><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mydeb</span><br><span class="line"></span><br><span class="line">|<span class="params">----DEBIAN</span></span><br><span class="line"></span><br><span class="line">       |<span class="params">-------control</span></span><br><span class="line">       |<span class="params">-------postinst</span></span><br><span class="line"></span><br><span class="line">       |<span class="params">-------postrm</span></span><br><span class="line"></span><br><span class="line">|<span class="params">----App</span>'s path1</span><br><span class="line"></span><br><span class="line">       |<span class="params">----App</span>'s file1</span><br><span class="line"></span><br><span class="line">|<span class="params">----App</span>'s path2</span><br><span class="line"></span><br><span class="line">       |<span class="params">----App</span>'s file2</span><br><span class="line"></span><br><span class="line"><span class="string">.............</span></span><br></pre></td></tr></table></figure><p>在任意目录下创建如上所示的目录以及文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir   -p /root/mydeb                <span class="comment"># 在该目录下存放生成deb包的文件以及目录</span></span><br><span class="line">mkdir -p /root/mydeb/DEBIAN           <span class="comment">#目录名必须大写</span></span><br><span class="line">mkdir -p /root/mydeb/App<span class="string">'s path       # 将文件安装到目标目录下,路径从/根目录开始</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/control    # 必须要有该文件</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/postinst  # 软件安装完后，执行该Shell脚本</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/postrm    # 软件卸载后，执行该Shell脚本</span></span><br></pre></td></tr></table></figure><p>control文件内容：<br>Package: my-deb   （软件名称，中间不能有空格）<br>Version: 1                  (软件版本)<br>Section: utils            （软件类别）<br>Priority: optional        （软件对于系统的重要程度）<br>Architecture: amd64   （软件所支持的平台架构）<br>Maintainer: xxxxxx <a href="mailto:&#120;&#x78;&#x78;&#120;&#120;&#120;&#120;&#120;&#64;&#120;&#120;&#120;&#120;&#46;&#120;&#x78;">&#120;&#x78;&#x78;&#120;&#120;&#120;&#120;&#120;&#64;&#120;&#120;&#120;&#120;&#46;&#120;&#x78;</a> （打包人和联系方式）<br>Description: my first deb （对软件所的描述）</p><p>postinst文件内容（ 软件安装完后，执行该Shell脚本，一般用来配置软件执行环境，必须以“<code>#!/bin/sh</code>”为首行，然后给该脚本赋予可执行权限：<code>chmod +x postinst</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my deb"</span> &gt; /root/mydeb.log</span><br></pre></td></tr></table></figure><p>postrm文件内容（ 软件卸载后，执行该Shell脚本，一般作为清理收尾工作，必须以“#!/bin/sh”为首行，然后给该脚本赋予可执行权限：<code>chmod +x postrm</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">rm -rf /root/mydeb.log</span><br></pre></td></tr></table></figure><p>给mydeb目录打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg -b   mydeb   mydeb-1.deb      </span><br><span class="line"><span class="comment"># 第一个参数为将要打包的目录名，</span></span><br><span class="line"><span class="comment"># 第二个参数为生成包的名称。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/drfxiaoliuzi/p/4873670.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;deb包结构的目录以及文件：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="打包" scheme="https://icevil.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="deb" scheme="https://icevil.cn/tags/deb/"/>
    
      <category term="debian" scheme="https://icevil.cn/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04随机启动应用程序</title>
    <link href="https://icevil.cn/2019/03/14/Ubuntu16.04%E9%9A%8F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://icevil.cn/2019/03/14/Ubuntu16.04%E9%9A%8F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-03-14T01:18:25.000Z</published>
    <updated>2020-02-29T07:41:49.348Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需要，开发的应用程序需要系统开机启动，本文例子都是基于Ubuntu16.</p><a id="more"></a><p>网上方法基本是两种：</p><p>1.在<code>/etc/rc.local</code>中添加命令执行</p><p>在<code>exit 0</code>前面添加命令行。</p><p>2.在<code>/etc/init.d/</code> 目录下添加执行文件或脚本或软链接</p><p>引用例子（非笔者代码），随便搜索使用步骤如下：</p><p>1、新建个脚本文件<code>new_service.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># command content</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>2、设置权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 new_service.sh</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">sudo chmod +x new_service.sh</span><br></pre></td></tr></table></figure><p>3、把脚本放置到启动目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv new_service.sh /etc/init.d/</span><br></pre></td></tr></table></figure><p>4、将脚本添加到启动脚本</p><p>执行如下指令，在这里90表明一个优先级，越高表示执行的越晚</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">sudo update-rc.d new_service.sh defaults 90</span><br></pre></td></tr></table></figure><p>5、移除Ubuntu开机脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d -f new_service.sh remove</span><br></pre></td></tr></table></figure><p>6、通过sysv-rc-conf来管理上面启动服务的启动级别等，还是开机不启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysv-rc-conf</span><br></pre></td></tr></table></figure><p>本质上方式1是方式2的一个子集（特例）。由于要进入<code>/etc</code>该目录操作，所以需要<code>root</code>权限，<code>sudo</code>也是可以的。笔者照此方式流程做了一个QT5应用程序启动脚本，发现根本不能执行啊。</p><p>然而，回忆整个过程出错的地方也就是在执行<code>update-rc.d</code> 的时候报了一个 <code>miss tag</code>警告，不是错误。该警告只是一个bash格式警告而已啊（该有的注释项没有），所以理论上是不产生影响的。</p><p>后来尝试换台机子一试，新建脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！ /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my test_service.sh beging......"</span> &gt; /home/my/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>意思就是在我的工作目录建立一个test空文件夹，让开机启动脚本往里面写这么一段文字。照如上操作一遍，意外发现，执行无误。如此说来Ubuntu开机启动机制没问题啊，那就是区别在启动程序了。继续在<code>test_service.sh</code>中添加调用应用程序的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行我的Qt应用程序启动脚本</span></span><br><span class="line"></span><br><span class="line">/home/my/bin/myApp.sh</span><br></pre></td></tr></table></figure><p>重启果然没启动起来，那问题就来了，<span style=color:red>以上方法不能启动图形应用</span>，所以其定位就是启动服务程序。那就另找启动图形应用的方法，请确信这种方法是有的。输入法不就是典型吗？</p><p>3.开机启动图形应用方法</p><p>在<code>/etc/xdg/autostart</code>目录添加一个配置文件，名称自定义，后缀必须是<code>.desktop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version&#x3D;1.0</span><br><span class="line">Name&#x3D;qtApp.sh</span><br><span class="line">Exec&#x3D;&#x2F;home&#x2F;my&#x2F;qtApp.sh</span><br><span class="line">StartupNotify&#x3D;false</span><br><span class="line">NoDisplay&#x3D;true</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Categories&#x3D;System;Utility;Archiving;</span><br></pre></td></tr></table></figure><p>保存，重启，意外惊喜就出现了。另外如果我想开机直接启动程序跳过系统ui，怎么设置呢？</p><p>4.开机直接启动应用，跳过Ubuntu系统登录及相关UI</p><p>首先在Ubuntu系统中设置成锁定用户，并自动登录。</p><p>然后在<code>/etc/profile</code>文件中添加执行qt程序的命令即可（但是该方法，会默认使分辨率变成800x600<span style=color:red>补充:后来发现可以修改,直接在软件中设置窗口大小即可,也可通过获取屏幕分辨率控制全屏显示,注意fullscreen函数不起效.</span>）。如果想退出软件自动关机可以在最后加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure><p>5.关闭Ubuntu的载入画面<br>ubuntu启动时，会有一个ubuntu字样出现在屏幕，文字下方有闪烁的点，这时按ESC可以在动画和文字界面之间切换。这一步骤不属于lightdm，而是一个叫 plymouth 的进程在起作用。实际上，plymouth的意义就在于，在开机到图形桌面 (lightdm)起来这段时间里展示出一个动画，从而提高用户体验。</p><p>屏蔽的方法：</p><p>一、编辑 /etc/default/grub 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet splash"</span> </span><br><span class="line"></span><br><span class="line">去掉”splash“，改后：</span><br><span class="line"></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet"</span></span><br></pre></td></tr></table></figure><p>二、执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudu updat-grub</span><br></pre></td></tr></table></figure><p>重启，即可看到，不再有载入画面出现了。</p><p>6.另参考网上方法</p><p>方法一:</p><p>能成功运行,缺点:<br>    1.没有了其他的tty控制,除了图形tty2,其他tty全部成了终端输出,失去了tty的意义.</p><pre><code>2.QT插件键盘输入用不了.3.没了tty,也就不能掉其他的终端,执行不了其他的基本命令.</code></pre><p>方法二:文中4所说的方法缺点就一个,系统不操作十分钟后关闭屏幕,无论什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xset s</span><br><span class="line"></span><br><span class="line">xset -dpms</span><br></pre></td></tr></table></figure><p>都是无效的,X都没启动,怎么能设置有效呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setterm --blank 0</span><br></pre></td></tr></table></figure><p>无效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">"\\033[32m\\033[8]"</span> &gt; /dev/tty1</span><br></pre></td></tr></table></figure><p>也无效</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需要，开发的应用程序需要系统开机启动，本文例子都是基于Ubuntu16.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="Ubuntu" scheme="https://icevil.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Qt5 Linux远程调试</title>
    <link href="https://icevil.cn/2019/02/27/Qt5%20Linux%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://icevil.cn/2019/02/27/Qt5%20Linux%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2019-02-27T04:58:52.000Z</published>
    <updated>2020-02-22T14:40:22.599Z</updated>
    
    <content type="html"><![CDATA[<p>当我们程序发布到新机时,难免会遇到意料之外的情况,在目标机安装编译环境虽不失为一种方式,但安装环境耗时耗力,远程调试一定会让你觉得神清气爽.</p><a id="more"></a><ol><li>目标机需要有<code>gdb gdbserver</code>.</li></ol><p>没有就安装,Ubuntu是自带有,</p><blockquote><p><code>gdbserver --version</code>可以查看版本信息</p></blockquote><ol start="2"><li><p>目标机执行debug版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver 127.0.0.1:1234 myApp</span><br></pre></td></tr></table></figure><p>ip:port说明:ip地址本机可以使用环路地址,或者本机ip,端口是自定义的,该命令是建立一个可供连接的服务器.</p></li><li><p>开发环境配置</p></li></ol><p>打开qtcreate ,选择debug菜单中的start debug选远程调试</p><blockquote><p>Override server channel:<strong>目标机ip:端口1234</strong></p></blockquote><blockquote><p>Local executable:<strong>myApp的输出路径</strong></p></blockquote><p><strong>点击ok,此时你会发现目标机的终端开始出现输出信息,软件正常启动了,在开发环境打断点试试,完美执行中断.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们程序发布到新机时,难免会遇到意料之外的情况,在目标机安装编译环境虽不失为一种方式,但安装环境耗时耗力,远程调试一定会让你觉得神清气爽.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://icevil.cn/categories/Qt/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="远程调试" scheme="https://icevil.cn/tags/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机Ubuntu局域网联网问题</title>
    <link href="https://icevil.cn/2019/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98/"/>
    <id>https://icevil.cn/2019/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98/</id>
    <published>2019-01-25T10:36:15.000Z</published>
    <updated>2020-02-22T14:36:03.382Z</updated>
    
    <content type="html"><![CDATA[<p>对于虚拟机的网络有多种模式：</p><a id="more"></a><ol><li><p><strong>桥接模式</strong>，该模式直接使虚拟机连接物理网卡，与主机保持同一局域网。但与主机ip地址不同。该模式下，<span style=color:red>局域网内的其它主机可以与该虚拟机相互ping通</span>。可以使用外网。</p></li><li><p><strong>nat模式</strong>，默认模式，该模式是与主机共用一个ip，但虚拟了一个新的子网，故<span style=color:red>局域网内的其它主机不能ping该虚拟机，但该虚拟机可以ping通其它的主机</span>，可以使用外网。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于虚拟机的网络有多种模式：&lt;/p&gt;
    
    </summary>
    
    
      <category term="防坑笔记" scheme="https://icevil.cn/categories/%E9%98%B2%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ubuntu" scheme="https://icevil.cn/tags/ubuntu/"/>
    
      <category term="vm" scheme="https://icevil.cn/tags/vm/"/>
    
      <category term="联网" scheme="https://icevil.cn/tags/%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
</feed>
