<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ives&#39;s Blog</title>
  
  <subtitle>Reading maketh a full man; conference a ready man; and writing an exact man. --Fransis Bacon</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icevil.cn/"/>
  <updated>2020-03-16T08:38:52.588Z</updated>
  <id>https://icevil.cn/</id>
  
  <author>
    <name>Ives</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通信协议梳理之TCP</title>
    <link href="https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/"/>
    <id>https://icevil.cn/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/</id>
    <published>2020-03-15T01:23:01.000Z</published>
    <updated>2020-03-16T08:38:52.588Z</updated>
    
    <content type="html"><![CDATA[<p>上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。</p><h2 id="TCP介绍"><a href="#TCP介绍" class="headerlink" title="TCP介绍"></a>TCP介绍</h2><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向<strong>连接的、可靠的、基于字节流的传输层通信协议</strong>，由IETF的RFC 793定义。</p><a id="more"></a><p>TCP是一个应用非常广泛的传输层协议，也有很多应用层协议栈是在TCP的基础上封装的。TCP是基于ICMP,IP协议之上的封装。如下图<br><img src="protocols.gif" alt="常用协议图表" title="常用协议图表"><br>TCP/IP协议簇也是非常丰富，如下图：<br><img src="tcp_ip.gif" alt="TCP/IP协议簇" title="TCP/IP协议簇"></p><h2 id="TCP协议头详解"><a href="#TCP协议头详解" class="headerlink" title="TCP协议头详解"></a>TCP协议头详解</h2><p>IP协议头（20字节）<br><img src="ip.gif" alt="ip协议头" title="ip协议头"></p><h3 id="tcp协议头（20字节）"><a href="#tcp协议头（20字节）" class="headerlink" title="tcp协议头（20字节）"></a>tcp协议头（20字节）</h3><p><img src="tcp_head.png" alt="tcp协议头" title="tcp协议头"></p><ul><li><p>2字节源端口号</p></li><li><p>2字节目的端口号</p></li><li><p>4字节序列号</p><blockquote><p>发送字节流的起始字节序列号</p></blockquote></li><li><p>4字节确认号</p><blockquote><p>接收端期望接收的下一个字节序列号</p></blockquote></li><li><p>2字节标志位 </p><blockquote><ol><li>TCP头长度：占4bit，以 <code>4Byte</code> 为单位显示TCP头长，TCP协议头固定20Byte，因此length最小为5，选项部分最长40Byte，加上固定头长总共60Byte，所以length最大值为15，4bit刚刚好；</li><li>Resv：占4bit，预留；</li><li>CWR（Congestion Window Reduce）：发送端收到ECE置位的数据后进行设置，用来通知接收端已收到ECE标志的数据，了解了拥塞情况，接收端收到CWR置位消息后，不再设置ECE标志，同时发送端发送CWR信息时，将开始减小拥塞窗口，以此减小数据发送量，避免拥塞；</li><li>ECE（ECN ECHO）：网络拥塞一般出现在路由交换时，在支持ECN功能情况下，发生拥塞时路由会设置IP中该标志位，接收端收到IP头中标志了ECN的报文后，在返回的数据ACK中设置ECE标志，表示链路发生拥塞，将拥塞消息通知发送端；</li><li>URG：紧急标志，置位后不需要按照正常报文按序处理，执行<code>优先处理</code>；</li><li>ACK：确认标志；</li><li>PSH：将缓存中的数据以及当前psh报文一起执行推送，从缓存区发出去；</li><li>RST：强行复位标志，发送数据包出现错误时，TCP会发送该状态包；</li><li>SYN：请求建立连接时置位该标志，第一个握手报文携带；</li><li>FIN：请求连接关闭时置位该标志。</li></ol></blockquote></li><li><p>2字节窗口大小</p><blockquote><p>表示接收端接收缓存剩余大小</p></blockquote></li><li><p>2字节校验和</p><blockquote><p>包括TCP协议头与数据整体的校验字段</p></blockquote></li><li><p>2字节紧急指针</p><blockquote><p>标志位URG置位后使用，为一个正的偏移量，表示当前报文中起始字节开始需要偏移的长度，这个偏移到的字节就是紧急数据的结束字节，也就是通过偏移量确定了数据中需要紧急发送的字节个数，16bit；</p></blockquote></li><li><p>Opention</p><blockquote><p>一般用于握手时接收端，发送端信息的交互，以及数据交互过程中；最大40Byte；</p></blockquote></li></ul><p>通过协议头，TCP即可通过五元组来确定哪个数据包来自哪个客户端。$五元组 = 四元组+协议类型（tcp/udp）$组成。</p><blockquote><p>四元组：源IP，源端口，目标IP，目标端口<br>五元组与socket的fd是对应的<br>send数据：是通过fd找到相应的五元组信息<br>recv数据：是通过五元组找到相应fd的信息</p></blockquote><h3 id="TCP分段"><a href="#TCP分段" class="headerlink" title="TCP分段"></a>TCP分段</h3><p><strong>最大报文段长度<code>MSS</code>（Maximum Segment Size）</strong><br>收发双方协商通信时每一个报文段所能承载的最大数据长度。</p><p>$MSS = MTU - TCP头 - IP头$</p><p><strong>最大传输单元<code>MTU</code>(Maximum Transmission Unit)</strong><br>是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看MTU值,通常Linux默认是1500字节</span></span><br><span class="line">cat /sys/class/net/eth0/mtu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.  修改MTU值，为1460字节</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1460"</span> &gt; /sys/class/net/eth0/mtu</span><br></pre></td></tr></table></figure><p>相比于UDP那样直接丢，TCP有自动分段的功能，TCP会根据实际MTU大小自动分包发送，这也是TCP<font color=red>连接可靠</font>的一个保证。</p><h3 id="TCP和MTU的关系"><a href="#TCP和MTU的关系" class="headerlink" title="TCP和MTU的关系"></a>TCP和MTU的关系</h3><ul><li>MTU（Maximum Transmission Unit）是指通信协议的链路层上面所能通过的最大数据包大小，LINUX默认1500字节。</li><li>单个UDP传输的最大内容 <font color=red>$1460 = 1500 - 20 - 20$</font> 字节，但由于不同的网络中转设备设置的MTU值并不相同。 </li><li><code>Internet</code>上的标准MTU值为 <font color=red>$576$</font> 字节，TCP的数据包长度控制在 <font color=red>$536 = 576-20-20$</font> 字节以内； </li><li>局域网环境下，UDP的数据长度控制在$1460$个字节以内。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP建立连接的过程是需要三次握手的，三次握手由客户端执行connect开始触发，服务器执行accept完成连接。代码太简单，我们分析代码层看不到的东西，三次握手是怎么进行的？先看下图<br><img src="conn.png" alt=""><br><strong>第一次握手</strong>：client将标志位<code>SYN=1</code> 生成一个随机序列号<code>seq=J</code>发送<br><strong>第二次握手</strong>：server将标志位<code>SYN=1</code>, <code>ACK=1</code>； 然后将收到的序列号加1赋值给确认号<code>ack=J+1</code>,并将自己的序列号发送给客户端<code>seq=K</code><br><strong>第三次握手</strong>：client将标志位<code>ACK=1</code>, 然后将收到的序列号加1赋值给确认号<code>ack=K+1</code>发送<br>完成三次握手后，客户端，服务器才能都进入ESTABLESHED(已确立的)状态，才能进行收发数据。</p><p><em>为何是三次握手？两次行不行？</em><br>答：两次不行，如果两次握手就建立连接，那客户端发完请求就关闭了，服务器还认为客户端已建立连接，显然这是一个无效的连接，又或者客户端连续发起了两次连接，显然只有一个有效请求，但服务器却分辨不出以为是两个有效连接。所以，TCP作为一个可靠连接协议必然是三次握手。<font color=red>另外在我个人看来，要确定连接只需确定彼此双方都能收发数据就行，而三次握手正好可以表明双方都能收发成功。两次握手不能证明客户端能收到数据</font></p><blockquote><p>好比如下情景：<br>A:在吗？<br>B:在，你在吗？<br>A:我在(试想一下如果A不回复这句，B如何确定A还在？)</p></blockquote><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>前面我们已经知道了3次握手可以确定TCP的连接，那TCP是如何断开连接的呢？没错，四次挥手。先看下面两张图<br>客户端主动发起断开连接（服务器主动发起也是一样）<br><img src="disconn.png" alt=""><br>第一次挥手：Client发送一个FIN，<font color=red>用来关闭Client到Server的数据传送</font>，Client进入<code>FIN_WAIT_1</code>状态。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<code>CLOSE_WAIT</code>状态。<br>第三次挥手：Server发送一个FIN，<font color=red>用来关闭Server到Client的数据传送</font>，Server进入<code>LAST_ACK</code>状态。<br>第四次挥手：Client收到FIN后，Client进入<code>TIME_WAIT</code>状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入<code>CLOSED</code>状态，完成四次挥手。<br>双发同时发起断开连接<br><img src="disconn2.png" alt=""><br>后面这个图不再写每次挥手的作用，因为基本和上一个图一样。可以总结的是：4次挥手之后，无论客户端或是服务器都将进入<code>TIME_WAIT状态</code>或者<code>CLOSED状态</code>z,这两个状态都有关闭的意思，那区别是什么呢？为什么需要两个关闭状态呢一个不就行了吗或者说干嘛不直接进入<code>CLOSED状态</code>？带着这两个疑问继续往下看。</p><h2 id="TCP状态装换图"><a href="#TCP状态装换图" class="headerlink" title="TCP状态装换图"></a>TCP状态装换图</h2><p><img src="tcp_status_trans.jpg" alt="TCP状态装换图" title="TCP状态装换图"></p><ol><li>CLOSED：这是最开始的状态</li><li>LISTEN：服务器调用<code>listen()</code>之后的状态</li><li>SYN_SENT：客户端发起连接请求之后的状态</li><li>SYN_RECV：服务器收到客户端连接请求之后的状态</li><li>ESTABLISHED：这是双方建立连接之后的状态，该状态即可正常收发数据了。</li><li>FIN_WAIT_1：调用<code>close()</code>(发送完FIN)后的状态</li><li>CLOS_WAIT：等待关闭状态，在ESTABLISHED状态收到FIN后进入的状态，回发FIN，发完进入LAST_ASK</li><li>FIN_WAIT_2：在FIN_WAIT_1的状态先收到ack，然后收到FIN后的状态</li><li>LAST_ASK: 最后确认状态，在CLOS_WAIT状态回发FIN之后进入的状态</li><li>TIME_WAIT：由FIN_WAIT_1/FIN_WAIT_2发送ACK后的状态,或者在CLOSING接收到ACK后的状态。总之这是一个挥手完成后的状态</li><li>CLOSING：在FIN_WAIT_1状态的时候先收到FIN，然后收到ack的状态</li></ol><p>握手触发前5个状态，挥手触发后6个状态。有上图可知，TCP真正的关闭状态才是CLOSED,而TIME_WAIT并非关闭状态，TIME_WAIT需要经过2MSL(Maximum Segment Lifetime 报文最大生存时间)超时才会变成CLOSED状态。<br><font color=red>RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟（这个和操作系统有关，Solaris2.2MSL是2分钟，测试方法就是用netstat命令查看状态变化需要时间/2即可。）<br>2MSL TIME_WAIT状态的存在有两个理由：</font></p><ol><li>让4次挥手关闭流程更加可靠；<blockquote><p>4次挥手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</p></blockquote></li><li>防止<code>lost duplicate</code>对后续新建正常链接的传输造成破坏。<blockquote><p><code>lost duplicate</code>在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL（time to live的缩写，存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机），限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p></blockquote></li></ol><h2 id="TCP可靠性的保证"><a href="#TCP可靠性的保证" class="headerlink" title="TCP可靠性的保证"></a>TCP可靠性的保证</h2><p>TCP采用一种名为“带重传功能的肯定确认（positive acknowledge with retransmission）”的技术作为提供可靠数据传输服务的基础。这项技术要求接收方收到数据之后回发确认信息ACK。发送方对发出的每个分组都暂存着，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP译名传输控制协议，而tcpsocket叫流式套接字。流式也就是告诉我们tcp的数据包是有先后顺序的，先发先到而这又是由滑动窗口来处理的，滑动窗口又是如何保证顺序的呢？</p><p>滑动窗口由两个索引，一前，一后，中间部分即为滑动窗口大小。<br>对于发送端：前索引表示的是已发送的位置，后索引表示不允许发送的位置<br>对于接收端：前索引表示的是已确认的位置，后索引表示不允许接收的位置</p><h3 id="窗口边沿移动"><a href="#窗口边沿移动" class="headerlink" title="窗口边沿移动"></a>窗口边沿移动</h3><ol><li>左边沿右边沿靠近，叫窗口合拢。数据被发送和确认时</li><li>右边沿向右移动，叫窗口张开。接收端读取已经确认的数据并释放了TCP的接收缓存时</li><li>右边沿左边沿靠近，叫窗口收缩。<strong>不建议</strong>，一但出现零窗口（窗口大小为0），发送方将不能发送任何数据，却占用着资源，如何解决这种占坑不工作的现象？请看后面的坚持定时器。</li></ol><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>发送窗口的大小是由拥塞计算出来的，先小后大，最后趋于稳定波动，这是动态计算的，这将影响TCP性能。对于以太网，默认大小是4kb，当文件传输的时候，调到16kb可以增加40%左右的吞吐量。</p><p><img src="tcp_wnd1.png" alt=""></p><p><img src="tcp_wnd2.png" alt=""></p><h2 id="拥塞避免算法和慢启动算法"><a href="#拥塞避免算法和慢启动算法" class="headerlink" title="拥塞避免算法和慢启动算法"></a>拥塞避免算法和慢启动算法</h2><p><strong>拥塞</strong><br>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。如何解决拥塞？</p><p><font color=red>慢启动算法是一个在连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法就是一种处理丢失分组的方法。这是两个目的不同、独立的算法，前者目的是减少输入流大小；后者目的是判断中间网络是否发生分组丢失（通过发生超时和接收到重复的确认，以此来判断分组丢失）。所以这两个算法通常用于一起实现。</font></p><p>slow start算法，通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。<br>慢启动为发送方的TCP增加了另一个窗口：<strong>拥塞窗口</strong>，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中最小值作为发送上限。<strong>拥塞窗口是发送方使用的流量控制，而通告窗口是接收方使用的流量控制</strong>。<br>    拥塞窗口以指数方式增加，在某一时刻可能发送速率达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开的过大。</p><p>这两个算法对每个连接维持两个变量，<strong>一个拥塞窗口cwnd和一个慢启动阈值ssthresh</strong>.假设窗口大小变量为wnd_size,下面详细分析一下拥塞发生过程。</p><ol><li>给定的连接，初始化<code>cwnd=1;ssthresh=65535;</code></li><li>tcp输出不能超过cwnd和接收方通告窗口的大小。</li><li>当拥塞发生时（超时或者收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd&gt;=2）.此外如果是超时引起的拥塞，则<code>cwnd=1;</code></li><li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于正在进行慢启动还是拥塞避免，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人整理的伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line">cwnd = <span class="number">1</span>;</span><br><span class="line">ssthresh = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//慢启动</span></span><br><span class="line"><span class="keyword">if</span>( cwnd &lt;= ssthresh )</span><br><span class="line">&#123;</span><br><span class="line">    慢启动；</span><br><span class="line">    <span class="keyword">if</span>( cwnd &lt; <span class="number">2</span>*ssthresh )</span><br><span class="line">        cwnd = cwnd &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cwnd++;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//执行拥塞避免，增速急剧下降</span></span><br><span class="line">    <span class="comment">//当所有窗口数据全部发出并收到ACK的时候，cwnd += 1;</span></span><br><span class="line">    <span class="comment">//否则 cwnd += 0;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get</span>(ACK))</span><br><span class="line">        cwnd += <span class="number">1</span>/cwnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以假设 cwnd == 32 拥塞发生</span></span><br><span class="line"><span class="keyword">if</span>( cwnd&gt;? 拥塞发生)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(重复确认导致)</span><br><span class="line">    &#123;</span><br><span class="line">        ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line">        cwnd = ssthresh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(超时导致)</span><br><span class="line">    &#123;</span><br><span class="line">        cwnd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>下图是慢启动和拥塞避免的一个可视化描述。我们以段为单位来显示cwnd和ssthresh，但它们实际上都是以字节为单位进行维护的。<br><img src="slowstart.jpg" alt=""><br>在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置 ssthresh为16个报文段，而cwnd为1个报文段。在时刻 0发送了一个报文段，并假定在时刻 1接收到它的 ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻 3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起， cwnd以线性方式增加，在<code>每个往返时间内</code>(窗口全部数据包被发出并收到ACK的时间)最多增加 1个报文段。<br>正如我们在这个图中看到的那样，术语“慢启动”并不完全正确。它只是采用了比引起拥塞更慢些的分组传输速率，但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。只有在达到ssthresh拥塞避免算法起作用时，这种增加的速率才会慢下来。</li></ol><h2 id="TCP的七种定时器"><a href="#TCP的七种定时器" class="headerlink" title="TCP的七种定时器"></a>TCP的七种定时器</h2><ol><li>建立连接定时器(connection-establishment timer)</li><li>重传定时器(retransmission timer)</li><li>延迟应答定时器(delayed ACK timer)</li><li>坚持定时器(persist timer)</li><li>保活定时器(keepalive timer)</li><li>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</li><li>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</li></ol><p>TCP的定时器是TCP协议很重呀的一个部分，我认为是TCP最难理解的地方了，搞清楚了定时器的运转，TCP的很多机制将会迎刃而解。<font color=red>个人理解的定时器的设计：连接时防止SYN丢失需要1个定时器，断开时FIN丢失和ACK丢失两个定时器，数据传输过程中4个定时器：包括窗口大小探测1个定时器，数据超时发送重传需要一个定时器，数据延时应答一个定时器（只有这个定时器是为了提升效率的，其他都是保证传输可靠的），防止长时间不工作的连接浪费资源需要一个保活定时器。</font></p><h3 id="建立连接定时器-connection-establishment-timer"><a href="#建立连接定时器-connection-establishment-timer" class="headerlink" title="建立连接定时器(connection-establishment timer)"></a>建立连接定时器(connection-establishment timer)</h3><p>顾名思义，这个定时器是在建立连接的时候使用的， 我们知道， TCP建立连接需要3次握手。<br>建立连接的过程中，在发送SYN时， 会启动一个定时器(默认应该是3秒)，如果SYN包丢失了， 那么3秒以后会重新发送SYN包的(当然还会启动一个新的定时器， 设置成6秒超时)，当然也不会一直没完没了的发SYN包， 在 <code>/proc/sys/net/ipv4/tcp_syn_retries</code> 可以设置到底要重新发送几次SYN包。</p><h3 id="重传定时器-retransmission-timer"><a href="#重传定时器-retransmission-timer" class="headerlink" title="重传定时器(retransmission timer)"></a>重传定时器(retransmission timer)</h3><p>重传定时器在TCP发送数据时设定，在计时器超时后没有收到返回的确认ACK，发送端就会重新发送队列中需要重传的报文段。使用RTO(Retransmission Timeout超时重传)超时重传计时器一般有如下规则：</p><ol><li>当TCP发送了位于发送队列最前端的报文段后就启动这个RTO计时器；</li><li>如果队列为空则停止计时器，否则重启计时器；</li><li>当计时器超时后，TCP会重传发送队列最前端的报文段；</li><li>当一个或者多个报文段被累计确认后，这个或者这些报文段会被清除出队列</li></ol><p>重传计时器保证了接收端能够接收到丢失的报文段，继而保证了接收端交付给接收进程的数据始终的有序完整的。因为接收端永远不会把一个失序不完整的报文段交付给接收进程。</p><h3 id="延迟应答定时器-delayed-ACK-timer"><a href="#延迟应答定时器-delayed-ACK-timer" class="headerlink" title="延迟应答定时器(delayed ACK timer)"></a>延迟应答定时器(delayed ACK timer)</h3><p>延迟应答也被成为捎带ACK， 这个定时器是在延迟应答的时候使用的。 为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。</p><p>举例说明，比如服务端收到客户端的数据后， 不是立刻回ACK给客户端， 而是等一段时间(一般最大200ms)，这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了， 这样比立即回给客户端一个ACK节省了一个数据包。</p><h3 id="坚持定时器-persist-timer"><a href="#坚持定时器-persist-timer" class="headerlink" title="坚持定时器(persist timer)"></a>坚持定时器(persist timer)</h3><p>我们已经知道TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。接收端窗口变为非0后，就会发送一个确认ACK指明需要的报文段序号以及窗口大小。</p><p>如果这个确认ACK丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 (window probe)。</p><h3 id="保活定时器-keepalive-timer"><a href="#保活定时器-keepalive-timer" class="headerlink" title="保活定时器(keepalive timer)"></a>保活定时器(keepalive timer)</h3><p>在TCP连接建立的时候指定了SO_KEEPALIVE，保活定时器才会生效。如果客户端和服务端长时间没有数据交互，那么需要保活定时器来判断是否对端还活着，但是这个其实很不实用，因为默认是2小时(<code>cat /proc/sys/net/ipv4/tcp_keepalive_time</code>)没有数据交互才探测，时间实在是太长了。如果你真的要确认对端是否活着， 那么应该自己实现心跳包，而不是依赖于这个保活定时器。</p><h3 id="FIN-WAIT-2定时器-FIN-WAIT-2-timer"><a href="#FIN-WAIT-2定时器-FIN-WAIT-2-timer" class="headerlink" title="FIN_WAIT_2定时器(FIN_WAIT_2 timer)"></a>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</h3><p>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN，主动关闭的一段总不能一直傻等着，占着资源不撒手吧？这个时候就需要FIN_WAIT_2定时器出马了， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么不好意思， 不等了， 直接释放这个链接。FIN_WAIT_2定时器的时间可以从<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>中查看和设置。</p><h3 id="TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer"><a href="#TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer" class="headerlink" title="TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)"></a>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</h3><p>TIME_WAIT是主动关闭连接的一端最后进入的状态， 而不是直接变成CLOSED的状态， 为什么呢？第一个原因是万一被动关闭的一端在超时时间内没有收到最后一个ACK， 则会重发最后的FIN，2MSL（报文段最大生存时间）等待时间保证了重发的FIN会被主动关闭的一段收到且重新发送最后一个ACK；另外一个原因是在2MSL等待时间时，任何迟到的报文段会被接收并丢弃，防止老的TCP连接的包在新的TCP连接里面出现。不可避免的，在这个2MSL等待时间内，不会建立同样(源IP, 源端口，目的IP，目的端口)的连接。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><em>1. 什么时候给对端发送确认消息？</em></p><blockquote><p>确认重传，接收端确认最小序号的包重传如：ack number=5,对方就会从5号包开始将窗口内的剩余数据全部重传一遍。这也导致了有些包被重传多次。</p></blockquote><p><em>2. 确认消息应该发送多少？</em></p><blockquote><p>只发送序号最小的包，但是回，却是回从最小序号开始到窗口尾端的包。</p></blockquote><p><em>3. 为何不只重传没收到的包，已收到的不重传？</em></p><blockquote><p>就TCP现有机制来说，实现难度太大。</p></blockquote><p><em>4. 有了TCP，为何还要UDP的可靠传输？</em></p><blockquote><p>也因为<code>延时确认</code>，tcp牺牲了一定量的实时性及带宽，对于游戏而言，UDP的可靠传输就应用更多了，UDP是实时性的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。&lt;/p&gt;
&lt;h2 id=&quot;TCP介绍&quot;&gt;&lt;a href=&quot;#TCP介绍&quot; class=&quot;headerlink&quot; title=&quot;TCP介绍&quot;&gt;&lt;/a&gt;TCP介绍&lt;/h2&gt;&lt;p&gt;传输控制协议（TCP，Transmission Control Protocol）是一种面向&lt;strong&gt;连接的、可靠的、基于字节流的传输层通信协议&lt;/strong&gt;，由IETF的RFC 793定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="通信协议" scheme="https://icevil.cn/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="tcp" scheme="https://icevil.cn/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>通信协议梳理之UDP</title>
    <link href="https://icevil.cn/2020/03/14/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BUDP/"/>
    <id>https://icevil.cn/2020/03/14/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BUDP/</id>
    <published>2020-03-14T04:51:09.000Z</published>
    <updated>2020-03-15T01:28:24.379Z</updated>
    
    <content type="html"><![CDATA[<p>计划用两篇文章梳理一下ip，upd，tcp协议，重点放在后两者，因为后两者目前在应用上非常广，可编程性也大很多，本文将重点介绍UDP协议。</p><h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><p>UDP又名用户数据报协议（User Datagram Protocol）。UDP 为应用程序提供了一种<strong>无需建立连接就可以发送封装的 IP 数据包的协议</strong>，可知UDP是基于IP协议的。</p><a id="more"></a><h3 id="UDP对应的网络层"><a href="#UDP对应的网络层" class="headerlink" title="UDP对应的网络层"></a>UDP对应的网络层</h3><p>OSI七层网络模型中：属于第4层——传输层协议</p><p>TCP/IP四层模型中：属于第3层——运输层协议</p><p>如下图：我们可以看出UDP和TCP是处于同一层的。<br><img src="osi.png" alt=""></p><h3 id="UDP-IP协议头"><a href="#UDP-IP协议头" class="headerlink" title="UDP/IP协议头"></a>UDP/IP协议头</h3><p><img src="ipHead.jpg" alt="IP协议头" title="IP协议头"></p><center>IP协议头</center><p><img src="udpHead.jpg" alt="UDP协议头" title="UDP协议头"></p><center>UDP协议头</center><p>有上图可知一个完整的UDP头是由<code>20字节IP协议头</code> + <code>8字节UDP协议头</code>组成，总长度：28个字节。 </p><blockquote><p>16位源端口号：1 ~ 65535<br>16位目标端口号：1 ~ 65535<br>16位数据报长度：65535字节=64kb<br>16位校验和：目的是防止数据报被更改。</p></blockquote><p><font color=red>所以，一个UDP包长度不能超过64kb，超过64kb数据，我们必须分包发送。否则，多余的数据会被直接丢掉，导致接收端接收数据不完整。</font>那什么时候适合用UDP呢？</p><h3 id="UDP的应用场景"><a href="#UDP的应用场景" class="headerlink" title="UDP的应用场景"></a>UDP的应用场景</h3><p>采用UDP有3个关键点：</p><ul><li>网络带宽需求较小，而实时性要求高；</li><li>大部分应用无需维持连接； </li><li>需要低功耗。</li></ul><p>应用场景：</p><ul><li>网页浏览：新浪微博就已经用了QUIC协议 </li><li>流媒体：WebRTC就是基于UDP的， </li><li>实时游戏：Unity3D采用的RakNet也是基于UDP的协议</li></ul><h3 id="尽量避免IP分片"><a href="#尽量避免IP分片" class="headerlink" title="尽量避免IP分片"></a>尽量避免IP分片</h3><p><strong>IP层是没有超时重传机制的</strong>，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于 传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大；公网传输，需要经过多个网络设备，IP分片容易造成丢包。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。那我们只能重上层减少包大小，下面将介绍UDP如何分片和重组。</p><h2 id="UDP分片与重组"><a href="#UDP分片与重组" class="headerlink" title="UDP分片与重组"></a>UDP分片与重组</h2><h3 id="UDP分片原理"><a href="#UDP分片原理" class="headerlink" title="UDP分片原理"></a>UDP分片原理</h3><ol><li>对应用层的数据进行分片，以满足MTU传输的要求 </li><li>在发送端给分片编号，在接收端重组分片，解决乱序数据包重组的问题</li></ol><h3 id="UDP和MTU的关系"><a href="#UDP和MTU的关系" class="headerlink" title="UDP和MTU的关系"></a>UDP和MTU的关系</h3><ul><li>MTU（Maximum Transmission Unit）是指通信协议的链路层上面所能通过的最大数据包大小，LINUX默认1500字节。</li><li>单个UDP传输的最大内容 <font color=red>$1472 = 1500 - 20 - 8$</font> 字节，但由于不同的网络中转设备设置的MTU值并不相同。 </li><li><code>Internet</code>上的标准MTU值为 <font color=red>$576$</font> 字节，UDP的数据长度控制在 <font color=red>$548 = 576-8-20$</font> 字节以内； </li><li>局域网环境下，UDP的数据长度控制在$1472$个字节以内。</li></ul><h3 id="UDP协议格式"><a href="#UDP协议格式" class="headerlink" title="UDP协议格式"></a>UDP协议格式</h3><table><thead><tr><th>IP头</th><th>UDP头</th><th>报文</th></tr></thead><tbody><tr><td>20字节</td><td>8字节</td><td>UDP数据</td></tr></tbody></table><h3 id="UDP分片实现"><a href="#UDP分片实现" class="headerlink" title="UDP分片实现"></a>UDP分片实现</h3><p>如何实现分片？每个分片应该有哪些信息？下面我们用一个图来搞定。<br><img src="udp_peice.png" alt=""><br><font color=red>注意：如果同时接收多个client，上图分片有什么问题？</font></p><p>两种处理方式：</p><ol><li>我们应该注意到每个<code>clientid</code>，都应该对应一个环形缓冲区才行。</li><li>如果共用一个环形缓冲区，我们应该在分片的时候加上<code>clientid</code>以做区分。</li></ol><h3 id="源代码实现"><a href="#源代码实现" class="headerlink" title="源代码实现"></a>源代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//udp-piece.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UDP_PIECE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UDP_PIECE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circular_buffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_SYNC_WORD0<span class="comment">// 同步字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_TOTAL_SIZE 2<span class="comment">// 所有分片数据的大小（不包括HEAD） //total data length of all pieces</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_TOTAL_PIECES 4 <span class="comment">// 所有分片的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_P_INDEX 6 <span class="comment">// 分片序号，从0开始</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_P_LENGTH 8 <span class="comment">// 当前分片数据的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_SIZE 12<span class="comment">// 头部大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIECE_FIX_SIZE (576 - 8 - 20 - 12)UL <span class="comment">//internat MTU - UDP_head - IP_head - 分片头</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_piece</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recv_pieces;<span class="comment">// 当前已经接收的分片数量</span></span><br><span class="line">    <span class="keyword">int</span> total_size;<span class="comment">// 总数据大小</span></span><br><span class="line">    <span class="keyword">int</span> total_pieces;<span class="comment">// 分片总数量</span></span><br><span class="line">    <span class="keyword">int</span> left;<span class="comment">// 最后一片的大小</span></span><br><span class="line">    <span class="keyword">int</span> piece_size;<span class="comment">// 分片大小</span></span><br><span class="line">    <span class="keyword">int</span> recv_len;<span class="comment">// 接收数据的长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *recv_buf;<span class="comment">// 保存接收数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span>*send_ptr;<span class="comment">// 指向发送数据的buffer</span></span><br><span class="line">    <span class="keyword">uint8_t</span> piece_buf[PIECE_FIX_SIZE+HEAD_SIZE+<span class="number">1</span>];<span class="comment">//单帧的buffer</span></span><br><span class="line">    <span class="keyword">circular_buffer_t</span> *circular_buffer;<span class="comment">// 环形缓存</span></span><br><span class="line">&#125;<span class="keyword">udp_piece_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化资源</span></span><br><span class="line"><span class="comment"> * @param buf_size 设置环形缓冲区数据的最大长度</span></span><br><span class="line"><span class="comment"> * @return 成功则返回一个句柄，失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">udp_piece_t</span> *<span class="title">udp_piece_init</span><span class="params">(<span class="keyword">int</span> buf_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放资源</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_deinit</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重置，这里不会重新分配资源，只是讲部分参数重置到初始化状态</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_reset</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据长度进行切割，返回切割后的分片数量</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf       要分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size      要分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回分片的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_cut</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据分片编号获取切片指针及分片数据大小</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param index     分片编号</span></span><br><span class="line"><span class="comment"> * @param got_piece_size 获取指定编号分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回指定分片编号的数据指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">udp_piece_get</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">int</span> index, <span class="keyword">int</span> *got_piece_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片，使用环形缓存</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge_ex</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* end of __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//udp_piece.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udp-piece.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_ERRprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_DEBUGprintf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化资源</span></span><br><span class="line"><span class="comment"> * @param buf_size 设置缓冲区数据的最大长度</span></span><br><span class="line"><span class="comment"> * @return 成功则返回一个句柄，失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">udp_piece_t</span>* <span class="title">udp_piece_init</span><span class="params">( <span class="keyword">int</span> buf_size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">udp_piece_t</span> *udp_piece = (<span class="keyword">udp_piece_t</span> *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">udp_piece_t</span>) );</span><br><span class="line">    <span class="keyword">if</span> ( !udp_piece )</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memset</span>( udp_piece, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">udp_piece_t</span>) );</span><br><span class="line"></span><br><span class="line">    udp_piece-&gt;circular_buffer = circular_buffer_init( buf_size );</span><br><span class="line">    <span class="keyword">if</span> ( !udp_piece-&gt;circular_buffer )</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(udp_piece);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放资源</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_deinit</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 释放资源 */</span></span><br><span class="line">    <span class="keyword">if</span> ( udp_piece )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">            <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">        udp_piece-&gt;recv_buf= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;recv_pieces= <span class="number">0</span>;</span><br><span class="line">        udp_piece-&gt;total_size= <span class="number">0</span>;    <span class="comment">/* 总数据大小 */</span></span><br><span class="line">        udp_piece-&gt;total_pieces = <span class="number">0</span>;    <span class="comment">/* 分片总数量 */</span></span><br><span class="line">        udp_piece-&gt;left= <span class="number">0</span>;    <span class="comment">/* 最后一片的大小 */</span></span><br><span class="line">        udp_piece-&gt;piece_size= <span class="number">0</span>;    <span class="comment">/* 分片大小 */</span></span><br><span class="line">        udp_piece-&gt;recv_len= <span class="number">0</span>;</span><br><span class="line">        circular_buffer_deinit( udp_piece-&gt;circular_buffer );</span><br><span class="line">        udp_piece-&gt;circular_buffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重置，这里不会重新分配资源，只是讲部分参数重置到初始化状态</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_reset</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 数据重置 */</span></span><br><span class="line">    <span class="keyword">if</span> ( udp_piece )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">            <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">        udp_piece-&gt;recv_buf= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;send_ptr= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;recv_pieces= <span class="number">0</span>;</span><br><span class="line">        udp_piece-&gt;total_size= <span class="number">0</span>;    <span class="comment">/* 总数据大小 */</span></span><br><span class="line">        udp_piece-&gt;total_pieces = <span class="number">0</span>;    <span class="comment">/* 分片总数量 */</span></span><br><span class="line">        udp_piece-&gt;left= <span class="number">0</span>;    <span class="comment">/* 最后一片的大小 */</span></span><br><span class="line">        udp_piece-&gt;piece_size= <span class="number">0</span>;    <span class="comment">/* 分片大小 */</span></span><br><span class="line">        udp_piece-&gt;recv_len= <span class="number">0</span>;</span><br><span class="line">        circular_buffer_reset( udp_piece-&gt;circular_buffer );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据长度进行切割，返回切割后的分片数量</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf       要分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size      要分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回分片的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_cut</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!udp_piece || <span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    udp_piece-&gt;send_ptr = buf;</span><br><span class="line">    udp_piece-&gt;total_size = <span class="built_in">size</span>;</span><br><span class="line">    udp_piece-&gt;left = <span class="built_in">size</span> % PIECE_FIX_SIZE;<span class="comment">// 最后一个分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;total_pieces = </span><br><span class="line">        (udp_piece-&gt;left &gt; <span class="number">0</span>) ? (<span class="built_in">size</span> / PIECE_FIX_SIZE + <span class="number">1</span>) :(<span class="built_in">size</span> / PIECE_FIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> udp_piece-&gt;total_pieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据分片编号获取切片指针及分片数据大小</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param index     分片编号</span></span><br><span class="line"><span class="comment"> * @param got_piece_size 获取指定编号分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回指定分片编号的数据指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">udp_piece_get</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">int</span> index, <span class="keyword">int</span> *got_piece_size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> piece_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!udp_piece || !got_piece_size &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *got_piece_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片大小</span></span><br><span class="line">    <span class="keyword">if</span>(((udp_piece-&gt;total_pieces - <span class="number">1</span>) == index)<span class="comment">// 是不是最后一个分片</span></span><br><span class="line">        &amp;&amp; (udp_piece-&gt;left &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        piece_size = udp_piece-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        piece_size = PIECE_FIX_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>( udp_piece-&gt;piece_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(udp_piece-&gt;piece_buf) );</span><br><span class="line">    <span class="comment">// 填充分片帧头</span></span><br><span class="line">    <span class="comment">// 同步字</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_SYNC_WORD] = <span class="number">0xAF</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_SYNC_WORD + <span class="number">1</span>] = <span class="number">0xAE</span>;</span><br><span class="line">    <span class="comment">// 所有分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_SIZE] = udp_piece-&gt;total_size &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_SIZE + <span class="number">1</span>] = (udp_piece-&gt;total_size &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 所有分片的数量</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_PIECES] = udp_piece-&gt;total_pieces &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_PIECES + <span class="number">1</span>] = (udp_piece-&gt;total_pieces &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 分片编号，从0开始</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_INDEX] = index &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_INDEX + <span class="number">1</span>] = (index &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_LENGTH] = piece_size &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_LENGTH + <span class="number">1</span>] = (piece_size &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把用户数据拷贝到分片数据区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;udp_piece-&gt;piece_buf[HEAD_SIZE], &amp;udp_piece-&gt;send_ptr[PIECE_FIX_SIZE * index], piece_size);</span><br><span class="line">    *got_piece_size = piece_size + HEAD_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> udp_piece-&gt;piece_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *piece_buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_total_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_total_pieces = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> get_all_pieces = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测头部是否有同步字</span></span><br><span class="line">    piece_buf = buf;</span><br><span class="line">    temp_size = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((piece_buf[<span class="number">0</span>] == <span class="number">0xAF</span>) &amp;&amp; (piece_buf[<span class="number">1</span>] == <span class="number">0xAE</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        piece_buf++;</span><br><span class="line">        temp_size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果检测到同步字，且剩余数据长度还超过 分片帧头长度</span></span><br><span class="line">    <span class="keyword">while</span> (temp_size &gt; HEAD_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前分片的数据长度</span></span><br><span class="line">        <span class="keyword">int</span> data_len = (piece_buf[HEAD_POS_P_LENGTH] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_P_LENGTH+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(temp_size &gt;= (HEAD_SIZE + data_len))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取分片编号</span></span><br><span class="line">            p_index = (piece_buf[HEAD_POS_P_INDEX] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_P_INDEX+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(udp_piece-&gt;total_size == <span class="number">0</span>)<span class="comment">// 重置后第一次收到数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取分片数据的总大小</span></span><br><span class="line">                udp_piece-&gt;total_size = (piece_buf[HEAD_POS_TOTAL_SIZE] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_SIZE+<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 获取总的分片数量</span></span><br><span class="line">                udp_piece-&gt;total_pieces = (piece_buf[HEAD_POS_TOTAL_PIECES] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_PIECES+<span class="number">1</span>]);</span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces  = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_buf)</span><br><span class="line">                    <span class="built_in">free</span>(udp_piece-&gt;recv_buf);</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>(udp_piece-&gt;total_size + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"malloc recv_buf filed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UDP_DEBUG( <span class="string">"buf size: %d, piece_data_len: %d, p_index: %d, recv_pieces: %d, total_size: %d, total_pieces: %d\n"</span>,</span><br><span class="line">                   temp_size, data_len, p_index, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, udp_piece-&gt;total_pieces );</span><br><span class="line">            temp_total_size = (piece_buf[HEAD_POS_TOTAL_SIZE] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_SIZE+<span class="number">1</span>]);</span><br><span class="line">            temp_total_pieces = (piece_buf[HEAD_POS_TOTAL_PIECES] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_PIECES+<span class="number">1</span>]);</span><br><span class="line">            udp_piece-&gt;recv_pieces++;</span><br><span class="line">            <span class="comment">// 分析下新的分片是否和原来的分片组有区别</span></span><br><span class="line">            <span class="keyword">if</span>((temp_total_size != udp_piece-&gt;total_size) || (temp_total_pieces != udp_piece-&gt;total_pieces))</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_size = temp_total_size;</span><br><span class="line">                udp_piece-&gt;total_pieces = temp_total_pieces;</span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_buf)</span><br><span class="line">                    <span class="built_in">free</span>(udp_piece-&gt;recv_buf);</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>(udp_piece-&gt;total_size + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"malloc recv_buf filed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            piece_buf += HEAD_SIZE;</span><br><span class="line">            temp_size -= HEAD_SIZE;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;udp_piece-&gt;recv_buf[PIECE_FIX_SIZE * p_index], piece_buf, data_len);</span><br><span class="line">            piece_buf += data_len;</span><br><span class="line">            temp_size -= data_len;</span><br><span class="line"></span><br><span class="line">            udp_piece-&gt;recv_len += data_len;<span class="comment">// 分片数据的累加</span></span><br><span class="line">            <span class="keyword">if</span>(udp_piece-&gt;recv_pieces == udp_piece-&gt;total_pieces)</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_pieces = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_len == udp_piece-&gt;total_size)</span><br><span class="line">                &#123;</span><br><span class="line">                    get_all_pieces = <span class="number">1</span>;<span class="comment">// 把所有分片组成完整的数据帧</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"recv_len != total_size! recv_len: %d, total_size: %d"</span>, udp_piece-&gt;recv_len, udp_piece-&gt;total_size );</span><br><span class="line">                    get_all_pieces = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_all_pieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片，使用环形缓存</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge_ex</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>tmp_total_size= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>tmp_total_pieces= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>p_index= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>get_all_pieces = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>bytes_to_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>bytes_to_read  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>value0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>value1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bytes_to_write = circular_buffer_write( udp_piece-&gt;circular_buffer, buf, <span class="built_in">size</span> );</span><br><span class="line">    <span class="keyword">if</span> ( bytes_to_write != <span class="built_in">size</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        UDP_ERR( <span class="string">"%s(%d) There is not enough space, only %d bytes, but need %d bytes\n"</span>,</span><br><span class="line">             __FUNCTION__, __LINE__, bytes_to_write, <span class="built_in">size</span> );</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从新收到的数据检测是否包含 片头</span></span><br><span class="line"><span class="comment">     * 检测头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, <span class="number">0</span>, &amp;value0 );          <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, <span class="number">1</span>, &amp;value1 );</span><br><span class="line">        <span class="keyword">if</span> ( value0 == <span class="number">0xAF</span> &amp;&amp; value1 == <span class="number">0xAE</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            circular_buffer_pop_front( udp_piece-&gt;circular_buffer, <span class="number">1</span>);        <span class="comment">/* 出队列一个元素 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果剩余的数据长度仍大于于 */</span></span><br><span class="line">    <span class="keyword">while</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt; HEAD_SIZE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前分片的数据长度（不含帧头） */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_LENGTH, &amp;value0 ); <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_LENGTH + <span class="number">1</span>, &amp;value1 );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> data_len = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">        <span class="comment">//data_len&lt;&lt;= 8;</span></span><br><span class="line">        <span class="comment">//data_len+= value1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* UDP_DEBUG("%s(%d)\n", __FUNCTION__, __LINE__); */</span></span><br><span class="line">        <span class="keyword">if</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt;= (HEAD_SIZE + data_len) )</span><br><span class="line">        &#123;</span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_INDEX, &amp;value0 );                   <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_INDEX + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            p_index = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">            <span class="keyword">if</span> ( udp_piece-&gt;total_size == <span class="number">0</span> )                                                               <span class="comment">/* 重置后第一次收到分片 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 计算当前分片所属分片组数据的总大小 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE, &amp;value0 );        <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">                udp_piece-&gt;total_size = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 计算当前分片所属分片组的总分片数量 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES, &amp;value0 );      <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">                udp_piece-&gt;total_pieces = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 重置当前接收分片的数量 */</span></span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* 重置当前接收到的数据长度 */</span></span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* 如果缓存区有数据则先释放 */</span></span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">                    <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">                <span class="comment">/* 分配能够存储一个分片组所有的数据的空间 */</span></span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>( udp_piece-&gt;total_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UDP_DEBUG( <span class="string">"buf size: %d, piece_data_len: %d, p_index: %d, recv_pieces: %d, total_size: %d, total_pieces: %d"</span>,</span><br><span class="line">                   circular_buffer_size( udp_piece-&gt;circular_buffer ), data_len, p_index, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, udp_piece-&gt;total_pieces );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算当前分片所属分片组数据的总大小 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE, &amp;value0 );        <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            tmp_total_size = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算当前分片所属分片组的总分片数量 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES, &amp;value0 );      <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            tmp_total_pieces = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">            udp_piece-&gt;recv_pieces++;</span><br><span class="line">            <span class="keyword">if</span> ( (tmp_total_pieces != udp_piece-&gt;total_pieces) || (tmp_total_size != udp_piece-&gt;total_size) )</span><br><span class="line">            &#123;</span><br><span class="line">                UDP_DEBUG( <span class="string">"Discard current frame, total_pieces:%d, cur_total_pieces:%d, recv_pieces:%d, total_size:%d, cur_total_size:%d\n"</span>,</span><br><span class="line">                       udp_piece-&gt;total_pieces, tmp_total_pieces, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, tmp_total_size );</span><br><span class="line">                <span class="comment">/* one piece of a new frame is coming, reset the variables */</span></span><br><span class="line">                udp_piece-&gt;total_size= tmp_total_size;</span><br><span class="line">                udp_piece-&gt;total_pieces = tmp_total_pieces;</span><br><span class="line">                udp_piece-&gt;recv_pieces= <span class="number">1</span>;</span><br><span class="line">                udp_piece-&gt;recv_len= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">                    <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>( udp_piece-&gt;total_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将帧头出队列</span></span><br><span class="line">            circular_buffer_pop_front( udp_piece-&gt;circular_buffer, HEAD_SIZE);</span><br><span class="line">            <span class="comment">// 读取分片数据</span></span><br><span class="line">            bytes_to_read = circular_buffer_read( udp_piece-&gt;circular_buffer,</span><br><span class="line">                                  &amp;udp_piece-&gt;recv_buf[PIECE_FIX_SIZE * p_index],</span><br><span class="line">                                  data_len );</span><br><span class="line">            <span class="keyword">if</span> ( bytes_to_read != data_len )</span><br><span class="line">            &#123;</span><br><span class="line">                UDP_ERR( <span class="string">"%s(%d) There is not enough space, only %d bytes, but need %d bytes\n"</span>,</span><br><span class="line">                     __FUNCTION__, __LINE__, bytes_to_write, <span class="built_in">size</span> );</span><br><span class="line">                <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            UDP_DEBUG( <span class="string">"remain size = %d\n"</span>, circular_buffer_size( udp_piece-&gt;circular_buffer ) );</span><br><span class="line"></span><br><span class="line">            udp_piece-&gt;recv_len += data_len;</span><br><span class="line">            <span class="keyword">if</span> ( udp_piece-&gt;recv_pieces == udp_piece-&gt;total_pieces )</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_pieces = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_len == udp_piece-&gt;total_size ) <span class="comment">/* current frame is received completely, call Process() */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 组成了一帧数据 */</span></span><br><span class="line">                    get_all_pieces = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"recv_len != total_size! recv_len: %d, total_size: %d"</span>, udp_piece-&gt;recv_len, udp_piece-&gt;total_size );</span><br><span class="line">                    get_all_pieces - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">        &#123;</span><br><span class="line">            UDP_DEBUG( <span class="string">"temp_size = %d, HEAD_SIZE + data_len = %d\n"</span>,</span><br><span class="line">                   circular_buffer_size( udp_piece-&gt;circular_buffer ), HEAD_SIZE + data_len );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(get_all_pieces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计划用两篇文章梳理一下ip，upd，tcp协议，重点放在后两者，因为后两者目前在应用上非常广，可编程性也大很多，本文将重点介绍UDP协议。&lt;/p&gt;
&lt;h2 id=&quot;UDP介绍&quot;&gt;&lt;a href=&quot;#UDP介绍&quot; class=&quot;headerlink&quot; title=&quot;UDP介绍&quot;&gt;&lt;/a&gt;UDP介绍&lt;/h2&gt;&lt;p&gt;UDP又名用户数据报协议（User Datagram Protocol）。UDP 为应用程序提供了一种&lt;strong&gt;无需建立连接就可以发送封装的 IP 数据包的协议&lt;/strong&gt;，可知UDP是基于IP协议的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="upd" scheme="https://icevil.cn/tags/upd/"/>
    
      <category term="通信协议" scheme="https://icevil.cn/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Electron之识</title>
    <link href="https://icevil.cn/2020/03/11/Electron%E4%B9%8B%E8%AF%86/"/>
    <id>https://icevil.cn/2020/03/11/Electron%E4%B9%8B%E8%AF%86/</id>
    <published>2020-03-11T13:22:38.000Z</published>
    <updated>2020-03-12T10:31:17.691Z</updated>
    
    <content type="html"><![CDATA[<p>当我第一次享受到nodejs的美好的时候是玩hexo的时候。说起electron缘于和顺丰的一个大佬的愉快聊天，虽然我很诚恳的表达了我对electron的未知，但还是很感谢他给我耐心介绍了一番。事后，我记下了这个关键字，闲来无事搜索认知。</p><a id="more"></a><h2 id="Electron之化繁为简"><a href="#Electron之化繁为简" class="headerlink" title="Electron之化繁为简"></a>Electron之化繁为简</h2><p>定义：<a href="https://www.electronjs.org/" target="_blank" rel="noopener" title="官网地址">使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</a></p><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 <code>JavaScript</code>, <code>HTML</code> 和 <code>CSS</code> 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。这是官网的一段原文。由此我们可以得知electron的核心设计思想就是<font color=red><strong>化繁为简</strong></font>。</p><h2 id="Electron特点"><a href="#Electron特点" class="headerlink" title="Electron特点"></a>Electron特点</h2><h3 id="1-Web-技术"><a href="#1-Web-技术" class="headerlink" title="1. Web 技术"></a>1. Web 技术</h3><p><code>Electron</code> 基于 <code>Chromium</code> 和 <code>Node.js</code>, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。</p><h3 id="2-开源"><a href="#2-开源" class="headerlink" title="2. 开源"></a>2. 开源</h3><p><code>Electron</code> 是一个由 <code>GitHub</code> 及众多贡献者组成的活跃社区共同维护的开源项目。</p><h3 id="3-跨平台"><a href="#3-跨平台" class="headerlink" title="3. 跨平台"></a>3. 跨平台</h3><p><code>Electron</code> 兼容 <code>Mac</code>、<code>Windows</code> 和 <code>Linux</code>，可以构建出三个平台的应用程序。</p><p><em>那electron是怎样化繁为简的呢？</em></p><blockquote><p>l.利用chromium项目基于c++开发的原因，chromium是跨平台的，如此便简化了跨平台的繁琐操作；<br>2.相比于传统桌面前端技术，没了各种语言的api（如：c/c++），没了系统gui框架api(如：mfc)，累活基本让chromium干了，开发人员只需关注业务代码，实现高定制的个性化界面，electron做到了类似于qt一样的实现自己的api，一处编写，各处运行。且呈现效果一致。js的学习难度与c/c++这种底层语言相比学习难度不知道低了多少。如此便简化了编程学习的曲线及难度；<br>3.electron如何保证高效的运行,拥抱开源。<font color=#ff4777><em>（这一点其实有点牵强，高不高效全建立在chromium渲染以及v8引擎，所以不适合极高速的渲染工程，像ps，3dmax这种图形图像软件或者工程测绘等实时性要求高的软件是不合适用electron框架来做的）</em></font></p></blockquote><h2 id="Electron开发入门"><a href="#Electron开发入门" class="headerlink" title="Electron开发入门"></a>Electron开发入门</h2><p>初识 Electron，可参考下列资料，了解如何使用 Electron 封装你的前端代码，调用丰富的 API，以及生成安装程序。</p><h3 id="探索-Electron-的-API"><a href="#探索-Electron-的-API" class="headerlink" title="探索 Electron 的 API"></a>探索 Electron 的 API</h3><p><a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">Electron API 示例程序</a>采用交互式界面展示了 Electron API 最关键的功能。发布版地址在这<br><a href="https://github.com/electron/electron-api-demos/releases" target="_blank" rel="noopener">从GitHub下载</a>。</p><h3 id="借助-Electron-Fiddle-深入探索"><a href="#借助-Electron-Fiddle-深入探索" class="headerlink" title="借助 Electron Fiddle 深入探索"></a>借助 <code>Electron Fiddle</code> 深入探索</h3><p>你可以使用 <code>Electron Fiddle</code> 创建并运行小段 <code>Electron</code> 程序，从一个简单的模板开始，随心所欲地挥洒你的创意，选择一个 <code>Electron</code> 版本欣赏运行效果。最后，你可以将其下载保存，或推送 <code>GitHub Gist</code> 上，所有人都可以输入网址运行你的 <code>Fiddle</code>。<br><a href="https://github.com/electron/fiddle/releases/latest" target="_blank" rel="noopener">从Github下载</a><br><a href="https://www.electronjs.org/fiddle" target="_blank" rel="noopener">详细</a></p><h3 id="关于help文档"><a href="#关于help文档" class="headerlink" title="关于help文档"></a>关于help文档</h3><p><a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">快速启动</a> 应用程序，看看 Electron 是如何运转的：<br><strong><em>一个有帮助内容的 Electron 应用。</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆示例项目的仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入这个仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖并运行</span></span><br><span class="line">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>或开始钻研<a href="https://www.electronjs.org/docs" target="_blank" rel="noopener">文档</a>。<br>使用 <code>Electron</code> 构建的应用<br>最初为 <code>GitHub</code> 开发 <a href="https://atom.io/" target="_blank" rel="noopener">Atom 编辑器</a>, <code>Electron</code> 此后被世界各地的公司采纳，如微软的<code>Visual Studio Code</code>。</p><p>有了官方文档，就可以开始干活了。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>首先，安装最新版本的<code>Node.js</code> 。 我们推荐您安装最新的 <code>长期支持版本</code> 或者 <code>当前发行版本</code> 。 访问<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js下载页面</a>，这里我选择 <code>Windows Installer</code>。 下载完成后， 执行安装程序，根据引导完成安装即可。</p><p>在安装过程中的配置界面, 请勾选<code>Node.js runtime</code>、<code>npm package manager</code>和<code>Add to PATH</code>这三个选项。</p><p>安装完成后，我们需要来确认<code>Node.js</code>是不是可以正常工作。 点击 <code>开始</code> 按钮，输入<code>PowerShell</code>，找到<code>Windows PowerShell</code>。 打开<code>PowerShell</code>或其他你喜欢的<code>命令行客户端</code>后，通过以下命令来确认 <code>node</code> 和 <code>npm</code>已经安装成功：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这行的命令会打印出Node.js的版本信息</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这行的命令会打印出npm的版本信息</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h3 id="开发第一个程序"><a href="#开发第一个程序" class="headerlink" title="开发第一个程序"></a>开发第一个程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#当前项目在线安装electron，各项目选择版本不同，可以使用此方法</span></span><br><span class="line">npm install --save-dev electron</span><br><span class="line"><span class="comment">#后面为空，是默认下载最新发布版electron的意思</span></span><br><span class="line">npm install </span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#全局安装</span></span><br><span class="line">npm install electron -g</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想修改下载安装的位版本(例如, 在x64机器上安装ia32位版本), 你可以使用npm install中的--arch标记，或者设置npm_config_arch 环境变量:</span></span><br><span class="line">npm install --arch=ia32 electron</span><br><span class="line"></span><br><span class="line"><span class="comment">#此外, 您还可以使用 --platform 来指定开发平台 (例如, win32、linux 等):</span></span><br><span class="line">npm install --platform=win32 electron</span><br></pre></td></tr></table></figure><p>离线安装<br>去<a href="https://github.com/electron/electron/releases" target="_blank" rel="noopener">electron/electron/releases</a><br>选择相应release版本下载安装文件。</p><p><font color=red>个人对这个安装包的理解：<br>就是一个小型chrome浏览器</font>，直接解压就可以使用，可以把这个解压目录加到环境变量，从而就可以直接运行<code>electron 项目路径</code>，如果不用环境变量，这每次执行需要运行：<code>electron.exe的路径 项目路径</code>.如下图我下载了一个<code>electron-quick-start-master</code>项目，然后把一个<code>blog</code>首页替换<code>index.html</code>即可得到一个和web一样效果的程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用electron启动</span></span><br><span class="line">.\electron-v8.1.1-win32-x64\electron.exe .\electron-quick-start-master\ </span><br><span class="line"></span><br><span class="line"><span class="comment">#用npm启动，前提是electron在环境变量中或者electron.exe和工程在同一个目录</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="electron_demo.png" alt="demo效果图" title="demo效果图"></p><h2 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h2><p>由上步骤，我们已经得到了一个完整的web项目，可是如何发布打包成一个exe呢？<br>在 Windows 上, 你必须使用安装程序将你的应用装到用户的计算机上才能使用<code>autoUpdater</code>, 所以比较推荐的方法是用 <a href="https://github.com/electron/windows-installer" target="_blank" rel="noopener">electron-winstaller</a>, <a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">electron-forge</a>或 <a href="https://github.com/electron/grunt-electron-installer" target="_blank" rel="noopener">grunt-electron-installer</a> 模块来生成Windows安装程序。</p><p>当使用 electron-winstaller 或 electron-forge 时，确保不要在第一次运行时更新你的应用程序 (详情参阅 这个问题的更多信息). 还建议使用 <code>electron-squirrel-startup</code> 来创建应用程序的桌面快捷方式。</p><p>使用Squirrel生成的安装程序将以<code>com.squirrel.PACKAGE_ID.YOUR_EXE_WITHOUT_DOT_EXE</code>,的格式创建一个带有<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85).aspx" target="_blank" rel="noopener">Application User Model ID</a> 的快捷图标,例子是 <code>com.squirrel.slack.Slack</code> 和 <code>com.squirrel.code.Code.</code>。 你应该在自己的应用中使用 <code>app.setAppUserModelId</code> API 方法设置相同的 API和ID，不然 Windows 将不能正确地把你的应用固定在任务栏上。</p><p>与 Squirrel.Mac 不同，Windows 版可以将更新文件放在 S3 或者其他静态主机上。 你可以阅读 <a href="https://github.com/Squirrel/Squirrel.Windows" target="_blank" rel="noopener">Squirrel.Windows</a>的文档来获得更多详细信息。</p><p>具体哪种打包怎么做参考相应GitHub链接即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我第一次享受到nodejs的美好的时候是玩hexo的时候。说起electron缘于和顺丰的一个大佬的愉快聊天，虽然我很诚恳的表达了我对electron的未知，但还是很感谢他给我耐心介绍了一番。事后，我记下了这个关键字，闲来无事搜索认知。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="https://icevil.cn/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="nodejs" scheme="https://icevil.cn/tags/nodejs/"/>
    
      <category term="electron" scheme="https://icevil.cn/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>VS使用WSL开发Linux程序配置说明</title>
    <link href="https://icevil.cn/2020/03/05/VS%E4%BD%BF%E7%94%A8WSL%E5%BC%80%E5%8F%91Linux%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <id>https://icevil.cn/2020/03/05/VS%E4%BD%BF%E7%94%A8WSL%E5%BC%80%E5%8F%91Linux%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</id>
    <published>2020-03-05T08:57:15.000Z</published>
    <updated>2020-03-05T09:43:27.105Z</updated>
    
    <content type="html"><![CDATA[<p>自Visual Studio 2019（简称vs）16.1版本开始，vs已经能够很好的支持WSL了，我们可以通过ssh连接在WSL上开发并调试c/c++程序。</p><a id="more"></a><p>Windows Subsystem for Linux (WSL) 第一次出现是在2016年的微软开发者大会上。现在win10的应用商店已经有好几版本的WSL系统了，尤其Ubuntu LTS版本最为受欢迎，下面也以Ubuntu为例。</p><h2 id="安装WSL-ubuntu"><a href="#安装WSL-ubuntu" class="headerlink" title="安装WSL(ubuntu)"></a>安装WSL(ubuntu)</h2><ol><li>首先我们要在win10启用开发者模式</li><li>然后去应用商店下载即可，<br>安装完成后，会提升我们呢输入用户名密码如下图<br><img src="bash-install-500x282.png" alt=""></li><li>安装c/c++必要的编译调试环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment">#We’ll also need to install gdbserver, a program that allows you to debug with a remote GDB debugger.</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install -y gdbserver</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装-amp-配置SSH"><a href="#安装-amp-配置SSH" class="headerlink" title="安装&amp;配置SSH"></a>安装&amp;配置SSH</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装ssh</span></span><br><span class="line">$ sudo apt install -y openssh-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh</span></span><br><span class="line"></span><br><span class="line">$ sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到 “PasswordAuthentication” 设置成 “yes”然后保存退出,如下图。<br><img src="bash-nanosshd-454x350.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成ssh keys</span></span><br><span class="line"></span><br><span class="line">$ sudo ssh-keygen -A</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动ssh，如果已经启动可以用restar替换start</span></span><br><span class="line"></span><br><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure><h2 id="安装-amp-配置Visual-Studio"><a href="#安装-amp-配置Visual-Studio" class="headerlink" title="安装&amp;配置Visual Studio"></a>安装&amp;配置Visual Studio</h2><p>下载安装vs17版本以上，最好19以上，安装的时候注意选择<code>Visual C++ for Linux</code>，安装完成后打开vs就有一下界面<br><img src="bashinstalllinux-500x293.png" alt=""><br>现在就可以连接到WSL了，操作如下：<br><code>Tools &gt; Options &gt; Cross Platform &gt; Connection Manager</code>.<br>如下图让你输入ip，端口，用户名，密码远程连接Linux了。其实如果不是wsl，是其他的Linux系统如子网或者公网的Linux系统都是可以的，前提是我们配置正确。<br><img src="bashconnectionmanager-500x290.png" alt=""></p><p>如果连接成功，vs会下载一些系统头文件到本地，方便我们编码时的智能感知提醒。至此我们的编译器就可使用了，新建工程试试。<br><code>File &gt; New Project &gt; Visual C++ &gt; Cross Platform &gt; Linux</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自Visual Studio 2019（简称vs）16.1版本开始，vs已经能够很好的支持WSL了，我们可以通过ssh连接在WSL上开发并调试c/c++程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="https://icevil.cn/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="vs" scheme="https://icevil.cn/tags/vs/"/>
    
      <category term="visual studio" scheme="https://icevil.cn/tags/visual-studio/"/>
    
      <category term="wsl" scheme="https://icevil.cn/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>Docker介绍及使用</title>
    <link href="https://icevil.cn/2020/03/01/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://icevil.cn/2020/03/01/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-01T02:24:56.000Z</published>
    <updated>2020-03-01T07:16:49.058Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><a id="more"></a><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>Docker 包括三个基本概念: </p><ul><li><p>镜像（Image）：<br>Docker 镜像（Image），就相当于是一个 root 文件系统。 比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系 统的 root 文件系统。 </p></li><li><p>容器（Container）：<br>镜像（Image）和容器（Container）的关系，就像是 面向对象程序设计中的类和实例一样如下表，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建Docker 容器。</p><table><thead><tr><th align="center">docker概念</th><th align="center">面向对象概念</th></tr></thead><tbody><tr><td align="center">容器</td><td align="center">对象</td></tr><tr><td align="center">镜像</td><td align="center">类</td></tr></tbody></table></li><li><p>仓库（Repository）：<br>仓库可看着一个代码控制中心，用来保存镜像</p><h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><h3 id="1-安裝"><a href="#1-安裝" class="headerlink" title="1. 安裝"></a>1. 安裝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不到300M</span></span><br><span class="line"><span class="comment">#sudo apt-get install docker在Ubuntu16以上要加.io</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="comment">#查看docker版本</span></span><br><span class="line">docker –v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安裝必要的系統工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment">#安裝GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/dockerce/linux/ubuntu/gpg | sudo apt-key add – </span><br><span class="line"></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span> </span><br><span class="line"> </span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install docker-ce –y </span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看 docker-ce 版本 </span></span><br><span class="line">sudo apt-cache madison docker-ce </span><br><span class="line"><span class="comment">#安装指定版本的 Docker-CE </span></span><br><span class="line">sudo apt-get install docker-ce=17.06.0~ce-0~ubuntu</span><br></pre></td></tr></table></figure></li><li><p><em>docker安装成功后，后续docker操作基本都要root权限，所以建议干脆直接切root账号。*</em></p></li></ul><h3 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2. 镜像仓库"></a>2. 镜像仓库</h3><p>查看可用的 Ubuntu 版本 访问 <a href="https://hub.docker.com" target="_blank" rel="noopener">Ubuntu 镜像库地址</a>。 可以通过 Sort by 查 看 其 他 版 本 的 Ubuntu 。 默 认 是 最 新 版 本 ubuntu:latest 。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所以镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 拉取ubuntu14.04</span></span><br><span class="line">docker pull ubuntu:14.04</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 启动已停止运行的容器'df9c1758dde1'，命令如下： </span></span><br><span class="line">docker start df9c1758dde1</span><br><span class="line"><span class="comment"># 查看容器所以命令</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 停止容器的命令如下： </span></span><br><span class="line">docker stop df9c1758dde1</span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart df9c1758dde1</span><br><span class="line"><span class="comment"># 进入容器两种方式attach与exec</span></span><br><span class="line">docker attach df9c1758dde1</span><br><span class="line">docker <span class="built_in">exec</span> -it df9c1758dde1 /bin/bash </span><br><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> df9c1758dde1 &gt; ubuntu.tar</span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">cat ubuntu.tar | docker import - ubuntu:v1</span><br><span class="line"><span class="comment"># 删除容器 </span></span><br><span class="line">docker rm -f b87fcf19d529 </span><br><span class="line"><span class="comment"># 拉取最新版Nginx</span></span><br><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><p>容器不退出，返回宿主机快捷键：<kbd>ctrl</kbd>+<kbd>p</kbd>+<kbd>q</kbd>，进入容器推荐<code>exec</code>；如果使用<code>attach</code>，多个终端登入的话会相互影响。<br>安装完成后，我们可以使用以下命令来运行 nginx 容器：<br><code>docker run --name nginx-test -p 8080:80 -d nginx</code> </p><ul><li>–name nginx-test：容器名称。 </li><li>-p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。 </li><li>-d nginx： 设置容器在在后台一直运行。 </li></ul><h3 id="3-定制镜像-Dockerfile"><a href="#3-定制镜像-Dockerfile" class="headerlink" title="3. 定制镜像 Dockerfile"></a>3. 定制镜像 Dockerfile</h3><pre><code>编写`Dockerfile`，然后执行`docker build -t 名称:tag .` </code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定制nginx的Dockfile如下</span></span><br><span class="line"><span class="comment"># This is dockerfile for nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># base image</span></span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># author</span></span><br><span class="line">MAINTAINER 作者名 myname@email.com</span><br><span class="line"></span><br><span class="line">ADD nginx-1.13.7.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD pcre-8.41.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD zlib-1.2.11.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD openssl-1.1.0g.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line"></span><br><span class="line">ADD sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install build-essential -y</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span>/src/nginx-1.13.7</span><br><span class="line"></span><br><span class="line">RUN ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_realip_module --with-http_addition_module --with-http_gzip_static_module --with-http_secure_link_module --with-http_stub_status_module --with-stream --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 --with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 --with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.1.0g &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"daemon off;"</span> &gt;&gt; /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/usr/local/nginx/sbin/nginx"</span>, <span class="string">"-c"</span>, <span class="string">"/usr/local/nginx/conf/nginx.conf"</span>]</span><br></pre></td></tr></table></figure><h2 id="文件系统隔离"><a href="#文件系统隔离" class="headerlink" title="文件系统隔离"></a>文件系统隔离</h2><p>docker里面不能直接使用<code>apt</code>这些系统命令，需要在前面加<code>/usr/bin/</code>如：<code>/usr/bin/apt-get</code>,加环境变量也可以</p><h3 id="docker实现原理："><a href="#docker实现原理：" class="headerlink" title="docker实现原理："></a>docker实现原理：</h3><ol><li>Mount namespace:挂载隔离，可以将日志文件共享到物理机，也可以通过该机制从docker拷贝文件到物理机。</li><li>UTS namespace:主机名的隔离，进入docker后，我们能看到终端的主机名会发生改变，不再是宿主机的hostname。</li><li>IPC namespace:两个进程间不能通过ipc技术通信</li><li>PID namespace:单独的pid系统，各docker都是从1开始，相当于Linux的init进程</li><li>Network namespace:网络不复用，网络不共享</li><li>User namespace:用户名隔离，与系统用户不一样</li></ol><p>以上6种隔离技术原理推荐阅读链接</p><p><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（上）</a><br><a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（下）</a><br>下面详述一下复杂的<code>Network namespace</code>.内容是copy上述链接中的，如果原链接能访问建议访问原链接，感谢<code>作者陈皓</code>。<br>在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p><p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）<br><img src="networknamespace.jpg" alt="" title="network namespace"><br>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p><p>当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hchen@ubuntu:~$ ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...</span><br><span class="line">    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>那么，要做成这个样子应该怎么办呢？我们来看一组命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 接下来，我们要创建一个network namespace - ns1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1   ip link <span class="built_in">set</span> dev lo up </span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 <span class="built_in">type</span> veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1  ip link <span class="built_in">set</span> dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1     ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure><p>上面基本上就是docker网络的原理了，只不过，</p><ul><li>Docker的resolv.conf没有用这样的方式，而是用了<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">上篇中的Mount Namesapce的那种方式</a></li><li>另外，docker是用进程的PID来做Network Namespace的名称的。<br>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link add peerA <span class="built_in">type</span> veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link <span class="built_in">set</span> peerA up </span><br><span class="line">ip link <span class="built_in">set</span> peerB netns <span class="variable">$&#123;container-pid&#125;</span> </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> dev peerB name eth1 </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> eth1 up ; </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip addr add <span class="variable">$&#123;ROUTEABLE_IP&#125;</span> dev eth1 ;</span><br></pre></td></tr></table></figure>上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</li></ul><p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p><p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p><p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a href="https://lwn.net/Articles/620087/" target="_blank" rel="noopener">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="docker" scheme="https://icevil.cn/tags/docker/"/>
    
      <category term="容器" scheme="https://icevil.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="镜像" scheme="https://icevil.cn/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用github,hexo,next搭建个人博客</title>
    <link href="https://icevil.cn/2020/02/11/%E4%BD%BF%E7%94%A8github-hexo-next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://icevil.cn/2020/02/11/%E4%BD%BF%E7%94%A8github-hexo-next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-11T12:52:22.000Z</published>
    <updated>2020-03-11T14:29:59.718Z</updated>
    
    <content type="html"><![CDATA[<p>其实之前一直用csdn写博客，后来闲来无事别想着自己搭一个平台，于是用了wordpress，不愧是出自大厂（Facebook），可以说的上是简单、优美、功能完善一应俱全。然而，让我放弃的原因有点单调，设想自己N年后，把自己的记录整理一番，发现某些博客平台导出非常不友好，而wordpress虽然能做很多事情，但是。。。好吧不但是了，我是一个有强迫症的人，我就是要用markdown文档，记得第一次接触这种格式是在GitHub的<code>readme.md</code>，没想到用了几年后蓦然回首才发现被她的美深深吸引。因为我觉得这种文档格式非常好，精简高效地实现了较为友好的阅读效果，所以当我知道hexo原生支持<code>markdown</code>做博客文档时候，我就明确我要干些啥了。</p><a id="more"></a><p>抒情完了，介于做博客，本文将介绍如何使用GitHub pages和hexo来搭建一个个人博客。github pages 是一个静态网页博客平台。建立好git仓库之后，可以直接在github上配置生成一个简单的首页index.html <strong>(没错还是hello world)</strong>，另外还支持域名配置。hexo是一个基于nodeJS实现的博客框架。它的最大的作用就是能将 <strong>markdown文档</strong>自动转化成 <strong>html文档</strong>。再搭配一些主题（比如：<strong>next主题</strong>）,将显示的非常美观，而且next主题是一个开源的可以自由定制的主题。</p><h2 id="关于hexo的安装及使用"><a href="#关于hexo的安装及使用" class="headerlink" title="关于hexo的安装及使用"></a>关于hexo的安装及使用</h2><p>先安装nodejs，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>下载安装即可。Linux 安装npm即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure><p>输入 <code>npm -v</code> ，如果出现版本号，那说明安装成功了并且环境变量也配置好了，如果是未知命令那就要配置一下环境变量。</p><p><strong>windows的安装</strong><br>如果已经安装了<em>git bash</em>,可以在<em>git bash</em>中使用以下安装命令（网上有人反应过失败，用cmd能成功，但应该是个例），否则使用<em>cmd</em>（快捷键<kbd>Win</kbd>+<kbd>R</kbd>然后输入cmd）窗口也是一样。后面的就和命令行安装一摸一样了。<br><strong>命令行安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#windows环境的话</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment">#linux环境的话</span></span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>这一步安装可能略慢，原因大家都懂，就不说了。输入<code>hexo -v</code>如果能看到版本信息就说明成功了,另附<a href="https://www.w3cschool.cn/nodejs/nodejs-npm.html" target="_blank" rel="noopener">npm W3C教程</a>。<br>接下来就可以用hexo来生成博客了。新建一个博客文件夹，如blog,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo init</span><br><span class="line">hexo generate   //可以简写成hexo g</span><br><span class="line">hexo server     //可以简写成hexo s</span><br></pre></td></tr></table></figure><p>成功后，我们可以看到提示 localhost:4000 可以访问，用浏览器打开，可以看到首页。<br><img src="localhost.png" alt="生成博客成功" title="博客首页"><br>个人调试可以用以下命令去一键生成：<br><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code><br>意思是先清除现有博客，然后生成，发布。另外hexo的远程部署命令是<code>hexo d</code>.</p><h2 id="hexo配合github建站"><a href="#hexo配合github建站" class="headerlink" title="hexo配合github建站"></a>hexo配合github建站</h2><p>当我们需要远程部署的时候，需要先安装<em>hexo-deployer-git</em>。<br><code>npm install hexo-deployer-git --save</code><br>安装好之后在博客目录配置文件_config.yml最后面添加deploy字段如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:UserName/Blog.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>如果git仓库是ssh则需要生成rsa key,添加公钥到github，后续用远程更新代码即可不用输入用户名密码验证。这是git的操作，本文部再赘述。</p><blockquote><p>此外，如果您的 <code>Github Pages</code> 需要使用 <code>CNAME</code> 文件自定义域名，请将 <code>CNAME</code> 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 <code>CNAME</code> 文件一并推送至部署分支。</p></blockquote><p>关于hexo的工程文件说明如下：</p><blockquote><p>_config.yml ——工程配置文件<br>source/ ——该目录为我们存放markdown文件的地方<br>theme/ ———存放主题的目录<br>public/ ——发布生成的路径，hexo clean可以删除该目录</p></blockquote><h3 id="hexo-创建文章、标签、分类"><a href="#hexo-创建文章、标签、分类" class="headerlink" title="hexo 创建文章、标签、分类"></a>hexo 创建文章、标签、分类</h3><ul><li><p>创建文章<code>hexo new &quot;文章名称&quot;</code></p><pre><code>---title: CentOS7下Tomcat启动慢的原因及解决方案date: 2017-12-02 21:01:24comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;云服务器&quot; #分类tags:   #标签    - centOS    - tomcat---</code></pre></li><li><p>创建标签<code>hexo new page tags</code></p><pre><code>title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot;</code></pre></li><li><p>创建分类<code>hexo new page categories</code></p><pre><code>title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot;</code></pre><p>更多hexo详细说明如<code>API，主题，插件</code>等请参阅<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文官方文档</a>。<br>注意标签和分类中，title可以为空，但是type:一定要写对，否则网站不能自动关联。</p></li></ul><h2 id="next教程"><a href="#next教程" class="headerlink" title="next教程"></a>next教程</h2><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；称为 <code>站点配置文件</code>， 另一份位于主题目录下，称为 <code>主题配置文件</code>。<br><strong>nexT</strong>是一个<a href="https://github.com/iissnan/hexo-theme-next/releases/tag/v5.1.4" target="_blank" rel="noopener">github 上的开源主题</a>。<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">nexT官网</a>有教程教怎么使用、配置等。</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><ul><li><p>克隆最新版本</p><blockquote><p>在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> your-hexo-site</span><br><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure></li><li><p>下载稳定版本</p><blockquote><p>1.前往 NexT 版本 <a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">发布页面</a>。<br>2.选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。例如，下载 v0.4.0 版本。<br>3.解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（<code>hexo-theme-next-0.4.0</code>）更改为 next。</p></blockquote></li></ul><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 <code>克隆/下载</code> 完成后，打开 站点配置文件， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><table><thead><tr><th>启用 NexT 主题</th></tr></thead><tbody><tr><td>theme:<code></code>next</td></tr></tbody></table><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<br><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，检查站点是否正确运行。<br>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p><h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><blockquote></blockquote><p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新</p><p>Scheme 的切换通过更改 <code>主题配置文件</code>，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p><table><thead><tr><th>选择 Pisces Scheme</th></tr></thead><tbody><tr><td>#scheme: Muse</td></tr><tr><td>#scheme: Mist</td></tr><tr><td>scheme: Pisces</td></tr></tbody></table><h4 id="设置-界面语言"><a href="#设置-界面语言" class="headerlink" title="设置 界面语言"></a>设置 界面语言</h4><p>编辑 站点配置文件， 将 <code>language</code> 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：<br>` language: zh-Hans<br>目前 NexT 支持的语言如以下表格所示：</p><table><thead><tr><th>语言</th><th>代码</th><th>设定示例</th></tr></thead><tbody><tr><td>English</td><td>en</td><td>language: en</td></tr><tr><td>简体中文</td><td>zh-Hans</td><td>language: zh-Hans</td></tr><tr><td>Français</td><td>fr-FR</td><td>language: fr-FR</td></tr><tr><td>Português</td><td>pt</td><td>language: pt or language: pt-BR</td></tr><tr><td>繁體中文</td><td>zh-hk 或者 zh-tw</td><td>language: zh-hk</td></tr><tr><td>Русский язык</td><td>ru</td><td>language: ru</td></tr><tr><td>Deutsch</td><td>de</td><td>language: de</td></tr><tr><td>日本語</td><td>ja</td><td>language: ja</td></tr><tr><td>Indonesian</td><td>id</td><td>language: id</td></tr><tr><td>Korean</td><td>ko</td><td>language: ko</td></tr></tbody></table><h4 id="设置-菜单"><a href="#设置-菜单" class="headerlink" title="设置 菜单"></a>设置 菜单</h4><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p><p>编辑 <code>主题配置文件</code>，修改以下内容：</p><ul><li>设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：<code>item name: link</code>。其中 <code>item name</code> 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。<blockquote></blockquote>菜单示例配置<br>menu:<br>home: /<br>archives: /archives<br>#about: /about<br>#categories: /categories<br>tags: /tags<br>#commonweal: /404.html</li></ul><blockquote><p>若你的站点运行在子目录中，请将链接前缀的 <code>/</code> 去掉</p></blockquote><p>NexT 默认的菜单项有（标注  的项表示需要手动创建这个页面）：</p><table><thead><tr><th>键值</th><th>设定值</th><th>显示文本（简体中文）</th></tr></thead><tbody><tr><td>home</td><td>home: /</td><td>主页</td></tr><tr><td>archives</td><td>archives: /archives</td><td>归档页</td></tr><tr><td>categories</td><td>categories: /categories</td><td>分类页</td></tr><tr><td>tags</td><td>tags: /tags</td><td>标签页</td></tr><tr><td>about</td><td>about: /about</td><td>关于页面</td></tr><tr><td>commonweal</td><td>commonweal: /404.html</td><td>公益 404</td></tr></tbody></table><ul><li>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/{language}.yml</code> （{language} 为你所使用的语言）。</li></ul><p>以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 <code>languages/zh-Hans.yml</code>，在 <code>menu</code> 字段下添加一项：</p><blockquote></blockquote><p>menu:<br>  home: 首页<br>  archives: 归档<br>  categories: 分类<br>  tags: 标签<br>  about: 关于<br>  search: 搜索<br>  commonweal: 公益404<br>  something: 有料</p><ul><li><p>设定菜单项的图标，对应的字段是 <code>menu_icons</code>。 此设定格式是 <code>item name: icon name</code>，其中 <code>item name</code> 与上一步所配置的菜单名字对应，<code>icon name</code> 是 Font Awesome 图标的 名字。而 <code>enable</code> 可用于控制是否显示图标，你可以设置成 <code>false</code> 来去掉图标。</p><blockquote></blockquote><p>菜单图标配置示例<br>menu_icons:</p><pre><code>enable: true\# Icon Mapping.home: homeabout: usercategories: thtags: tagsarchives: archivecommonweal: heartbeat</code></pre></li><li><p>在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 :?  作为图标。</p></li><li><p>请注意键值（如 <code>home</code>）的大小写要严格匹配</p><h4 id="设置-侧栏"><a href="#设置-侧栏" class="headerlink" title="设置 侧栏"></a>设置 侧栏</h4><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p></li><li><p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p><blockquote></blockquote><p>left - 靠左放置<br>right - 靠右放置</p></li></ul><p>目前仅 Pisces Scheme 支持 <code>position</code> 配置。影响版本5.0.0及更低版本。</p><blockquote></blockquote><p>sidebar:<br>  position: left</p><ul><li>设置侧栏显示的时机，修改 <code>sidebar.display</code> 的值，支持的选项有：<blockquote></blockquote></li><li>post - 默认行为，在文章页面（拥有目录列表）时显示</li><li>always - 在所有页面中都显示</li><li>hide - 在所有页面中都隐藏（可以手动展开）</li><li>remove - 完全移除</li></ul><blockquote></blockquote><p>sidebar:<br>  display: post</p><ul><li>已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。</li></ul><h4 id="设置-头像"><a href="#设置-头像" class="headerlink" title="设置 头像"></a>设置 头像</h4><p>编辑 主题配置文件， 修改字段 <code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p><table><thead><tr><th>地址</th><th>值</th></tr></thead><tbody><tr><td>完整的互联网 URI</td><td><a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></td></tr><tr><td>站点内的地址</td><td>将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）</td></tr><tr><td></td><td>配置为：avatar: /uploads/avatar.png</td></tr><tr><td></td><td>或者 放置在 source/images/ 目录下</td></tr><tr><td></td><td>配置为：avatar: /images/avatar.png</td></tr></tbody></table><blockquote></blockquote><p>头像设置示例<br>avatar: <a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></p><h4 id="设置-作者昵称"><a href="#设置-作者昵称" class="headerlink" title="设置 作者昵称"></a>设置 作者昵称</h4><p>编辑 <code>站点配置文件</code>， 设置 <code>author</code> 为你的昵称。</p><h4 id="设置-站点描述"><a href="#设置-站点描述" class="headerlink" title="设置 站点描述"></a>设置 站点描述</h4><p>编辑 <code>站点配置文件</code>， 设置 <code>description</code> 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>请参考连接<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">主题配置</a></p><h2 id="注意，踩坑记录："><a href="#注意，踩坑记录：" class="headerlink" title=" 注意，踩坑记录："></a><span style=color:red;> 注意，踩坑记录：</span></h2><ol><li><p>正文中表示超链接时，前后应该用空格流出或者用特殊标签标记如:`http:localhost:4000`。原因：md语法问题导致的编译工程报错!</p></li><li><p>正文中输入#等特殊字符应该使用转义，否则也会因为解析失败，不能编译成功。</p></li><li><p>关于定制样式。chrome调配置样式，使用<kbd>F12</kbd>进入调试模式，找到相应的css或者js再去IDE（如：<code>vs code</code>）中打开的工程中搜索并修改即可。</p></li><li><p>表格不显示，前面一定要空一行，且表头不能省略<code>|</code>。</p></li><li><p>404公益是直接将<code>/404/</code>改成<code>/404.html</code>.</p></li><li><p>主题(next)里面访问的资源路径总是根目录，即使站点设置了child目录为根目录也不行（设置upload目录也不会被生成，即使站点打开了asset，目录乱绝对是一个bug。待修复）。<br>似乎现在已经修复了这个bug（待验证）。总之官方的使用方式很麻烦且阅读性烂，<del>推荐 <code>hexo-asset-image</code> 插件，使用方法就是通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹</del>（新版本已经不再需要）。修改 <code>_config.yml</code>下的 <code>post_asset_folder: true</code> 将其改成true.用的时候只要 <code>![a](a.jpg)</code> 即可，插件会自动修改具体的路径。完整的目录结构如下:</p><blockquote></blockquote><p>TEST<br>├── a.jpg<br>├── b.jpg<br>└── c.jpg<br>TEST.md</p></li><li><p>数学公式不显示，在_config.yml文件中启用mathjax，并在文章<code>font-matter</code>里面添加：<code>mathjax: true</code><br>这是一个公式渲染引擎，默认是关闭的，每篇文章加这个是为了避免拖慢访问速度。 </p></li><li><p>关于插件，推荐<br> 1.使用RSS:<code>npm install --save hexo-generator-feed</code><br> 2.博客管理:<code>npm install --save hexo-admin</code><br> 3.<del>Asset管理:<code>npm install --save hexo-asset</code>,也许是新版修复了bug的问题，在新版中使用这个会导致有图片的文章重复解析一遍，害我找了半天，但我更相信这还是一个bug，（不推荐）</del>没试<code>hexo-asset-image</code>这个插件。<br> 4.文章字数统计:<code>npm i --save  hexo-symbols-count-time</code><br> 5.文章搜索插件:<code>npm install hexo-generator-searchdb --save</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实之前一直用csdn写博客，后来闲来无事别想着自己搭一个平台，于是用了wordpress，不愧是出自大厂（Facebook），可以说的上是简单、优美、功能完善一应俱全。然而，让我放弃的原因有点单调，设想自己N年后，把自己的记录整理一番，发现某些博客平台导出非常不友好，而wordpress虽然能做很多事情，但是。。。好吧不但是了，我是一个有强迫症的人，我就是要用markdown文档，记得第一次接触这种格式是在GitHub的&lt;code&gt;readme.md&lt;/code&gt;，没想到用了几年后蓦然回首才发现被她的美深深吸引。因为我觉得这种文档格式非常好，精简高效地实现了较为友好的阅读效果，所以当我知道hexo原生支持&lt;code&gt;markdown&lt;/code&gt;做博客文档时候，我就明确我要干些啥了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="https://icevil.cn/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="nodejs" scheme="https://icevil.cn/tags/nodejs/"/>
    
      <category term="github page" scheme="https://icevil.cn/tags/github-page/"/>
    
      <category term="hexo" scheme="https://icevil.cn/tags/hexo/"/>
    
      <category term="next" scheme="https://icevil.cn/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>搭建gitlab仓库</title>
    <link href="https://icevil.cn/2020/02/09/%E6%90%AD%E5%BB%BAgitlab%E4%BB%93%E5%BA%93/"/>
    <id>https://icevil.cn/2020/02/09/%E6%90%AD%E5%BB%BAgitlab%E4%BB%93%E5%BA%93/</id>
    <published>2020-02-09T10:30:56.000Z</published>
    <updated>2020-03-09T12:31:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>我们熟知github这个强大的源代码管理仓库，利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。但是介意外网访问速度的原因，以及企业安全的角度，我们通常考虑自己搭建自己的类似hub站点，其实个人使用的话，我觉得完全没必要搭建hub，在公网平台上搭一个远程仓库就够用了。而本文将主要以Ubuntu18为例讲解如何搭建一个自己的gitlab仓库，好了写本文的目的估计都猜到了，没错，就是出于练手。</p><a id="more"></a><h2 id="github的特点"><a href="#github的特点" class="headerlink" title="github的特点"></a>github的特点</h2><p>Repo：项目，绝大多数的开源项目都会放在github上，包括<code>Linus Torvalds</code>参与的linux内核，基于repo可以提<br>      issue，可以review code，可以有wiki，branch，tag等等都支持，还可以star和fork这样的repo。<br>Explore：基于兴趣显示了一些开源项目<br>Topics：按照主题显示的一些项目，可以选择某个主题继续观察<br>Trending：流行repo，可以选择语言和周期来显示<br>Events：显示github官方的一些活动</p><p>我们可以通过搜索关键字、stars:&gt;1000、fork:&gt;100、语言等来搜索高质量的仓库。</p><h2 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h2><p>GitLab是利用 <code>Ruby on Rails</code> 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。很多公司都是基于gitlab进行版本管理的。</p><h2 id="搭建gitlab"><a href="#搭建gitlab" class="headerlink" title="搭建gitlab"></a>搭建gitlab</h2><h3 id="第一步：安装一些依赖软件"><a href="#第一步：安装一些依赖软件" class="headerlink" title="第一步：安装一些依赖软件"></a>第一步：安装一些依赖软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br><span class="line">sudo apt-get install -y postfix  # postfix发送邮件，其它的邮件配置见：https://docs.gitlab.com/omnibus/settings/smtp.html</span><br></pre></td></tr></table></figure><h3 id="第二步：添加下载源："><a href="#第二步：添加下载源：" class="headerlink" title="第二步：添加下载源："></a>第二步：添加下载源：</h3><p>添加下载源之前，如果没有添加GPG信任，需要先信任 GitLab 的 GPG 公钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><p>已信任的可以跳过，如果不添加信任，更新源的时候会有如下错误提示<br><img src="GPG.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list.d/gitlab_gitlab-ee.list </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打开该文件添加：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：版本号别错ubuntu16是xenial,18是bionic</span></span><br><span class="line">deb https://mirrors.tencent.com/gitlab-ce/ubuntu bionic main</span><br><span class="line"><span class="meta">#</span><span class="bash">更新源列表</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>更新源成功如下图：<br><img src="addGPG.png" alt=""></p><h3 id="第三步：安装gitlab"><a href="#第三步：安装gitlab" class="headerlink" title="第三步：安装gitlab"></a>第三步：安装gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><p>安装成功后，如下图：<br><img src="gitlab.png" alt=""></p><h3 id="第四步：配置gitlab"><a href="#第四步：配置gitlab" class="headerlink" title="第四步：配置gitlab"></a>第四步：配置gitlab</h3><p>下面的命令基本要用root权限，所以建议提前<code>sudo -i</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">external_url ‘http://192.168.2.129’ <span class="comment"># 把external_url修改成访问的IP，当然更复杂的配置信息可以参考,</span></span><br><span class="line"><span class="comment">#https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab</span></span><br><span class="line"><span class="comment">#如果用nginx代理可以不配置这个。</span></span><br><span class="line">gitlab-ctl reconfigure  <span class="comment"># 开始配置</span></span><br></pre></td></tr></table></figure><h3 id="第五步：启动重启查看状态："><a href="#第五步：启动重启查看状态：" class="headerlink" title="第五步：启动重启查看状态："></a>第五步：启动重启查看状态：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl restart/start/status/stop     <span class="comment"># 通过gitlab-ctl help都能查看到该信息</span></span><br></pre></td></tr></table></figure><p>启动浏览器访问试试？<br><img src="502.png" alt=""><br>不慌，此时我们可以使用<code>gitlab-ctl tail</code>来查看gitlab的服务日志，通过日志可以看到8080端口被别的进程占用了，那就改个端口咯。</p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>此时需要修改gitlab的配置信息，如下：<br>由于默认gitlab使用80端口，所以，我们需要修改gitlab的默认端口（unicorn会占用8080端口，nginx会占用80端口）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line">nginx[<span class="string">'listen_port'</span>] = 8988 <span class="comment">#nginx外部访问的端口</span></span><br><span class="line">unicorn[<span class="string">'port'</span>] = 8989 <span class="comment">#这个端口是内部nginx跳转的端口这个可以随意设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新配置</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>如果不出意外应该可以看到站点已经可以访问，如下图：<br><img src="succeed.png" alt=""><br>这是第一次登录让你添加新密码的。输入完密码，你会发现要登录，用户名是啥？不要慌，试试：<code>root+您刚设置的新密码</code>。<br>惊喜过后，添加个test仓库试试玩玩？<br><img src="down.png" alt=""></p><h3 id="有没有疑问您的仓库存储在了哪里？"><a href="#有没有疑问您的仓库存储在了哪里？" class="headerlink" title="有没有疑问您的仓库存储在了哪里？"></a>有没有疑问您的仓库存储在了哪里？</h3><p>gitlab默认路径是：<code>/var/opt/gitlab/git-data/repositories</code><br>cd进去看看？看不出就对了，这是git的文件镜像，不是给人读的文件。<br>如果要进行git仓库的迁移,做如下操作</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 准备迁移之前要停止GitLab服务，防止用户写入数据。</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"><span class="meta"># 注意 'repositories'后面不带斜杠，而</span></span><br><span class="line"><span class="meta"># '/home/gitlab-data'后面是有斜杠的。</span></span><br><span class="line"> rsync -av /<span class="keyword">var</span>/opt/gitlab/git-data/repositories /home/gitlab-data/</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果需要修复权限设置，</span></span><br><span class="line"><span class="meta"># 可运行下面的命令进行修复。</span></span><br><span class="line"> gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="meta"># 再次检查下  /home/gitlab-data 的目录. 正常情况应该有下面这个子目录:</span></span><br><span class="line"><span class="meta"># repositories</span></span><br><span class="line"></span><br><span class="line"> ls /home/gitlab-data/</span><br><span class="line">repositories</span><br><span class="line"><span class="meta"># 完工! 启动GitLab，验证下是否能</span></span><br><span class="line"><span class="meta"># 通过web访问Git仓库。</span></span><br><span class="line"> gitlab-ctl start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们熟知github这个强大的源代码管理仓库，利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。但是介意外网访问速度的原因，以及企业安全的角度，我们通常考虑自己搭建自己的类似hub站点，其实个人使用的话，我觉得完全没必要搭建hub，在公网平台上搭一个远程仓库就够用了。而本文将主要以Ubuntu18为例讲解如何搭建一个自己的gitlab仓库，好了写本文的目的估计都猜到了，没错，就是出于练手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="git" scheme="https://icevil.cn/tags/git/"/>
    
      <category term="gitlab" scheme="https://icevil.cn/tags/gitlab/"/>
    
      <category term="github" scheme="https://icevil.cn/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://icevil.cn/2020/02/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://icevil.cn/2020/02/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-02-04T02:34:40.000Z</published>
    <updated>2020-02-29T03:09:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。过滤器还能干啥？老东西为何又突然热了起来？假设我们要做一个爬虫程序，如何判断某个地址已经被爬过了？一个海量数据集中如何判断某个值是否存在？带着问题去思考，请看下面详解。</p><a id="more"></a><p>我们已经知道map（前面已经说过基于红黑树实现的）已经起到了很好的查找效率，如100w的数据量，我们也只需要20次查找即可。</p><p>就算嫌弃速度慢了，我们也可以用hashmap这样的数据结构，hashmap能保证我们O(1)查找，但是我们需要知道的是hashmap是一个空间换时间的数据结构，由一个巨大的hash(key)组成的数组，且每个数值下面还有一个列表用以保存hash碰撞的数据。4G内存空间也就是$2^{32}$字节。假设我们用的是32位hash算法也就10亿数据量，再留空一部分，以及保存hash碰撞的数据，我们一般不能存储超过5亿数据量，否则hash碰撞多了，效率会下降。</p><p><span style=color:red>那有没有省时省空间的算法呢？<span><br>那么这就算布隆过滤器又被人们热谈的原因了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>由一系列hash函数转换之后得到的值作为position的<code>bitmap数据结构</code></strong>——本人自定义，不嫌麻烦的还是去百度搜吧。</p><p>百度盗个图，以图解说bloom算法<br><img src="bloom.jpg" alt="布隆过滤器" title="布隆过滤器"><br>这是一个通过3个hash函数得到3个pos,将bitmap的这3个pos置1，即得到了集合S转化后的布隆过滤器B。<br>如图S中的元素a,b,c都是通过3个hash得到的值作为B的下标,然后将<code>相应位置的值 | 1</code>即可。这样当判断d,e是否在集合S中的时候，同样对d,e分别做3次hash得到的3个pos,是否都为1？</p><blockquote><ol><li>如果不全为1，必不在集合S中；</li><li>如果全为1，可能在集合S中</li></ol></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>速度快O(1)</li><li>占空间小<blockquote><p>与hashMap相比，<br>以100w数据量为例，k次hash，也就是 1/k（当然这里k肯定是一个很小的数，k这里绝不是一个线性递减的，而是当k大到一定程度，将趋于不变，而k越大时间开销会成倍增大。具体见文末链接） Mb空间,当然这样的空间是不合理的，碰撞率接近1了，但是与hashmap相比，hashmap碰撞率也将这么高.<br>而hashmap，32位hash算法为例，约用32M空间做key，还没算value对应的list空间。<br>占$&lt; 1/32k$.</p></blockquote></li></ol><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol><li>不能删除元素，只能增加元素</li><li>只能判断可能在，这是一个概率结果，该算法能优化的也就是在大概率存在。不能保证存在。</li></ol><h2 id="布隆过滤器具体参数关系参考"><a href="#布隆过滤器具体参数关系参考" class="headerlink" title="布隆过滤器具体参数关系参考"></a>布隆过滤器具体参数关系参考</h2><p><a href="https://hur.st/bloomfilter" target="_blank" rel="noopener">各参数对应假阳概率关系</a></p><blockquote><p>n为容量<br>p为假阳概率<br>m为所需内存空间<br>k为hash数量</p></blockquote><iframe src="https://hur.st/bloomfilter/?n=1000000&p=1.0E-7&m=&k=" width="100%" height="100%" frameborder="0">您的浏览器不支持iframe，请升级</iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;布隆过滤器（Bloom Filter）是1970年由布隆提出的。过滤器还能干啥？老东西为何又突然热了起来？假设我们要做一个爬虫程序，如何判断某个地址已经被爬过了？一个海量数据集中如何判断某个值是否存在？带着问题去思考，请看下面详解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://icevil.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="过滤器" scheme="https://icevil.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="bloom" scheme="https://icevil.cn/tags/bloom/"/>
    
      <category term="hash" scheme="https://icevil.cn/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>B树与B+树</title>
    <link href="https://icevil.cn/2020/02/02/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/"/>
    <id>https://icevil.cn/2020/02/02/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</id>
    <published>2020-02-02T03:40:00.000Z</published>
    <updated>2020-02-29T03:09:28.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>B树又写做B-树，做索引的时候，hash ，红黑树效率已经很高了，什么时候要用到B树？</p><a id="more"></a><p>B树的应用：当我们的内存不够支撑的时候，往往B树的效率更好。hash,红黑树都是基于内存内数据的高效查找。文件系统的索引，数据库的索引都是采用B树实现。<br>那为什么B树在磁盘访问的时候更高效呢？<br>原因：如果用二叉树，1024个节点，我们需要一个10层高的二叉树。10层高，就相当于我们需要访问10次磁盘才能找到相应值。磁盘的访问速度是远不如内存的。故二叉树性能会显得格外低，那我们必然会考虑到多叉树，如果是毫无约束的多叉树，<strong>树就可能变成一个链表，性能将降到最低状态。</strong>所以有必要对多叉树做适当的约束，而B树就是这样的一个<strong>自平衡的多叉树</strong>数据结构。</p><h3 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h3><p>一颗M阶B树T，满足以下条件 </p><ol><li>每个结点至多拥有M棵子树 </li><li>根结点至少拥有两棵子树 </li><li>除了根结点以外，其余每个分支结点至少拥有M/2棵子树 </li><li><span style=color:red> 所有的叶子结点都在同一层上 </span></li><li><span style=color:red>有k棵子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序</span> </li><li>关键字数量满足 ceil(M/2) - 1 &lt;= n &lt;= M-11</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义M的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEGREE5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KEY_VALUE;</span><br><span class="line"><span class="comment">//B树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> &#123;</span></span><br><span class="line">    KEY_VALUE *keys;<span class="comment">//key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> **<span class="title">childrens</span>;</span><span class="comment">//子结点地址</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//子结点长度应该是M-1</span></span><br><span class="line">    <span class="keyword">int</span> leaf;<span class="comment">//是否叶子结点</span></span><br><span class="line">&#125; btree_node;</span><br><span class="line"><span class="comment">//B树的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree</span> &#123;</span></span><br><span class="line">    btree_node *root;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="comment">//M值</span></span><br><span class="line">&#125; btree;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol><li>插入值，总是从根结点开始插入</li><li>插入结点长度 &lt;M 直接插入</li><li>等于M 需要裂变，裂变从根结点开始裂变<ol><li>创建一个空的结点</li><li>将裂变位置右边的给新结点，准备将裂变位置给父节点</li><li>遍历父节点从i位置开始全部右移一位，给裂变点空出位置</li><li>将裂变点赋值给父节点i位置</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//树T的x结点从i位置开始裂变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_split_child</span><span class="params">(btree *T, btree_node *x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = T-&gt;t;</span><br><span class="line"></span><br><span class="line">    btree_node *y = x-&gt;childrens[i];<span class="comment">//y是开始裂变的结点</span></span><br><span class="line">    btree_node *z = btree_create_node(t, y-&gt;leaf);<span class="comment">//创建一个空结点位置以便插入新值</span></span><br><span class="line"></span><br><span class="line">    z-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将i右边的值先移到新的结点z中</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t<span class="number">-1</span>;j ++) &#123;</span><br><span class="line">        z-&gt;keys[j] = y-&gt;keys[j+t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;leaf == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t;j ++) &#123;</span><br><span class="line">            z-&gt;childrens[j] = y-&gt;childrens[j+t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父结点x大于i的右移,给子结点y空出位置</span></span><br><span class="line">    y-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num;j &gt;= i+<span class="number">1</span>;j --) &#123;</span><br><span class="line">        x-&gt;childrens[j+<span class="number">1</span>] = x-&gt;childrens[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;childrens[i+<span class="number">1</span>] = z;</span><br><span class="line">    <span class="comment">//key值也右移</span></span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num<span class="number">-1</span>;j &gt;= i;j --) &#123;</span><br><span class="line">        x-&gt;keys[j+<span class="number">1</span>] = x-&gt;keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将y移向父节点x</span></span><br><span class="line">    x-&gt;keys[i] = y-&gt;keys[t<span class="number">-1</span>];</span><br><span class="line">    x-&gt;num += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在树T的x结点插入k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert_nonfull</span><span class="params">(btree *T, btree_node *x, KEY_VALUE k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = x-&gt;num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leaf == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) &#123;</span><br><span class="line">            x-&gt;keys[i+<span class="number">1</span>] = x-&gt;keys[i];</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;keys[i+<span class="number">1</span>] = k;</span><br><span class="line">        x-&gt;num += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在非叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) i --;</span><br><span class="line">        <span class="comment">//需要非叶子节点数满，需要裂变</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;childrens[i+<span class="number">1</span>]-&gt;num == (<span class="number">2</span>*(T-&gt;t))<span class="number">-1</span>) &#123;</span><br><span class="line">            btree_split_child(T, x, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; x-&gt;keys[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归插入</span></span><br><span class="line">        btree_insert_nonfull(T, x-&gt;childrens[i+<span class="number">1</span>], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int t = T-&gt;t;</span></span><br><span class="line"></span><br><span class="line">    btree_node *r = T-&gt;root;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;num == <span class="number">2</span> * T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//根结点裂变</span></span><br><span class="line">        <span class="comment">//1.为T创建一个根节点，T变成叶子节点</span></span><br><span class="line">        btree_node *node = btree_create_node(T-&gt;t, <span class="number">0</span>);</span><br><span class="line">        T-&gt;root = node;</span><br><span class="line">        <span class="comment">//2.将T加到根结点第一个位置</span></span><br><span class="line">        node-&gt;childrens[<span class="number">0</span>] = r;</span><br><span class="line">        <span class="comment">//3.将T当作叶子结点裂变</span></span><br><span class="line">        btree_split_child(T, node, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//4.在叶子结点插入新值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;keys[<span class="number">0</span>] &lt; key) i++;</span><br><span class="line">        btree_insert_nonfull(T, node-&gt;childrens[i], key);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接在叶子结点插入新值</span></span><br><span class="line">        btree_insert_nonfull(T, r, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol><li>找到删除节点位置</li><li>归并:把相邻两个节点+父节点的一个值 $\le M$,合二为一再删掉即可<br>当M为5的时候如下图：<br><img src="del1.png" alt="" title="归并删除"></li><li>借值:把相邻两个节点+父节点的一个值 $&gt; M$,将父节点拉下来，将子结点放父位置，再删除即可。<br>当M为5的时候如下图：<br><img src="del2.png" alt="" title="借值删除"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_merge</span><span class="params">(btree *T, btree_node *node, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">    btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////data merge</span></span><br><span class="line">    left-&gt;keys[T-&gt;t<span class="number">-1</span>] = node-&gt;keys[idx];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">        left-&gt;keys[T-&gt;t+i] = right-&gt;keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;leaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t;i ++) &#123;</span><br><span class="line">            left-&gt;childrens[T-&gt;t+i] = right-&gt;childrens[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;num += T-&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destroy right</span></span><br><span class="line">    btree_destroy_node(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node </span></span><br><span class="line">    <span class="keyword">for</span> (i = idx+<span class="number">1</span>;i &lt; node-&gt;num;i ++) &#123;</span><br><span class="line">        node-&gt;keys[i<span class="number">-1</span>] = node-&gt;keys[i];</span><br><span class="line">        node-&gt;childrens[i] = node-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;childrens[i+<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;num -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;root = left;</span><br><span class="line">        btree_destroy_node(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除树T的node节点的key值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_delete_key</span><span class="params">(btree *T, btree_node *node, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx &lt; node-&gt;num &amp;&amp; key &gt; node-&gt;keys[idx]) &#123;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; node-&gt;num &amp;&amp; key == node-&gt;keys[idx]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;leaf) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = idx;i &lt; node-&gt;num<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">                node-&gt;keys[i] = node-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node-&gt;keys[node-&gt;num - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            node-&gt;num--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123; <span class="comment">//root</span></span><br><span class="line">                <span class="built_in">free</span>(node);</span><br><span class="line">                T-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">            node-&gt;keys[idx] = left-&gt;keys[left-&gt;num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, left, left-&gt;keys[left-&gt;num - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx+<span class="number">1</span>]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line">            node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, right, right-&gt;keys[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            btree_merge(T, node, idx);</span><br><span class="line">            btree_delete_key(T, node-&gt;childrens[idx], key);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        btree_node *child = node-&gt;childrens[idx];</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Cannot del key = %d\n"</span>, key);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = <span class="literal">NULL</span>;</span><br><span class="line">            btree_node *right = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                left = node-&gt;childrens[idx<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (idx + <span class="number">1</span> &lt;= node-&gt;num) </span><br><span class="line">                right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((left &amp;&amp; left-&gt;num &gt;= T-&gt;t) ||</span><br><span class="line">                (right &amp;&amp; right-&gt;num &gt;= T-&gt;t)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> richR = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (right) richR = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; right) richR = (right-&gt;num &gt; left-&gt;num) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right &amp;&amp; right-&gt;num &gt;= T-&gt;t &amp;&amp; richR) &#123; <span class="comment">//borrow from next</span></span><br><span class="line">                    child-&gt;keys[child-&gt;num] = node-&gt;keys[idx];</span><br><span class="line">                    child-&gt;childrens[child-&gt;num+<span class="number">1</span>] = right-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; right-&gt;num - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">                        right-&gt;keys[i] = right-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">                        right-&gt;childrens[i] = right-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    right-&gt;keys[right-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    right-&gt;childrens[right-&gt;num<span class="number">-1</span>] = right-&gt;childrens[right-&gt;num];</span><br><span class="line">                    right-&gt;childrens[right-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    right-&gt;num --;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//borrow from prev</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (i = child-&gt;num;i &gt; <span class="number">0</span>;i --) &#123;</span><br><span class="line">                        child-&gt;keys[i] = child-&gt;keys[i<span class="number">-1</span>];</span><br><span class="line">                        child-&gt;childrens[i+<span class="number">1</span>] = child-&gt;childrens[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    child-&gt;childrens[<span class="number">1</span>] = child-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;childrens[<span class="number">0</span>] = left-&gt;childrens[left-&gt;num];</span><br><span class="line">                    child-&gt;keys[<span class="number">0</span>] = node-&gt;keys[idx<span class="number">-1</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    left-&gt;keys[left-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    left-&gt;childrens[left-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    left-&gt;num --;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!left || (left-&gt;num == T-&gt;t - <span class="number">1</span>))</span><br><span class="line">                &amp;&amp; (!right || (right-&gt;num == T-&gt;t - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; left-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx<span class="number">-1</span>);</span><br><span class="line">                    child = left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &amp;&amp; right-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btree_delete_key(T, child, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">btree_delete</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//调递归删除接口</span></span><br><span class="line">    btree_delete_key(T, T-&gt;root, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>首先简单说明一下B+树：<strong>B+树通常用于数据库和操作系统的文件系统中</strong>。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反，<strong>B+树只在叶子结点存储数据，其他结点只保存索引</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:<br>(1)每个结点至多有m个子女；<br>(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；<br>(3)有k个子女的结点必有k个关键字。<br>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。 </p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。 </li><li>如果没有节点处于违规状态则处理结束。 </li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。 </li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。 </li><li>如果没有节点处于违规状态则处理结束。 </li><li>如果节点处于违规状态则有两种可能情况： <ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。 </li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h2 id="B-树与B-树比较"><a href="#B-树与B-树比较" class="headerlink" title="B+树与B-树比较"></a>B+树与B-树比较</h2><blockquote><p>B+树的优势：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>B+树的劣势：<br>1.单点查询，B-树有可能O(1),而B+树永远是B-树的最糟糕情况O(log n).</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><div style=color:red>注意</div></h2><p>这也导致在通用sql数据库中B+树更合适<br>而在mongoDb中，B-树更合适，因为对范围查找要求较低</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B-树&quot;&gt;&lt;/a&gt;B-树&lt;/h2&gt;&lt;p&gt;B树又写做B-树，做索引的时候，hash ，红黑树效率已经很高了，什么时候要用到B树？&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="B树" scheme="https://icevil.cn/tags/B%E6%A0%91/"/>
    
      <category term="B-树" scheme="https://icevil.cn/tags/B-%E6%A0%91/"/>
    
      <category term="B+树" scheme="https://icevil.cn/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从二叉树到红黑树</title>
    <link href="https://icevil.cn/2020/01/28/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://icevil.cn/2020/01/28/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-01-28T03:05:00.000Z</published>
    <updated>2020-02-29T03:09:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>树有很多种，二叉树，多叉树(B-树，B+树)等，本文主要针对几种较为常用的树，做精要记录，梳理逻辑便于长时间之后的理解与记忆。</p><a id="more"></a><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（<code>left subtree</code>）和“右子树”（<code>right subtree</code>）。二叉树常被用于实现二叉查找树和二叉堆。</p><h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>由二叉树的定义，以及图中所示的二叉树的分析可以得出二叉树具有以下几个特点：</p><ol><li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<h3 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h3>除数据域外，主要区别体现形式是左右子树的表示不同</li><li>链式存储<br>用数组表示二叉树，左右子树用数组下标表示<ul><li>优点：查找速度更快</li><li>缺点：不为<code>满二叉树</code>时，浪费了空间，扩展性差或者说插入新数据慢。</li></ul></li><li>链表存储<br>用链表表示二叉树，左右子树用结点指针表示<ul><li>优点：无空间浪费，扩展性好，插入数据快。</li><li>缺点：查找速度略慢。</li></ul></li></ol><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>记住一句话即可。</p><blockquote><p>所有叶子结点都在最下层</p></blockquote><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的 <strong><code>满二叉树</code></strong> 中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><blockquote><p>所有叶子结点都在最下层与次下层</p></blockquote><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>左右子树的高度相差不超过1的树为平衡二叉树，也叫AVL树。<br>注意点：<strong>实现了树的自平衡以提升树的查找效率</strong><br>如何做到自平衡的：<br><img src="rotate.png" alt="" title="自平衡操作"></p><ol><li>左旋<blockquote><p>1.结点的右孩子替代此结点位置<br>2.右孩子的左子树变为该结点的右子树<br>3.结点本身变为右孩子的左子树</p></blockquote></li><li>右旋<blockquote><p>1.结点的左孩子代表此结点<br>2.结点的左孩子的右子树变为结点的左子树<br>3.将此结点作为左孩子结点的右子树</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//y是x的右子结点</span></span><br><span class="line">    rbtree_node *y = x-&gt;right;  <span class="comment">// x  --&gt; y  ,  y --&gt; x,   right --&gt; left,  left --&gt; right</span></span><br><span class="line"></span><br><span class="line">    x-&gt;right = y-&gt;left; <span class="comment">//1 1</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123; <span class="comment">//1 2</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent = x-&gt;parent; <span class="comment">//1 3</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == T-&gt;nil) &#123; <span class="comment">//1 4</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x; <span class="comment">//1 5</span></span><br><span class="line">    x-&gt;parent = y; <span class="comment">//1 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T, rbtree_node *y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//x为y的左子结点</span></span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>红黑树是一种非常重要且应用广泛的数据结构。它是在AVL树的基础上加以改进优化得出的一个高效算法。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：<strong>它可以在O(log n)时间内做查找，插入和删除</strong>。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3></li></ol><ul><li>Linux进程调度CFS</li><li>Nginx Timer事件管理</li><li>Epoll事件块的管理</li><li>STL中set, multiset, map, multimap的实现<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3></li></ul><ol><li>结点是红色或黑色</li><li>根结点是黑色</li><li>每个叶子结点(nil)是黑色</li><li>每个红色结点的两个子结点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色结点)</li><li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</strong><br>从性质5可以知道：如果一个结点存在黑子结点，那么该结点肯定有两个子结点<br>下图Nil为叶子结点，并且它的颜色一定是黑色的。<br><img src="2392382-4996bbfb4017a3b2.png" alt="一颗简单的红黑树" title="一颗简单的红黑树"><br>由图可见，红黑树并不是一个<code>完美平衡二叉查找树</code>,根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<code>黑高平衡</code>。<br>为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如下图<br><img src="2392382-abedf3ecc733ccd5.webp" alt="结点的叫法" title="结点的叫法"></li></ol><h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。从根结点开始查找；</p><blockquote><p>若根结点为空，那么插入结点作为根结点，结束。<br>若根结点不为空，那么把根结点作为当前结点；<br>若当前结点为null，返回当前结点的父结点，结束。<br>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。<br>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；<br>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p></blockquote><p><img src="2392382-7521866b50683a24.webp" alt="数据插入" title="数据插入"></p><p>插入完成后，但插入结点是应该设置成什么颜色呢？<br>答案是<strong>红色</strong>。<em>因为红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡</em>。</p><p><img src="2392382-fa2b78271263d2c8.webp" alt="插入操作脑图" title="插入操作脑图"></p><h3 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h3><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。<br>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡，最后调色。<br>二叉树删除结点找替代结点有3种情情景：</p><p>情景1：若删除结点无子结点，直接删除<br>情景2：若删除结点只有一个子结点，用子结点替换删除结点<br>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图所示。<br><img src="2392382-edaf96e55f08c198.webp" alt="插入操作脑图" title="插入操作脑图"></p><h3 id="红黑树插入删除代码："><a href="#红黑树插入删除代码：" class="headerlink" title="红黑树插入删除代码："></a>红黑树插入删除代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; <span class="comment">//z ---&gt; RED</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right;<span class="comment">//y是z的叔父结点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_left_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_right_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_left_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != T-&gt;nil) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//Exist</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    rbtree_insert_fixup(T, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_delete_fixup</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((x != T-&gt;root) &amp;&amp; (x-&gt;color == BLACK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">         <span class="comment">//w是x的叔父结点   </span></span><br><span class="line">            rbtree_node *w= x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_right_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            rbtree_node *w = x-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_left_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rbtree_node *<span class="title">rbtree_delete</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == T-&gt;nil) || (z-&gt;right == T-&gt;nil)) &#123;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = rbtree_successor(T, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left) &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) &#123;</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line">        z-&gt;value = y-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;color == BLACK) &#123;</span><br><span class="line">        rbtree_delete_fixup(T, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"><a href="#我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解" class="headerlink" title="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"></a>我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解</h3><p><span style=color:red><strong>红黑树有着目前算法中内存读写综合性能最好的数据结构</strong></span>代码要求：不要求能盲打，但是最好能对照定义敲出。另外红黑树的算法论证见算法导论。</p><ol><li>查询速度仅次于hash，但是比hash省空间，几乎等于AVL树</li><li>搜索稳定性能最佳，算法耗时稳定<code>O(long n)</code>（不会出现最长搜索时间，最短搜索时间）</li><li>伸缩性好，写操作也能很快</li><li>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较</li><li>红黑树在插入和删除上优于avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">红黑树图片引用原文链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树有很多种，二叉树，多叉树(B-树，B+树)等，本文主要针对几种较为常用的树，做精要记录，梳理逻辑便于长时间之后的理解与记忆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="tree" scheme="https://icevil.cn/tags/tree/"/>
    
      <category term="rbtree" scheme="https://icevil.cn/tags/rbtree/"/>
    
      <category term="红黑树" scheme="https://icevil.cn/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://icevil.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>几种经典排序算法</title>
    <link href="https://icevil.cn/2020/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://icevil.cn/2020/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-25T01:05:23.000Z</published>
    <updated>2020-02-28T09:32:40.666Z</updated>
    
    <content type="html"><![CDATA[<p>几种常见排序算法比较<br>排序算法有很多，下面统计几种经典排序算法并做比较。</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>个人认为是最简单的排序方式，越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><blockquote><p>每次循环都是为了去找未排序数组中最小的那个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])   <span class="comment">//后者比前者小就交换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = data[i];</span><br><span class="line">                data[i] = data[j];</span><br><span class="line">                data[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由<code>C. A. R. Hoare</code>在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。这和分治思想非常相似。</p><blockquote><p>对数组A[N]快速排序的算法是:</p><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1;</li><li>以第一个数组元素作为关键数据，赋值给key;</li><li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换; </li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换; </li><li>重复第3、4步，直到i=j。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = data[left];   <span class="comment">//找到关键数。这里以第一个为准</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0   </span></span><br><span class="line">    <span class="comment">/*这段代码比下面那段代码更精简，但是下面那段代码更易理解</span></span><br><span class="line"><span class="comment">    while (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">        //1.比key大的放右边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span></span><br><span class="line"><span class="comment">            j --;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[i] = data[j];</span></span><br><span class="line"><span class="comment">        //2.比key小的放左边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span></span><br><span class="line"><span class="comment">            i ++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[j] = data[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    data[i] = key;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//1.比key大的放右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = key;      </span><br><span class="line">        <span class="comment">//2.比key小的放左边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = data[i];</span><br><span class="line">        data[i] = key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    sort(data, left, i - <span class="number">1</span>);</span><br><span class="line">    sort(data, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    sort(data, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,算法适用于少量数据的排序。</p><blockquote><p>从第2个数开始，依次与前面的数比较。<br>如果比前面的数大，不用移动<br>如果比前面的数小，前面的数依次后移，直至出现不小于该值的数，或者位置已以至最前面。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历查找插入位置j</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos&gt;= <span class="number">1</span> &amp;&amp; tmpData &lt; data[pos<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                data[pos] = data[pos<span class="number">-1</span>];</span><br><span class="line">                pos--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[pos] = tmpData;<span class="comment">//找到插入位置，赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>基于插入排序的优化，类似的还有二分查找算法也叫折半查找算法。</p><blockquote><p>在直接插入排序的思维下，加快查找插入位置pos。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，返回该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_insert</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">int</span>* data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)   <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> npos = (left + right) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, left, npos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, npos+<span class="number">1</span>, right);<span class="comment">//注意这里是npos+1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b_insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> npos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            npos = b_insert(tmpData, data, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> n = i;</span><br><span class="line">            <span class="keyword">while</span>( n &gt; npos )</span><br><span class="line">            &#123;</span><br><span class="line">                data[n] = data[n<span class="number">-1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[npos] = tmpData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序法又称缩小增量法，按其设计者希尔（Donald Shell）的名字命名。</p><blockquote><p>先选定一个整数，把待排序文件中所有记录分成2个组，所有距离为 gap = length/2 的记录分在同一组内，并对每一组内的记录进行排序。<br>然后，取重复上述分组和排序的工作。当到达gap=1时，所有记录在同一组内排好序。<br>各组内的排序通常采用直接插入法。由于开始时gap的取值较大，每组内记录数较少，所以排序比较快。<br>随着gap不断减小，每组内的记录数逐步增多，但由于已经按排好序，因此排序速度也比较快</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//外层循环控制增量gap，每次缩减一倍</span></span><br><span class="line">    <span class="keyword">for</span> (gap = length / <span class="number">2</span>;gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对新的数组做 直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap;i &lt; length;i ++) &#123;</span><br><span class="line"></span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i-gap;j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; data[j];j = j - gap) &#123;</span><br><span class="line">                data[j+gap] = data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+gap] = temp;<span class="comment">//将 temp 插入 j+gap 位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（<code>Divide and Conquer</code>）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。</p><blockquote><p>归并操作的工作原理如下：<br>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复上一步直到某一指针超出序列尾,将另一序列剩下的所有元素直接复制到合并序列尾</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start, j = middle+<span class="number">1</span>, k = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start;i &lt;= <span class="built_in">end</span>;i ++) &#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        middle = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        merge_sort(data, temp, start, middle);</span><br><span class="line">        merge_sort(data, temp, middle+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        merge(data, temp, start, middle, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各路算法比较："><a href="#各路算法比较：" class="headerlink" title="各路算法比较："></a>各路算法比较：</h2><p>道不完的算法，最后采个图比较。<br><img src="20200225125447.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种常见排序算法比较&lt;br&gt;排序算法有很多，下面统计几种经典排序算法并做比较。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sort" scheme="https://icevil.cn/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>linux内核编译与升级</title>
    <link href="https://icevil.cn/2020/01/17/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8D%87%E7%BA%A7/"/>
    <id>https://icevil.cn/2020/01/17/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8D%87%E7%BA%A7/</id>
    <published>2020-01-17T06:50:23.000Z</published>
    <updated>2020-02-23T03:08:48.955Z</updated>
    
    <content type="html"><![CDATA[<p>一，Linux内核源码下载</p><p>在<a href="http://www.kernel.org/" target="_blank" rel="noopener">Linux官网</a>下载对应的内核代码<br><img src="20200117143333282.png" alt=""></p><a id="more"></a><p>建议下载文档版本源码，解压到当前目录。</p><p>二、编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.解压</span></span><br><span class="line">xd -d linux_xxx.tar.xd</span><br><span class="line"> </span><br><span class="line">tar -xvf linux_xxx.tar</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.拷贝配置文件到当前目录</span></span><br><span class="line">cp /boot/config-xxx ./.config</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3.编译图型菜单</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="20200117143836562.png" alt=""></p><p> save保存。退出后，即可开始编译内核。建议系统空闲空间在30g以上，因为编译后的系统有十多g。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译内核，j后面的数字是cpu总核心数。这样编译速度更快</span></span><br><span class="line">make -j8</span><br><span class="line"><span class="comment">#编译组件</span></span><br><span class="line">make modules</span><br><span class="line"><span class="comment">#安装组件</span></span><br><span class="line">make modules_install</span><br><span class="line"><span class="comment">#生成镜像3</span></span><br><span class="line">make bzImage</span><br></pre></td></tr></table></figure><p>三、安装内核步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp arch/x86/boot/bzImage /boot/vmlinux-4.xxx</span><br><span class="line">cp .config /boot/config-4.xxx</span><br><span class="line"><span class="built_in">cd</span> /lib/modules/4.xxx/</span><br><span class="line">update-initramfs -c -k 4.xxx</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure><p>四、依赖库安装</p><p>编译过程出现错误，可能需要安装一下库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符端处理库，显示菜单，需要这个依赖</span></span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"><span class="comment">#ssl库</span></span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line"><span class="comment">#bc</span></span><br><span class="line">sudo apt-get install bc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一，Linux内核源码下载&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.kernel.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux官网&lt;/a&gt;下载对应的内核代码&lt;br&gt;&lt;img src=&quot;20200117143333282.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="内核" scheme="https://icevil.cn/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>网络IO模型</title>
    <link href="https://icevil.cn/2020/01/02/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://icevil.cn/2020/01/02/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-01-02T07:38:33.000Z</published>
    <updated>2020-03-03T14:07:45.412Z</updated>
    
    <content type="html"><![CDATA[<p>网络 IO，会涉及到两个系统对象，<span style=color:#ff3366>一个是用户空间调用IO的进程或者线程，另一个是内核空间的内核系统</span>，比如发生 IO 操作 read 时，它会经历两个阶段： </p><ol><li>等待数据准备就绪 </li><li>将数据从内核拷贝到进程或者线程中。</li></ol><p>因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型 。本文主要介绍五种网络IO模型</p><a id="more"></a><h2 id="阻塞IO-blocking-io"><a href="#阻塞IO-blocking-io" class="headerlink" title="阻塞IO(blocking io)"></a>阻塞IO(blocking io)</h2><p>在 linux 中，默认情况下所有的 socket 都是 blocking，一个典型的读操作流程<br><img src="blocking.png" alt="" title="blocking io"><br>当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于 <code>network io</code> 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包）， 这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果， 用户进程才解除 block 的状态，重新运行起来。<br>所以，<span style=color:#ff3366>blocking IO 的特点就是在 IO 执行的两个阶段（等待数据和拷贝数据两个阶段）都被 block 了</span>。<br>一般程序员接触到的网络编程都是从 <code>listen()</code>、<code>send()</code>、<code>recv()</code> 等接口开始的， 这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一 个简单地“一问一答”的服务器。<br><img src="block.png" alt="" title="一问一答服务器"><br>大部分的 <code>socket</code> 接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是 IO 接口） 不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返 回。 实际上，除非特别指定，几乎所有的 IO 接口 ( 包括 <code>socket</code> 接口 ) 都是阻塞型的。这给 网络编程带来了一个很大的问题，如在调用 <code>send()</code>的同时，线程将被阻塞，在此期间，线程 将无法执行任何运算或响应任何的网络请求。 一个简单的改进方案是在服务器端使用多线程（或多进程）。<span style=color:#ff3366><strong>多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接</strong></span>。具体使用多进程还是多进程，并没有一个特定的模式。</p><blockquote><p>多线程还是多进程的选择：<br>传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问， 则进程较为安全。通常，使用 <code>pthread_create ()</code>创建新线程，<code>fork()</code>创建新进程。 </p></blockquote><p>我们让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型<br><img src="multiThreadsvr.png" alt=""></p><center>多线程服务器模型</center><blockquote><p>在上述的<code>线程/时间</code>图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。 很多初学者可能不明白为何一个 socket 可以 accept 多次。实际上 socket 的设计者 可能特意为多客户机的情况留下了伏笔，让 accept()能够返回一个新的 socket。下面是 accept 接口的原型：<code>int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</code><br> 输入参数 s 是从 <code>socket()</code>，<code>bind()</code>和 <code>listen()</code>中沿用下来的 socket 句柄。执行完 <code>bind()</code>和 <code>listen()</code>后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用 <code>accept()</code>接口正是从 <code>socket s</code> 的请求队列抽 取第一个连接信息，创建一个与 <code>s</code> 同类的新的 <code>socket</code> 返回句柄。新的 <code>socket</code> 句柄即是后 续 <code>read()</code>和 <code>recv()</code>的输入参数。如果请求队列当前没有请求，则 <code>accept()</code> 将进入阻塞 状态直到有请求进入队列。</p></blockquote><p> <strong>上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实 并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据 系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</strong> </p><p> 很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在<span style=color:#ff3366>减少创建和销毁线程的频率</span>，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接,<span style=color:#ff3366>减少创建和关闭连接的频率</span>。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如 <code>websphere</code>、<code>tomcat</code> 和各种<code>数据库</code>等。 但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用 <code>IO</code> 接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p><p>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。<strong>总之，多线程模型可以方便高效的 解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p><h2 id="非阻塞-IO（non-blocking-IO）"><a href="#非阻塞-IO（non-blocking-IO）" class="headerlink" title="非阻塞 IO（non-blocking IO）"></a>非阻塞 IO（non-blocking IO）</h2><p>Linux 下，可以通过设置 <code>socket</code> 使其变为 <code>non-blocking</code>。当对一个 <code>non-blocking socket</code> 执行读 操作时，流程是这个样子:<br><img src="non-blockingio.png" alt=""></p><center>非阻塞 IO</center><blockquote><p>从图中可以看出，当用户进程发出 read 操作时，如果 <code>kernel</code> 中的数据还没有准备好，那 么它并不会 <code>block</code> 用户进程，而是立刻返回一个 <code>error</code>。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 <code>error</code> 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 <code>kernel</code> 中的数据 准备好了，并且又再次收到了用户进程的 <code>system call</code>，那么它马上就将数据拷贝到了用 户内存，然后返回，所以，在<code>非阻塞式 IO</code> 中，用户进程其实是需要不断的主动询问 <code>kernel</code> 数据准备好了没有。 在非阻塞状态下，<code>recv()</code> 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中， </p></blockquote><ul><li>recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数； </li><li>recv() 返回 0，表示连接已经正常断开； </li><li>recv() 返回 -1，且 <code>errno</code> 等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作还没执行完成； </li><li>recv() 返回 -1，且 <code>errno</code> 不等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作遇到系统错误 <code>errno</code>。</li></ul><p><strong>非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。</strong>使用如下 的函数可以将某句柄 <code>fd</code> 设为非阻塞状态。<br><code>fcntl( fd, F_SETFL, O_NONBLOCK );</code><br>下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。<br><img src="non-blocking-single.png" alt=""></p><center>使用非阻塞io的单线程服务器</center><blockquote><p>可以看到服务器线程可以通过循环调用 <code>recv()</code>接口，可以在单个线程内实现对所有连 接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用 <code>recv()</code>将大幅度推高 CPU 占用率；此外，在这个方案中 <code>recv()</code>更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如 <code>select()多路复用模式</code>， 可以一次检测多个连接是否活跃。 </p></blockquote><h2 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h2><p><code>IO multiplexing</code> 这个词可能有点陌生，但是提到 <code>select/epoll</code>，大概就都能明白了。有些地方 也称这种 <code>IO</code> 方式为事件驱动 <code>IO</code>(<code>event driven IO</code>)。我们都知道，<code>select/epoll</code> 的好处就在于单个 <code>process</code> 就可以同时处理多个网络连接的 IO。它的基本原理就是 <code>select/epoll</code> 这个 <code>function</code> 会不断的轮询所负责的所有 <code>socket</code>，当某个 <code>socket</code> 有数据到达了，就通知用户进程。它的流程如图：<br><img src="io-multiplexing.png" alt=""></p><center>IO多路复用</center><blockquote><p>当用户进程调用了 <code>select</code>，那么整个进程会被 <code>block</code>，而同时，<code>kernel</code> 会“监视”所有 <code>select</code> 负责的 <code>socket</code>，当任何一个 <code>socket</code> 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从 <code>kernel</code> 拷贝到用户进程。 这个图和 <code>blocking IO</code> 的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(<code>select</code> 和 <code>read</code>)，而 <code>blocking IO</code> 只调用了一个系统调用(<code>read</code>)。 但是使用 <code>select</code> 以后最大的优势是用户可以在一个线程内同时处理多个 <code>socket</code> 的 <code>IO 请求</code>。用户可以注册多个 <code>socket</code>，然后不断地调用 <code>select</code> 读取被激活的 <code>socket</code>，即可达到 在同一个线程内同时处理多个 <code>IO</code> 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。（多说一句：所以，如果处理的连接数不是很高的话，使用 <code>select/epoll</code> 的 <code>web server</code> 不一定比使用 <code>multi-threading</code> + <code>blocking IO</code> 的 <code>web server</code> 性能更好，可能延迟还更大。<code>select/epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在多路复用模型中，对于每一个 <code>socket</code>，一般都设置成为 <code>non-blocking</code>，但是，上图所示，整个用户的 <code>process</code> 其实是一直被 <code>block</code> 的。只不过 <code>process</code> 是被 <code>select</code> 这 个函数 <code>block</code>，而不是被 <code>socket IO</code> 给 <code>block</code>。因此 <code>select()</code>与<code>非阻塞IO</code> 类似。<br>大部分 Unix/Linux 都支持 select 函数，该函数用于探测多个文件句柄的状态变化。 下面给出 select 接口的原型：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fds)     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds</span></span></span><br><span class="line"><span class="function"><span class="params">    , fd_set *exceptfds, struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><p>这里，<code>fd_set</code> 类型可以简单的理解为按 <code>bit</code> 位标记句柄的队列，例如要在某 <code>fd_set</code> 中标记一个值为 16 的句柄，则该 <code>fd_set</code> 的第 16 个 bit 位被标记为 1。具体的置位、验证 可使用 <code>FD_SET</code>、<code>FD_ISSET</code> 等宏实现。在 <code>select()</code>函数中，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 同时作为输入参数和输出参数。如果输入的 <code>readfds</code> 标记了 16 号句柄，则 <code>select()</code>将检测 16 号句柄是否可读。在 <code>select()</code>返回后，可以通过检查 <code>readfds</code> 有否标 记 16 号句柄，来判断该“可读”事件是否发生。另外，用户可以设置 <code>timeout</code> 时间。 下面将重新模拟上例中从多个客户端接收数据的模型。<br><img src="select.png" alt=""></p><center>select 模型</center><blockquote><p>上述模型只是描述了使用 <code>select()</code>接口同时从多个客户端接收数据的过程；由于 <code>select()</code> 接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个客户端提供独立问答服务的服务器系统。 </p></blockquote><p><img src="select-event.png" alt=""></p><center>基于事件驱动的select模型</center><blockquote><p>这里需要指出的是，客户端的一个 <code>connect()</code> 操作，将在服务器端激发一个“可读事件”，所以 <code>select()</code> 也能探测来自客户端的 <code>connect()</code> 行为。 </p></blockquote><p>上述模型中，最关键的地方是如何动态维护 <code>select()</code>的三个参数 <code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>。作为输入参数，<code>readfds</code> 应该标记所有的需要探测的“可读事件”的句柄， 其中永远包括那个探测 <code>connect()</code> 的那个“母”句柄；同时，<code>writefds</code> 和 <code>exceptfds</code> 应 该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 <code>FD_SET()</code> 标记 )。 作为输出参数，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 中的保存了 <code>select()</code> 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用 <code>FD_ISSET()</code>检查 )，以确定到底哪些句柄发生了事件。</p><p>上述模型主要模拟的是“一问一答”的服务流程，所以如果 <code>select()</code>发现某句柄捕捉到了“可读事件”，服务器程序应及时做<code>recv()</code>操作，并根据接收到的数据准备好待发送数据， 并将对应的句柄值加入 <code>writefds</code>，准备下一次的“可写事件”的 <code>select()</code>探测。同样，如果 <code>select()</code>发现某句柄捕捉到“可写事件”，则程序应及时做 <code>send()</code>操作，并准备好下一 次的“可读事件”探测准备。<br><strong>这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发 某个特定的响应。我们可以将这种模型归类为“事件驱动模型”。</strong><br>相比其他模型，使用 <code>select()</code> 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。 </p><p>但这个模型依旧有着很多问题。</p><ol><li>首先 <code>select()</code>接口并不是实现“事件驱动”的最好选择。 因为当需要探测的句柄值较大时，<code>select()</code>接口本身需要消耗大量时间去轮询各个句柄。 很多操作系统提供了更为高效的接口，如<code>linux</code>提供了<code>epoll</code>，<code>BSD</code>提供了<code>kqueue</code>，<code>Solaris</code> 提供了<code>/dev/poll</code>，…。如果需要实现更高效的服务器程序，类似 epoll 这样的接口更被推 荐。遗憾的是不同的操作系统特供的 epoll 接口有很大差异，所以使用类似于 epoll 的接 口实现具有较好跨平台能力的服务器会比较困难。 </li><li>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整 个模型是灾难性的。如，庞大的执行体 1 将直接导致响应事件 2 的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。 </li></ol><p>幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有 <code>libevent</code> 库，还有作为 <code>libevent</code> 替代者的 <code>libev</code> 库。这些库会根据操作系统的特点选择 最合适的事件探测接口，并且加入了信号(<code>signal</code>) 等技术以支持异步响应，这使得这些库成为构建事件驱动模型的不二选择。下章将介绍如何使用 <code>libev</code> 库替换 <code>select</code> 或 <code>epoll</code> 接口，实现高效稳定的服务器模型。<br>实际上，<code>Linux</code> 内核从 2.6 开始，也引入了支持异步响应的 IO 操作，如 <code>aio_read</code>, <code>aio_write</code>，这就是异步IO。</p><h2 id="异步IO（Asynchronous-I-O）"><a href="#异步IO（Asynchronous-I-O）" class="headerlink" title="异步IO（Asynchronous I/O）"></a>异步IO（Asynchronous I/O）</h2><p>Linux 下的 asynchronous IO 用在磁盘 IO 读写操作，不用于网络 IO，从内核 2.6 版本才开始引 入。先看一下它的流程<br><img src="asynchrIO.png" alt=""></p><center>异步IO</center><blockquote><p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 <code>kernel</code> 的角度，当它受到一个 <code>asynchronous read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何 <code>block</code>。然后，<code>kernel</code> 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 <code>signal</code>，告诉它 <code>read</code> 操作完成了。 </p></blockquote><p><strong>异步 IO 是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。</strong></p><p>到目前为止，已经将四个 IO 模型都介绍完了。<font size=4>现在回过头来回答最初的两个问题： <code>blocking</code> 和 <code>non-blocking</code> 的区别在哪?<code>synchronous IO</code> 和 <code>asynchronous IO</code> 的区别在哪?</font></p><blockquote><p>先回答最简单的这个：<code>blocking</code> 与 <code>non-blocking</code>。前面的介绍中其实已经很明确的 说明了这两者的区别。调用 <code>blocking IO</code> 会一直 <code>block</code> 住对应的进程直到操作完成，而 <code>non-blocking IO</code> 在 <code>kernel</code> 还在准备数据的情况下会立刻返回。<br>两者的区别就在于 <code>synchronous IO</code> 做<font color=red>“IO operation”</font>的时候会将 <code>process</code> 阻塞。 按照这个定义，之前所述的 <code>blocking IO</code>，<code>non-blocking IO</code>，<code>IO multiplexing</code> 都属于 <code>synchronous IO</code>。有人可能会说，<code>non-blocking IO</code>并没有被 <code>block</code> 啊。这里有个非常 “狡猾”的地方，<font color=red>定义中所指的”IO operation”是指真实的 IO 操作，就是例子中的 read 这个系统调用。</font><code>non-blocking IO</code> 在执行 <code>read</code> 这个系统调用的时候，如果 <code>kernel</code> 的数据没有准备好，这时候不会 <code>block</code> 进程。但是当 <code>kernel</code> 中数据准备好的时候，<code>read</code> 会将数据 从 <code>kernel</code> 拷贝到用户内存中，这个时候进程是被 <code>block</code> 了，在这段时间内进程是被 <code>block</code> 的。而 <code>asynchronous IO</code> 则不一样，当进程发起 IO 操作之后，就直接返回再也不理睬了， 直到<code>kernel</code>发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被<code>block</code>。</p></blockquote><h2 id="信号驱动IO（signal-driven-I-O，-SIGIO）"><a href="#信号驱动IO（signal-driven-I-O，-SIGIO）" class="headerlink" title="信号驱动IO（signal driven I/O， SIGIO）"></a>信号驱动IO（signal driven I/O， SIGIO）</h2><p>首先我们允许套接口进行信号驱动 I/O,并安装一个信号处理函数，进程继续运行并不阻 塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函 数处理数据。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后既可 以在信号处理函数中调用 read 读取数据报，并通知主循环数据已准备好待处理，也可以立 即通知主循环，让它来读取数据报。无论如何处理 SIGIO 信号，这种模型的优势在于等待数 据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了 select 的阻塞与轮询，当 有活跃套接字时，由注册的 handler 处理。<br><img src="singalIO.png" alt=""></p><center>信号驱动IO</center><blockquote><p>经过上面的介绍，会发现 <code>non-blocking IO</code> 和 <code>asynchronous IO</code> 的区别还是很明显的。在 <code>non-blocking IO</code> 中，虽然进程大部分时间都不会被 <code>block</code>，但是它仍然要求进程去主动的 <code>check，</code> 并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而 <code>asynchronous IO</code> 则完全不同。它就像是用户进程将整个 <code>IO</code> 操作交给了他人（<code>kernel</code>）完 成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 IO 操作的状态，也不需要主动的去拷贝数据.</p></blockquote><h2 id="服务器模型-Reactor-与-Proactor"><a href="#服务器模型-Reactor-与-Proactor" class="headerlink" title="服务器模型 Reactor 与 Proactor"></a>服务器模型 Reactor 与 Proactor</h2><p>对高并发编程，网络连接上的消息处理，可以分为两个阶段：等待消息准备、消息处理。当使用默认的阻塞套接字时（例如上面提到的 1 个线程捆绑处理 1 个连接），往往是把 这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了高并发下线程会频繁的睡眠、唤醒，从而影响了 CPU 的使用效率。<br>高并发编程方法当然就是把两个阶段分开处理。即，等待消息准备好的代码段，与处理消息的代码段是分离的。当然，这也要求套接字必须是非阻塞的，否则，处理消息的代码段 很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。那么问题来了，<strong>等待消息准备好这个阶段怎么实现？</strong>它毕竟还是等待，这意味着线程还是要睡眠的！解决办法就是，线程主动查询，或者让 1 个线程为所有连接而等待！这就是 IO 多路复用了。多路复用就是处理 等待消息准备好这件事的，但它可以同时处理多个连接！它也可能“等待”，所以它也会导致 线程睡眠，然而这不要紧，因为它一对多、它可以监控所有连接。这样，当我们的线程被唤醒执行时，就一定是有一些连接准备好被我们的代码执行了。<br>作为一个高性能服务器程序通常需要考虑处理三类事件： <strong>I/O 事件，定时事件及信号</strong>。 下面介绍两种高效的事件处理模型：Reactor 和 Proactor。</p><h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><p>首先来回想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将 结果和控制权返回给程序，程序继续处理。Reactor 释义“反应堆”，是一种事件驱动机制。 和普通函数调用的不同之处在于：应用程序不是主动的调用某个 API 完成处理，而是恰恰相反，Reactor 逆置了事件处理流程，<font color=red>应用程序需要提供相应的接口并注册到 Reactor 上， 如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</font><br><img src="reactor-class.png" alt=""></p><center>reactor模式uml图</center>Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，中心思想是将所有要处理的 I/O 事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上； 一旦有 I/O 事件到来或是准备就绪(文件描述符或 socket 可读、写)，多路复用器返回并将事 先注册的相应 I/O 事件分发到对应的处理器中。 <p><strong>Reactor 模型有三个重要的组件：</strong> </p><ul><li>多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。 </li><li>事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。 </li><li>事件处理器：负责处理特定事件的处理函数。 </li></ul><p><img src="reactor.png" alt=""></p><center>reactor模式时序图</center><p>具体流程如下： </p><ol><li>注册读就绪事件和相应的事件处理器；  </li><li>事件分离器等待事件； </li><li>事件到来，激活分离器，分离器调用事件对应的处理器； </li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><p>Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点： </p><ul><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的； </li><li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进 程的切换开销；</li><li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源； </li><li>可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；</li></ul><p>Reactor 模型开发效率上比起直接使用 IO 复用要高，它通常是单线程的，设计目标是希望单线程使用一颗 CPU 的全部资源，但也有附带优点，即每个事件处理中很多时候可以不考虑共享资源的互斥访问。可是缺点也是明显的，现在的硬件发展，已经不再遵循摩尔定律，CPU 的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，当程序需要使用多核资源时，Reactor 模型就会悲剧, 为什么呢？<br>如果程序业务很简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开启多个反应堆，每个反应堆对应一颗 CPU 核心，这些反应堆上跑的请求互不相关，这是完全可以利用多核的。例如: Nginx 这样的 http 静态服务器。 </p><h3 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h3><p><img src="proactor_uml.jpg" alt=""></p><center>proactor模式uml图</center><p><img src="proactor_flow.png" alt=""></p><center>proactor模式时序图</center><p><code>Proactor</code>译作“前摄器模式”是设计模式中重要的一种，具体流程如下： </p><ol><li>处理器发起异步操作，并关注 I/O 完成事件 </li><li>事件分离器等待操作完成事件 </li><li>分离器等待过程中，内核并行执行实际的 I/O 操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成 </li><li>I/O 完成后，通过事件分离器呼唤处理器 </li><li>事件处理器处理用户自定义缓冲区中的数据 </li></ol><p>从上面的处理流程，我们可以发现 <code>proactor</code> 模型最大的特点就是 <code>Proactor</code> 最大的特点是使用异步 I/O。所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操 作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。       </p><blockquote><p><code>Proactor</code> 增加了编程的复杂度，但给工作线程带来了更高的效率。<code>Proactor</code> 可以在 系统态将读写优化，利用 I/O 并行能力，提供一个高性能单线程模型。在 <code>windows</code> 上， 由于没有 <code>epoll</code> 这样的机制，因此提供了 <code>IOCP</code> 来支持高并发， 由于操作系统做了较好的优化，<code>windows</code> 较常采用 <code>Proactor</code> 的模型利用完成端口来实现服务器。在 <code>linux</code> 上，在 2.6 内核出现了 <code>aio</code> 接口，但 <code>aio</code> 实际效果并不理想，它的出现，主要是解决 <code>poll</code> 性能不佳的问题，但实际上经过测试，<code>epoll</code> 的性能高于 <code>poll+aio</code>，并且 <code>aio</code> 不能处理 <code>accept</code>， 因此 linux 主要还是以 <code>Reactor</code> 模型为主。</p></blockquote><p>在不使用操作系统提供的异步 I/O 接口的情况下，还可以使用 <code>Reactor</code> 来模拟 <code>Proactor</code>， 差别是：使用异步接口可以利用系统提供的读写并行能力，而在模拟的情况下，这需要在用户态实现。具体的做法如下： </p><ol><li>注册读事件（同时再提供一段缓冲区） </li><li>事件分离器等待可读事件 </li><li>事件到来，激活分离器，分离器（立即读数据，写缓冲区）调用事件处理器 </li><li>事件处理器处理数据，删除事件(需要再用异步接口注册)            </li></ol><p>我们知道，<code>Boost.asio</code> 库采用的即为 <code>Proactor</code> 模型。不过 <code>Boost.asio</code> 库在 <code>Linux</code> 平台采用 <code>epoll</code> 实现的 <code>Reactor</code> 来模拟 <code>Proactor</code>，并且另外开了一个线程来完成读写调度。 </p><h3 id="同步-I-O-模拟-Proactor-模型"><a href="#同步-I-O-模拟-Proactor-模型" class="headerlink" title="同步 I/O 模拟 Proactor 模型"></a>同步 I/O 模拟 Proactor 模型</h3><p><img src="11.png" alt=""></p><center>proactor模式流程图</center><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 </li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。 </li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据， 直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后 往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。 </li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户 请求的结果。 </li></ol><p>两个模式的相同点，<font color=red>都是对某个 IO 事件的事件通知(即告诉某个模块，这个 IO 操作可以进行或已经完成)。在结构上两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、 查询设备是否可操作(同步)，然后当条件满足时，就回调注册处理函数。</font> </p><p>不同点在于，<font color=red>异步情况下(Proactor)，当回调注册的处理函数时，表示 IO 操作已经完成；同步情况下(Reactor)，回调注册的处理函数时，表示 IO 设备可以进行某个操作(can read or can write)，注册的处理函数这个时候开始提交操作。 </font></p><p><strong>本文参考链接</strong></p><p>本文reactor/proactor盗图自<a href="https://tech.youzan.com/yi-bu-wang-luo-mo-xing/" target="_blank" rel="noopener">xieshuang-异步网络模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络 IO，会涉及到两个系统对象，&lt;span style=color:#ff3366&gt;一个是用户空间调用IO的进程或者线程，另一个是内核空间的内核系统&lt;/span&gt;，比如发生 IO 操作 read 时，它会经历两个阶段： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待数据准备就绪 &lt;/li&gt;
&lt;li&gt;将数据从内核拷贝到进程或者线程中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型 。本文主要介绍五种网络IO模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="https://icevil.cn/tags/c-c/"/>
    
      <category term="socket" scheme="https://icevil.cn/tags/socket/"/>
    
      <category term="io" scheme="https://icevil.cn/tags/io/"/>
    
      <category term="select" scheme="https://icevil.cn/tags/select/"/>
    
      <category term="poll" scheme="https://icevil.cn/tags/poll/"/>
    
      <category term="epoll" scheme="https://icevil.cn/tags/epoll/"/>
    
      <category term="iocp" scheme="https://icevil.cn/tags/iocp/"/>
    
      <category term="network" scheme="https://icevil.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>表达式计算</title>
    <link href="https://icevil.cn/2019/12/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>https://icevil.cn/2019/12/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</id>
    <published>2019-12-24T01:05:23.000Z</published>
    <updated>2020-02-24T02:47:26.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题：计算数学表达式-color-green-1-2-times-3-5-2"><a href="#题：计算数学表达式-color-green-1-2-times-3-5-2" class="headerlink" title="题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$"></a>题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$</h2><a id="more"></a><h2 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h2><h3 id="我们先了解两个概念"><a href="#我们先了解两个概念" class="headerlink" title="我们先了解两个概念"></a>我们先了解两个概念</h3><p>   任意一个数学表达式都可以用二叉树来表示，根节点表示运算符，叶子节点表示数值。</p><p><img src="image.png" alt=""></p><p>根据二叉树遍历方式，那么就有<code>前缀表达式</code>，<code>中缀表达式</code>与<code>后缀表达式</code>三种，人们常习惯用中缀表达式来表示，是因为其较好的可阅读性比较符合人类的思维习惯。但后缀表达式更有利于我们使用计算机来运算。</p><ul><li>中缀表达式：<br>   $a+b$</li><li>后缀表达式：<br>   $ab+$<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3>遍历将中缀表达式，<span style=color:red><strong>准备一个队列和一个临时空栈–&gt;遍历表达式–&gt;数值入队列–&gt;运算符入栈–&gt;匹配右边括号符`)`的时候需要将栈依次出栈到队列中直至出现左边括号符`(`-&gt;最后将栈2的所有符号都出栈到队列</strong></span>，最后就会得到一个队列即为后缀表达式，操作流程如下图，注意<code>括号是不入队列表达式的也就是说待计算的后缀表达式中是没有括号的</code>。<br><img src="image-1.png" alt=""><br><img src="image-2.png" alt=""><br><img src="image-3.png" alt=""><br><img src="image-4.png" alt=""><h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3>后缀表达式计算就比较简单了，如下图：<br><span style=color:red><strong>准备一个空栈–&gt;表达式依次入栈–&gt;数值直接入栈–&gt;遇到运算符就出栈两个数运算-&gt;将计算出新的数值入栈</strong></span>，最后就会得到一个数值即为运算结果。<br><img src="image-5.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题：计算数学表达式-color-green-1-2-times-3-5-2&quot;&gt;&lt;a href=&quot;#题：计算数学表达式-color-green-1-2-times-3-5-2&quot; class=&quot;headerlink&quot; title=&quot;题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$&quot;&gt;&lt;/a&gt;题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$&lt;/h2&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="算法" scheme="https://icevil.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://icevil.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu及QT注意事项-笔记</title>
    <link href="https://icevil.cn/2019/11/25/Ubuntu%E5%8F%8AQT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%AC%94%E8%AE%B0/"/>
    <id>https://icevil.cn/2019/11/25/Ubuntu%E5%8F%8AQT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-25T02:44:15.000Z</published>
    <updated>2020-02-29T07:20:29.908Z</updated>
    
    <content type="html"><![CDATA[<ol><li>E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系</li></ol><p>Ubuntu关闭软件更新，会导致网络安装软件失败，要想安装新软件，需打开网络更新。</p><a id="more"></a><ol start="2"><li>安装ftp服务器vsftpd，配置完后，系统重启服务器用不了</li></ol><p>禁用ipv6即可</p><ol start="3"><li>系统断电记录关机</li></ol><p>这个问题其实没有根本解决办法，拿系统关机日志很麻烦，所以只能另辟蹊径了，加定时器每秒写时间到文件，下次软件启动时先读取文件是否是正常关机，如果不是，则补充断电关机日志，时间可以保持在文件也可以直接取文件修改时间，建议前者。</p><ol start="4"><li>qt如何失去焦点关闭窗口</li></ol><p>在主窗口中重写event事件，关机代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event-&gt;type() == QEvent::ActivationChange)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(QApplication::activeWindow() != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> QWidget::event(event);</span><br></pre></td></tr></table></figure><ol start="5"><li>qt调用shell,比如启用Ubuntu的虚拟键盘</li></ol><p>使用QProcess类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QProcess::execute(<span class="string">"onboard"</span>);<span class="comment">//静态调用</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"onboard"</span>);<span class="comment">//C方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上两种都是在当前进程调用，会导致阻塞。若想多任务</span></span><br><span class="line"></span><br><span class="line">QProcess* proc = <span class="keyword">new</span> QProcess;</span><br><span class="line"></span><br><span class="line">proc-&gt;start(<span class="string">"onboard"</span>);</span><br></pre></td></tr></table></figure><ol><li>Model/View结构中表格可编辑问题</li></ol><p>view能直接setEditTriggers来设置可编辑模式及进入编辑状态的触发条件，单击，双击等。</p><p>需要注意的是Model是也可以控制的，在重写的<code>Qt::ItemFlags flags(const QModelIndex &amp;index) const;</code>函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> QAbstractItemModel::flags(index) | Qt::ItemIsEditable;<span class="comment">//即可设置item为可编辑项</span></span><br></pre></td></tr></table></figure><p>且model设置不可编辑的话，view的editTrigger是不会触发的。</p><ol start="7"><li><p>Shell替换文件内容</p><p> 1、将当前目录下包含jack串的文件中，jack字符串替换为tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> `grep <span class="string">"jack"</span> -rl ./`</span><br></pre></td></tr></table></figure><p> 2、将某个文件中的jack字符串替换为tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> test.txt</span><br></pre></td></tr></table></figure></li><li><p>访问不了串口COM问题</p></li></ol><p>当前用户不能访问串口，其实是Linux权限问题，将当前用户添加到dialout用户组即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd --add yourname dialout</span><br></pre></td></tr></table></figure><p>添加完毕后可以用groups yourname查看是否添加成功</p><ol start="9"><li><p>关闭系统错误报告</p><p> 临时关闭：<code>sudo service apport stop</code></p><p> 永久关闭：将<code>/etc/default/apport</code>文件中的enable=1改成0即可。</p><p> 移除该功能：<code>sudo apt-get purge apport</code> （感觉没必要，常用第二种）</p></li><li><p>关闭/启用系统图形显示服务lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span>/<span class="built_in">enable</span> lightdm.service</span><br></pre></td></tr></table></figure><p>lightdm是一个全新的轻量级的显示管理器，在Ubuntu16.04上面已经使用。</p></li></ol><p>从图形界面进入到命令行界面 <code>systemctl disable lightdm.service</code></p><p>从命令行进入到图形界面 <code>systemctl enable lightdm.service</code> 然后 <code>systemctl start lightdm.service</code></p><ol start="11"><li>Qt数据模型Model与组件委托（delegate）数据同步问题</li></ol><p>在model中又setData，data两个接口需要重写的。参数role==Qt::EditorRole时，即是同步两种数据交互的时期，比如：comboBox与model：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">CMyModel::data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> QVariant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Implement me!</span></span><br><span class="line">    QString strTemp;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::DisplayRole)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步显示数据到combo的currenIndex</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nIndex = m_data[index.row()].DeviceAddr - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> nIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QVariant();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMyModel::setData</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步combo的currenIndex到显示数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[index.row()].DeviceAddr = value.toInt() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>qt工具栏按钮无法隐藏</li></ol><p><code>QAction *QToolBar::addWidget(QWidget *widget)</code>，widget使用setVisible无效，若需隐藏，You should use QAction::setVisible() to change the visibility of the widget.</p><ol start="13"><li>QListView移植到触屏下,手势上下翻滚实现<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QListView *p;</span><br><span class="line"></span><br><span class="line">QScroller-&gt;grabGesture(p, QScroller::TouchGesture);</span><br></pre></td></tr></table></figure></li><li>QListView设置行高</li></ol><p>某度搜了半天,qss啥都不好使,唯有这句有用,view,widget通杀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item-&gt;setSizeHint(QSize(item-&gt;sizeHint().<span class="built_in">width</span>(), <span class="number">32</span>));</span><br></pre></td></tr></table></figure><ol start="15"><li>qt怎样做才能既可以执行那些耗时的操作，又不会阻塞事件循环呢？</li></ol><p>一般会有三种解决方案：第一，我们将任务移到另外的线程；第二，我们手动强制运行事件循环。想要强制运行事件循环，我们需要在耗时的任务中一遍遍地调用<code>QCoreApplication::processEvents()</code>函数(该函数是告诉系统不用等本事件返回了,系统可以处理其他的事件了,所以长时间事件处理时,时而调用该函数,可以清理消息队列,来达到系统不因某个事件而阻塞卡死的目的)。<code>QCoreApplication::processEvents()</code>函数会发出事件队列中的所有事件，并且立即返回到调用者。仔细想一下，我们在这里所做的，就是模拟了一个事件循环。另外一种解决方案：使用<code>QEventLoop</code>类重新进入新的事件循环。通过调用<code>QEventLoop::exec()</code>函数，我们重新进入新的事件循环，给<code>QEventLoop::quit()</code>槽函数发送信号则退出这个事件循环。通过“其它的入口”进入事件循环要特别小心：因为它会导致递归调用！现在我们可以看看为什么会导致递归调用了。回过头来看看按钮的例子。当我们在<code>Worker::doWork()</code>槽函数中调用了<code>QCoreApplication::processEvents()</code>函数时，用户再次点击按钮，槽函数<code>Worker::doWork()</code>又一次被调用,<code>doWork-&gt;processEvents-&gt;doWork-&gt;....</code></p><p>当然，这种情况也有解决的办法：我们可以在调用<code>QCoreApplication::processEvents()</code>函数时传入<code>QEventLoop::ExcludeUserInputEvents</code>参数，意思是不要再次派发用户输入事件（这些事件仍旧会保留在事件队列中）。参考链接</p><ol start="16"><li>设置窗口border宽度及颜色<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有solid，显示不出来，QDialog为作用域，不加会影响所有子窗口</span></span><br><span class="line">setStyleSheet(<span class="string">"QDialog&#123;border: 1px solid rgb(185,185,185);&#125;"</span>);</span><br></pre></td></tr></table></figure></li><li>QMessageBox定制图标及文字样式</li></ol><p>常用的静态函数如果不满足要求，可以使用QMessageBox dlgMsg；dlgMsg.exec();来定制。</p><ol start="18"><li>修改用户名密码过短提示时</li></ol><p>使用：<code>sudo passwd 用户名</code></p><p>可以解决密码过简单设置不成功的问题。</p><ol start="19"><li>&amp; 放在命令后面表示设置此进程为后台进程</li></ol><p>默认情况下，进程是前台进程，这时此进程（命令执行相当于本质是开启一个进程）就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。</p><ol start="20"><li>自动更新检测不出，命令行检测升级系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo   update-manager   -c</span><br></pre></td></tr></table></figure></li><li>sudo不能执行gui程序，报不能使用XDG_RUNTIME_DIR错误<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmg3</span><br></pre></td></tr></table></figure>重启可解决</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ubuntu关闭软件更新，会导致网络安装软件失败，要想安装新软件，需打开网络更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="防坑笔记" scheme="https://icevil.cn/categories/%E9%98%B2%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="Ubuntu" scheme="https://icevil.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>run文件打包</title>
    <link href="https://icevil.cn/2019/11/09/run%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <id>https://icevil.cn/2019/11/09/run%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</id>
    <published>2019-11-09T04:02:46.000Z</published>
    <updated>2020-02-29T07:55:40.626Z</updated>
    
    <content type="html"><![CDATA[<p>run程序安装包实质上是一个安装脚本+程序，为了简单起见，要安装的程序就是helloworld程序，安装它的过程就是把它拷贝到<code>/bin</code>目录下.</p><a id="more"></a><p>install.sh代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">cp helloworld /bin</span><br></pre></td></tr></table></figure><p><code>tar cvf helloworld.tar.gz helloworld</code><br>现在修改一个安装脚本<code>install.sh</code>改为： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">lines=7 <span class="comment">#这个值是指这个脚本的行数加1，这个脚本共有6行 </span></span><br><span class="line">tail +<span class="variable">$lines</span> <span class="variable">$0</span> &gt;/tmp/helloworld.tar.gz <span class="comment"># $0表示脚本本身，这个命令用来把从$lines开始的内容写入一个/tmp目录的helloworld.tar.gz文件里。 </span></span><br><span class="line">tar xvf /tmp/hellowrold.tar.gz </span><br><span class="line">cp helloworld /bin  <span class="comment">#该行代码不变</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>然后使用cat命令连接安装脚本<code>install.sh</code>和<code>helloworld.tar.gz</code>。<br><code>cat install.sh helloworld.tar.gz &gt; myinstall.run</code><br>这样就得到了<code>myinstall.run</code>文件，它的结构如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">------------------</span>|<span class="string"> 第1行 </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> install.sh </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第6行 </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第7行 </span></span><br><span class="line">|<span class="string">helloworld.tar.gz</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> 结尾</span></span><br></pre></td></tr></table></figure><p>运行<code>myinstall.run</code>时，运行到第6行的<code>exit 0</code>脚本就退出了，所以不会去运行第7行以下的二进制数据(即 <code>helloworld.tar.gz</code>文件)，而我们用了<code>tail</code>巧妙地把第7行以下的数据重新生成了一个<code>helloworld.tar.gz</code>文件。再执行安装。<br><code>run</code>安装包制作较小的程序包是很好的选择，但是它也有缺点，做逻辑比较复杂的安装包，写的安装脚本将会很麻烦。因此此时还是用其他的安装包更好。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;run程序安装包实质上是一个安装脚本+程序，为了简单起见，要安装的程序就是helloworld程序，安装它的过程就是把它拷贝到&lt;code&gt;/bin&lt;/code&gt;目录下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="https://icevil.cn/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="打包" scheme="https://icevil.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="run" scheme="https://icevil.cn/tags/run/"/>
    
  </entry>
  
  <entry>
    <title>Linux gdb 调试core dump</title>
    <link href="https://icevil.cn/2019/10/18/Linux%20gdb%20%E8%B0%83%E8%AF%95core%20dump/"/>
    <id>https://icevil.cn/2019/10/18/Linux%20gdb%20%E8%B0%83%E8%AF%95core%20dump/</id>
    <published>2019-10-18T03:27:47.000Z</published>
    <updated>2020-02-23T02:25:38.579Z</updated>
    
    <content type="html"><![CDATA[<p>gdb使用两个推荐链接：<a href="https://www.cnblogs.com/mister-lv/p/6022841.html" target="_blank" rel="noopener">GDB中文手册</a> <a href="https://www.jianshu.com/p/b7896e9afeb7" target="_blank" rel="noopener">GDB常用命令</a></p><a id="more"></a><ol start="0"><li>关于core文件的设置</li></ol><p>两种方式设置core文件名，默认系统是生成名为core的文件，但是当我们为了方便调试，需要生成带pid，time等信息的core文件时候，就需要自己设置一下了。以下命令一般都要root权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/kernel/core_uses_pid</span><br></pre></td></tr></table></figure><p>如果以上命令执行无权限，可以使用下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w kernel.core_uses_pid=1</span><br></pre></td></tr></table></figure><p>都是一个意思，设置core文件名带进程id。另外我们也可以修改core文件统一生成到一个自定义默认路径，比如：“<code>/corefile</code>”更详细可以参考下面说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行如下命令的一条即可</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/corefile/core-%e-%p-%t"</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment">#标识生成的core文件格式是 core-%e-%p-%t,保存路径为/corefile</span></span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure><blockquote><p>%p - insert pid into filename 添加pid(进程id)<br>%u - insert current uid into filename 添加当前uid(用户id)<br>%g - insert current gid into filename 添加当前gid(用户组id)<br>%s - insert signal that caused the coredump into the filename 添加导致产生core的信号<br>%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间<br>%h - insert hostname where the coredump happened into filename 添加主机名<br>%e - insert coredumping executable name into filename 添加导致产生core的命令名</p></blockquote><ol><li><p>在终端使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c</span><br></pre></td></tr></table></figure><p>查看你当前终端是否打开了core dump。系统一半默认输出0，此时我们需要设置一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>将终端设置成无限dump文件大小。也可以设置成一个值比如1000，dump文件超过1000字节就不会继续生成。所以通常使用无限制大小。</p></li><li><p>编写测试demo,text.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ -o text text.cpp</code>，生成text可执行文件，然后运行，就会得到<code>core.*</code>文件了。</p></li><li><p>gdb调试</p></li></ol><p>当我们发布程序后，拿到core文件了，怎么调试？答案就是gdb。</p><p>使用源代码，如果是用makefile的话也一样，编译的时候加 -g 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">g++ -g -o textd text.cpp</span><br><span class="line"><span class="comment">#调试</span></span><br><span class="line">gdb textd core.*</span><br></pre></td></tr></table></figure><p>此时我们就会发现输出信息很直观了，如下图。<br><img src="20191018112559275.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gdb使用两个推荐链接：&lt;a href=&quot;https://www.cnblogs.com/mister-lv/p/6022841.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB中文手册&lt;/a&gt; &lt;a href=&quot;https://www.jianshu.com/p/b7896e9afeb7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB常用命令&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="linux" scheme="https://icevil.cn/tags/linux/"/>
    
      <category term="gdb" scheme="https://icevil.cn/tags/gdb/"/>
    
      <category term="core dump" scheme="https://icevil.cn/tags/core-dump/"/>
    
  </entry>
  
  <entry>
    <title>用Qt5编写压缩解压缩文件(夹)</title>
    <link href="https://icevil.cn/2019/08/02/%E7%94%A8Qt5%E7%BC%96%E5%86%99%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6(%E5%A4%B9)/"/>
    <id>https://icevil.cn/2019/08/02/%E7%94%A8Qt5%E7%BC%96%E5%86%99%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6(%E5%A4%B9)/</id>
    <published>2019-08-02T07:21:15.000Z</published>
    <updated>2020-02-23T03:12:00.922Z</updated>
    
    <content type="html"><![CDATA[<p>全网居然没找到一个能直接压缩整个文件夹的c/c++库,就算找到了zlib，karchive，archive等开源库，基本也是在Linux下支持的较好，在win下只有zlib还算是编译过了。而且不能全文件夹压缩的，都是buffer或者单文件压缩，这就好奇了，标准zip怎么搞？原来zip是有一个特定archive的，<a href="http://www.fileformat.info/format/zip/corion.htm" target="_blank" rel="noopener">链接在此</a>。</p><a id="more"></a><p>由此思路，如果自己要压缩文件夹，那就自己遍历，然后自己定义压缩文件的格式就好了，当然不是标准化的压缩格式而已了。但是够自己使用就行。这么理解，实现文件夹的压缩就显得不那么重要了，重要的是压缩算法，而提供压缩算法的库就多了去了，也容易找到。下面就用qt5简单实现一个文件的压缩与解压缩。注意，没有全文件一次读取再压缩，是考虑到文件太大，比如4g，会直接冲爆你的内存。下面测试代码已使用MD5验证通过。show code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUFFER 10240</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;output)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            QByteArray <span class="built_in">read</span> = file.<span class="built_in">read</span>(READ_BUFFER);</span><br><span class="line">            QByteArray comp = qCompress(<span class="built_in">read</span>);</span><br><span class="line">            <span class="keyword">int</span> nsize = comp.<span class="built_in">size</span>();</span><br><span class="line">            ds&lt;&lt;nsize&lt;&lt;comp;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"Input:"</span>&lt;&lt;nsize;</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uncompress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        QByteArray <span class="built_in">read</span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">            ds&gt;&gt;<span class="built_in">size</span>&gt;&gt;<span class="built_in">read</span>;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"out:"</span>&lt;&lt;<span class="built_in">size</span>;</span><br><span class="line">            QByteArray comp = qUncompress(<span class="built_in">read</span>);</span><br><span class="line">            output.<span class="built_in">write</span>(comp);</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"compress...."</span>;</span><br><span class="line">    compress(<span class="string">"data.db"</span>, <span class="string">"data.zip"</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"uncompress...."</span>;</span><br><span class="line">    uncompress(<span class="string">"data.zip"</span>, <span class="string">"dt.db"</span>);</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全网居然没找到一个能直接压缩整个文件夹的c/c++库,就算找到了zlib，karchive，archive等开源库，基本也是在Linux下支持的较好，在win下只有zlib还算是编译过了。而且不能全文件夹压缩的，都是buffer或者单文件压缩，这就好奇了，标准zip怎么搞？原来zip是有一个特定archive的，&lt;a href=&quot;http://www.fileformat.info/format/zip/corion.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接在此&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://icevil.cn/categories/Qt/"/>
    
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="压缩" scheme="https://icevil.cn/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="解压缩" scheme="https://icevil.cn/tags/%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://icevil.cn/2019/07/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://icevil.cn/2019/07/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2019-07-22T11:13:21.000Z</published>
    <updated>2020-02-29T08:05:21.505Z</updated>
    
    <content type="html"><![CDATA[<p>关于线程同步主要有四种方式：临界区/互斥量/信号量/事件</p><a id="more"></a><h2 id="临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"><a href="#临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）" class="headerlink" title="临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"></a>临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）</h2><p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p><p>可以将临界区比作旅馆的房卡，调用<code>EnterCriticalSection()</code>即申请房卡，得到房卡后自己当然是可以多次进出房间的，在你调用<code>LeaveCriticalSection()</code>交出房卡之前，别人自然是无法进入该房间,在经典线程同步问题上，主线程正是由于拥有“线程所有权”即房卡，所以它可以重复进入关键代码区域从而导致子线程在接收参数之前主线程就已经修改了这个参数。所以关键段可以用于线程间的互斥，但不可以用于同步。</p><h2 id="互斥量（Mutex）（可以跨进程，实现互斥）"><a href="#互斥量（Mutex）（可以跨进程，实现互斥）" class="headerlink" title="互斥量（Mutex）（可以跨进程，实现互斥）"></a>互斥量（Mutex）（可以跨进程，实现互斥）</h2><p>互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。<br>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</p><h2 id="信号量（Semaphores）（主要是实现同步，可以跨进程）"><a href="#信号量（Semaphores）（主要是实现同步，可以跨进程）" class="headerlink" title="信号量（Semaphores）（主要是实现同步，可以跨进程）"></a>信号量（Semaphores）（主要是实现同步，可以跨进程）</h2><p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出</p><h2 id="事件（Event）（实现同步，可以跨进程）"><a href="#事件（Event）（实现同步，可以跨进程）" class="headerlink" title="事件（Event）（实现同步，可以跨进程）"></a>事件（Event）（实现同步，可以跨进程）</h2><p>事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。</p><p>互斥量也是一个特殊的信号量（无计数能力或者说计数就是1的信号量）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于线程同步主要有四种方式：临界区/互斥量/信号量/事件&lt;/p&gt;
    
    </summary>
    
    
      <category term="c/c++" scheme="https://icevil.cn/categories/c-c/"/>
    
    
      <category term="临界区" scheme="https://icevil.cn/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="互斥量" scheme="https://icevil.cn/tags/%E4%BA%92%E6%96%A5%E9%87%8F/"/>
    
      <category term="信号量" scheme="https://icevil.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="事件" scheme="https://icevil.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="线程同步" scheme="https://icevil.cn/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用windeployqt打包</title>
    <link href="https://icevil.cn/2019/06/11/%E4%BD%BF%E7%94%A8windeployqt%E6%89%93%E5%8C%85/"/>
    <id>https://icevil.cn/2019/06/11/%E4%BD%BF%E7%94%A8windeployqt%E6%89%93%E5%8C%85/</id>
    <published>2019-06-11T05:36:48.000Z</published>
    <updated>2020-02-22T14:44:23.753Z</updated>
    
    <content type="html"><![CDATA[<p>使用QT5自带的windeployqt打包程序</p><a id="more"></a><ol><li>从开始菜单找到qt程序目录如下图，我安装了vs版和mingw版本，根据需要选择即可。<br><img src="20190611132725707.png" alt=""></li></ol><ol start="2"><li>执行两条关键命令</li></ol><p>cd 到exe所在的目录</p><p>执行<code>windeployqt *.exe</code></p><p>会在当前目录生成exe依赖的所有文件（含库，语言包，插件等信息，部分非必须文件也会被拷贝过来）。<br>此时程序即可打包了。</p><p><img src="20190611133144365.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用QT5自带的windeployqt打包程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://icevil.cn/categories/Qt/"/>
    
    
      <category term="打包" scheme="https://icevil.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="qt" scheme="https://icevil.cn/tags/qt/"/>
    
      <category term="windeployqt" scheme="https://icevil.cn/tags/windeployqt/"/>
    
  </entry>
  
</feed>
