<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis源码分析之数据库存储结构</title>
    <url>/2020/04/04/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>redis作为一个key-value存储系统，是如何做到高效的呢？在内存中维护一个hash表，hash表的操作时间复杂度是O(1),但是hash是由一定概率发生hash碰撞的，通常做法是还会维护一个list，以确保数据完整性。但是这个list一旦过长，速率必然明显下降，所以一定要有足够的空间分配来避免list过长，而redis是怎么灵活控制内存伸缩的呢？下面从源码着手查找原因。</p>
<a id="more"></a>
<h2 id="选择HASH算法"><a href="#选择HASH算法" class="headerlink" title="选择HASH算法"></a>选择HASH算法</h2><p>作为一个高效查找的数据库，从大量数据中查找一条数据，速度上来说的话，hash以O(1)的时间复杂度远胜于list，红黑树等现存数据结构。具体做法是怎样呢？</p>
<blockquote>
<p>hash为何是O(1)的时间复杂度，这里简单说明一下hash，hash是将给定的一串数字<code>sdafdf123123</code>，可以是字符串或者任意数字，通过<code>hash(&quot;sdafdf123123&quot;)</code>比如选择md5算法，得到一个散列值<code>7ce989929a0f0f862d71c8f67352a97d</code>,哪怕用时下优秀的MurmurHash算法，如下图：<br><img src="hash.jpg" alt=""><br>将图中的散列值作为索引，依然可以看出这是一个非常庞大的内存数组。所以通常我们会设置成固定大小的数组，然后以<code>hash(key)%size</code>作为索引，并在value加上key的list信息来报存完整数据，达到节省内存空间的目的。</p>
</blockquote>
<p><strong>例如</strong>：需要存储一个<code>key-value</code>结构，则实际存储的是<code>hash(key)%size-value</code>.</p>
<p>通过上述介绍，我们可以知道，我们不可能用上千万的TB内存去存储散列值，一定会选择类似取余的运算（redis选择的是直接位与运算<code>&amp;</code>），选择取余运算这就必然出现“碰撞”，所以每个键值对维护的列表必然会增长意味着时间必然上升，而且hash本身也会有碰撞，即使是再好的算法只是降低了碰撞率，所以我们必须在内存空间和时间空间上做一个优化选择，redis是如何权衡这种保证速度的情况下，还能对空间自由缩放的呢？</p>
<h2 id="redis的字典"><a href="#redis的字典" class="headerlink" title="redis的字典"></a>redis的字典</h2><p>redis的hash算法具体见<code>sha1.c</code>。每个redis字典有两个<code>hash table</code>(hash表)。</p>
<h3 id="redis的哈希表"><a href="#redis的哈希表" class="headerlink" title="redis的哈希表"></a>redis的哈希表</h3><p>首先我们介绍redis中的hash表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     </span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个<code>键值对</code>；</p>
</li>
<li><p>size 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（<code>键值对</code>）的数量；</p>
</li>
<li><p>sizemask 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面；</p>
</li>
<li><p>used属性，表示hash表里已有的数量。<br>如下图展示了一个空的hash表：<br><img src="empty_hash_table.png" alt="redis空的hash表"></p>
</li>
</ul>
<h3 id="hash表节点"><a href="#hash表节点" class="headerlink" title="hash表节点"></a>hash表节点</h3><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数，或者是double类型。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决<code>键冲突（collision）</code>的问题。</p>
<p>举个例子， 下图图就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。<br><img src="hash_table_node.jpg" alt="hash表节点"></p>
<h3 id="redis字典"><a href="#redis字典" class="headerlink" title="redis字典"></a>redis字典</h3><p>先来看字典的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字典类型</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典的私有数据,供type使用</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 两张哈希表，默认使用ht[0],当需要进行rehash的时候，会利用ht[1]进行</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash的索引，当没有进行rehash时其值为-1</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash表的迭代器，一般用于rehash和主从复制等等</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的，<strong>个人理解相当于C++的自定义类，你需要传入它的构造函数，比较函数，析构函数</strong>：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， <code>Redis</code> 会为用途不同的字典设置不同的类型特定函数。</li>
<li><code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 <code>rehash</code> 时使用。</p>
<blockquote>
<p>注解：</p>
<p><code>rehash</code>是什么？什么时候触发？<code>rehash</code>的步骤？</p>
<p><code>rehash</code>其实是一个从新分配空间的操作。hash表里的空间不够用或者空间空闲太多的时候，就利用ht[1]去进行扩容或者缩减空间。</p>
</blockquote>
<p>除了 ht[1] 之外， 另一个和 <code>rehash</code> 有关的属性就是 <code>rehashidx</code> ： 它记录了 <code>rehash</code> 目前的进度， 如果目前没有在进行 <code>rehash</code> ， 那么它的值为 -1 。</p>
<p>如下图展示了一个普通的字典：<br><img src="dict.png" alt="字典"></p>
<p>初始时，字典的hash表的大小只有4（<code>sizemask</code>为3），那么通过hash函数计算出的hash值可能会很大，此时hash值会与上（&amp;）<code>sizemask</code>，得到存储在hash表里的table[index]，见如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>比如我们dictFind的实现，通过key获取hash表的节点（即通过key获取value）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入键值对到字典</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果正在rehash，插入到ht[1],否则插入到ht[0]</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典中查找key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];<span class="comment">//这里只是找到索引，索引相同未必key相同</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//key比较，相同，返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，我们上文说到了4个url，那是如何存储到一个空的hash表里的呢？</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>hash</th>
<th>hash &amp; sizemask (index)</th>
</tr>
</thead>
<tbody><tr>
<td>baidu</td>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td>
<td>6912155183386829266</td>
<td>2</td>
</tr>
<tr>
<td>taobao</td>
<td><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></td>
<td>16210426838115629763</td>
<td>3</td>
</tr>
<tr>
<td>xinlang</td>
<td><a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></td>
<td>5168022858719342865</td>
<td>1</td>
</tr>
<tr>
<td>csdn</td>
<td><a href="http://www.csdn.com" target="_blank" rel="noopener">www.csdn.com</a></td>
<td>9700202312283457906</td>
<td>2</td>
</tr>
</tbody></table>
<p>插入到字典后，字典结构如下：<br><img src="urls_dict.jpg" alt="urls字典"></p>
<p><font color=red>总结下：hash表是随着K-V数量的增大而逐步增大的，并不直接以key的hash值为下标去取值得，而是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是一个链表，如果hash &amp; sizemask有冲突，则也把冲突key放在hash表的链表上，取值的时候还得遍历hash表里的链表。</font></p>
<h2 id="redis的数据库的结构"><a href="#redis的数据库的结构" class="headerlink" title="redis的数据库的结构"></a>redis的数据库的结构</h2><p>在redis的内部，有一个redisServer结构体的全局变量server，server保存了redis服务端所有的信息，包括当前进程的PID、服务器的端口号、数据库个数、统计信息等等。当然，它也包含了数据库信息，包括数据库的个数、以及一个redisDb数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="keyword">int</span> dbnum;    <span class="comment">/* Total number of configured DBs */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>显然，<code>dbnum</code>就是<code>redisDb</code>数组的长度，每一个数据库，都对应于一个<code>redisDb</code>，在redis的客户端中，可以通过select N来选择使用哪一个数据库，各个数据库之间互相独立。例如：可以在不同的数据库中同时存在名为“baidu”的key。</p>
<p>从上面的分析中可以看到，server是一个全局变量，它包含了若干个<code>redisDb</code>，每一个<code>redisDb</code>是一个<code>keyspace</code>(译作键空间)，各个<code>keyspace</code>互相独立，互不干扰。</p>
<p>下面来看一下redisDb的定义：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the 'id' field in the structure. */</span></span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict; </span>                <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    <span class="keyword">dict </span>*expires<span class="comment">;              /* Timeout of keys with a timeout set */</span></span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">blocking_keys; </span>       <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    <span class="keyword">dict </span>*ready_keys<span class="comment">;           /* Blocked keys that received a PUSH */</span></span><br><span class="line">    <span class="keyword">dict </span>*watched_keys<span class="comment">;         /* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    int id<span class="comment">;                     /* Database ID */</span></span><br><span class="line">    long long avg_ttl<span class="comment">;          /* Average TTL, just for stats */</span></span><br><span class="line">    list *defrag_later<span class="comment">;         /* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>redis的每一个数据库是一个独立的<code>keyspace</code>，因此，我们理所当然的认为，redis的数据库是一个hash表。但是，从redisDb的定义来看，它并不是一个hash表，而是一个包含了很多hash表的结构。之所以这样做，是因为redis还需要提供除了set、get以外更加丰富的功能(例如：键的超时机制)。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（ratio）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<blockquote>
<p>官方叫比率，可以认为是哈希表的使用率：ratio = ht[0].used / ht[0].size</p>
</blockquote>
<p>比如，hash表的size为4，如果已经插入了4个k-v的话，则ratio 为 1</p>
<blockquote>
<p>ratio = 4 / 4 = 1</p>
</blockquote>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的策略如下：</p>
<ul>
<li><ol>
<li>如果ratio小于0.1，则会对hash表进行收缩操作</li>
</ol>
</li>
<li><ol start="2">
<li>服务器目前没有在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令， 并且哈希表的负载因子大于等于 1 ，则扩容hash表，扩容大小为当前<code>ht[0].used*2</code>   </li>
</ol>
</li>
<li><ol start="3">
<li>服务器目前正在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令， 并且哈希表的负载因子大于等于 5，则扩容hash表，并且扩容大小为当前<code>ht[0].used*2</code></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE      4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHTABLE_MIN_FILL        10</span></span><br><span class="line"><span class="comment">//需要收缩条件判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">size</span>, used;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">size</span> &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/<span class="built_in">size</span> &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容条件判断</span></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dictExpand会调用下面这个函数计算扩容大小</span></span><br><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="built_in">size</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上文说的扩容为ht[0].uesd*2 是不严谨的，实际上是一个刚好大于等于该数的2的N次方,比如used=5,实际扩容不是2 * 5=10，而是2^4=8.</p>
<p>扩容的步骤如下：<br>1、为字典ht[1]哈希表分配合适的空间；<br>2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上；<br>3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>上一节说过， 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， <font color=red>为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</font></p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。  </li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。  </li>
<li><font color=red>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会额外花1毫秒的时间将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 。当 rehash 工作成功之后， 程序将 rehashidx 属性的值增一，一毫秒的时间其实是能rehash很多的，就算一次性rehash不完，下次更新操作的时候继续执行rehash。</font></li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上，甚至是后台启动一个定时器，每次时间循环时只工作一毫秒， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据迁移任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">databasesCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Perform hash tables rehashing if needed, but only if there are no</span></span><br><span class="line"><span class="comment">     * other processes saving the DB on disk. Otherwise rehashing is bad</span></span><br><span class="line"><span class="comment">     * as will cause a lot of copy-on-write of memory pages. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每调用一次最多迁移16条数据到新的hash表</span></span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;<span class="comment">//宏CRON_DBS_PER_CALL = 16</span></span><br><span class="line">        <span class="comment">/* Resize */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum);</span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rehash */</span></span><br><span class="line">        <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> work_done = incrementallyRehash(rehash_db);</span><br><span class="line">                <span class="keyword">if</span> (work_done) &#123;</span><br><span class="line">                    <span class="comment">/* If the function did some work, stop here, we'll do</span></span><br><span class="line"><span class="comment">                     * more at the next cron loop. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* If this db didn't need rehash, we'll try the next one. */</span></span><br><span class="line">                    rehash_db++;</span><br><span class="line">                    rehash_db %= server.dbnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our hash table implementation performs rehashing incrementally while</span></span><br><span class="line"><span class="comment"> * we write/read from the hash table. Still if the server is idle, the hash</span></span><br><span class="line"><span class="comment"> * table will use two tables for a long time. So we try to use 1 millisecond</span></span><br><span class="line"><span class="comment"> * of CPU time at every call of this function to perform some rehahsing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 1 if some rehashing was performed, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned. */</span></span><br><span class="line"><span class="comment">//每次读/写的时候花1毫秒的时间去执行rehash操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementallyRehash</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Keys dictionary */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].dict)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].dict,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Expires */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].expires)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].expires,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>那么hash表里的一个个对象都是什么呢？<br>下面请看C语言版“继承”的实现，是不是很有趣？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redis里的对象有11种，他们全都继承于redisObject。type属性，就是各对象的识别属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>
<p>本文参考了<a href="https://www.jianshu.com/p/bfecf4ccf28b" target="_blank" rel="noopener">wenmingxing Redis之字典</a></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
        <tag>存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信与线程同步</title>
    <url>/2020/03/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间进程间传输数据或交换信息。目的是提高系统扩展功能的同时，以内存安全访问的形势提升的并行性能。</p>
<a id="more"></a>
<h3 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h3><p>管道是Linux/Windows（winCE不支持）都具有的进程间通信方式，它是一种半双工的通信方式，数据只能单向流动，且具有FIFO特性。分命名管道与匿名管道两种，管道默认指匿名管道。</p>
<ol>
<li>匿名管道（pipe）：而且<strong>只能在具有亲缘关系的进程间使用</strong>进程间的亲缘关系通常是指父子进程关系。<br> 匿名管道的特征：<br>　　①创建一个管道文件，只提供单向通信<br>　　②只能用于具有血缘关系的进程间通信，通常用于父子进程间通信<br>　　③管道是基于字节流来通信的<br>　　④依赖于文件系统，它的生命周期随进程的结束结束（随进程）<br>　　⑤其本身自带同步互斥效果</li>
<li>命名管道（named pipe）：与匿名管道不同的是<strong>命名管道可以在不相关的进程之间</strong>。<br>有跨设备的情况也是封装了<code>tcp/ip</code>，所以通常还是用于同机不同进程的通信。</li>
</ol>
<h3 id="信号量（semophore）"><a href="#信号量（semophore）" class="headerlink" title="信号量（semophore）"></a>信号量（semophore）</h3><p>信号量是一个计数器，可以用来控制多个进程队共享资源的访问。它常作为一个锁机制，防止某进程在访问共享资源时，其他进程也访问此资源。例如：多个线程竞态的时候，当信号量达到某值num时，唤醒num个线程。<br>该方式其实是线程层面的控制，以达到进程竞态控制。（详见后文）</p>
<h3 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h3><p>信号是一种通知进程某件事情发生了的一种通信机制，通过向进程发送某个信号，可以告诉进程发生了什么事情，进程收到这个信号后，就知道某事情发生了，进程可以做出相应的响应（处理）。与IPC中其他进程通信方式不同的是，信号属于不精确通信，信号只能告诉进程大概发生了什么事情，但是不能准确的告诉进程详细的细节信息。<br>信号在操作系统内核应用非常广泛，Linux下边定义了很多的信号，所有的信号都是一个整数编号，不过为了好辨识，Linux系统给这些整数编号都定义了对应的宏名，宏名都是以SIG开头，比如:<code>SIGABRT</code>,<code>kill -9 pid</code>,<kbd>ctrl</kbd>+<kbd>c</kbd>就是发送<code>SIGINT</code>。</p>
<h3 id="消息队列（message-queue）"><a href="#消息队列（message-queue）" class="headerlink" title="消息队列（message queue）"></a>消息队列（message queue）</h3><p>消息队列就是一个消息的链表。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列就是一个消息的链表<br>大家熟知的windows的gui就是消息队列驱动的，但是Linux下也是支持消息队列的。</p>
<h3 id="共享内存（shared-memory）"><a href="#共享内存（shared-memory）" class="headerlink" title="共享内存（shared memory）"></a>共享内存（shared memory）</h3><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的ipc通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往和其他通信方式如信号量，配合使用来实现进程间的同步和通信。</p>
<h3 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h3><p>套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备间的进程通信。<br>这是搭建网络通信的基础，这里就不多说了。</p>
<h2 id="线程间通信-同步方式"><a href="#线程间通信-同步方式" class="headerlink" title="线程间通信/同步方式"></a>线程间通信/同步方式</h2><p>线程间通信方式，理论上所有的进程通信方式都是可以达到线程间通信的，因为进程就可以看作是一个不能为空的线程集。下面我们主要谈一些线程层面的或者说特有的通信方式。</p>
<ol>
<li>全局变量<br>线程可以访问所有全局变量。</li>
<li>信号量<br>这是基于线程设计的</li>
<li>事件(event)<br>Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</li>
<li>锁</li>
</ol>
<p>线程同步主要分互斥控制与同步控制，</p>
<ol>
<li>互斥控制：临界区，互斥量。（锁的形式控制）</li>
<li>同步控制：信号量，事件。（通知的形式控制）</li>
</ol>
<h3 id="临界区-CcriticalSection"><a href="#临界区-CcriticalSection" class="headerlink" title="临界区(CcriticalSection)"></a>临界区(CcriticalSection)</h3><p>通过对多线程的串行化来<strong>访问公共资源或一段代码，速度快，适合控制数据访问</strong>。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。<br>临界区对应着一个<code>CcriticalSection</code>对象，当线程需要访问保护数据时，调用<code>EnterCriticalSection</code>函数；当对保护数据的操作完成之后，调用<code>LeaveCriticalSection</code>函数释放对临界区对象的拥有权。</p>
<h3 id="互斥量（mutex）"><a href="#互斥量（mutex）" class="headerlink" title="互斥量（mutex）"></a>互斥量（mutex）</h3><p>互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。</p>
<h3 id="信号量（semophore）-1"><a href="#信号量（semophore）-1" class="headerlink" title="信号量（semophore）"></a>信号量（semophore）</h3><p>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作.</p>
<blockquote>
<p>用PV操作(P—— passeren，中文译为”通过”，V—— vrijgeven，中文译为”释放” 荷兰语)来管理共享资源时，首先要确保PV操作自身执行的正确性。由于P(S)和V(S)都是在同一个信号量S上操作，为了使得它们在执行时不发生因交叉访问信号量S而可能出现的错误，约定P(S)和V(S)必须是两个不可被中断的过程，即让它们在屏蔽中断下执行。把不可被中断的过程称为原语。于是，P操作和V操作实际上应该是P操作原语和V操作原语。<br>P操作的主要动作是：<br>①S减1；<br>②若S减1后仍大于或等于0，则进程继续执行；<br>③若S减1后小于0，<font color=red>则挂起该线程后放入该信号量对应的等待队列中，然后转线程调度（执行其他线程）。</font><br>V操作的主要动作是：<br>①S加1；<br>②若相加后结果大于0，则进程继续执行；<br>③若相加后结果小于或等于0，<font color=red>则从该信号的等待队列中释放一个线程，然后转线程调度（唤醒执行）。</font><br>PV操作对于每一个进程来说，都只能进行一次，而且必须成对使用。在PV原语执行期间不允许有中断发生。原语不能被中断执行，因为原语对变量的操作过程如果被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p>
</blockquote>
<h3 id="事件（event）"><a href="#事件（event）" class="headerlink" title="事件（event）"></a>事件（event）</h3><p>1.什么是事件？<br>事件Event对象是内核对象，代表系统的某一个状态（如），每一个事件都对应了一个事件触发函数。<br>2.事件什么时候产生?<br>当用户触发某元素的特定事件的时候（如：mouseMove,click），事件会调用事件响应函数，传递下去，函数不会在事件发生前被执行。<br>3.事件的编程<br>事件类型分为“通知事件”和“同步事件”两类，前者变为激发状态的时候，需要手动<code>置位事件</code>（<em>置位事件，是调用事件处理函数后，将事件恢复为未激发态，以便下次还能继续激发。所有事件都只有激活与未激活两种状态</em>），后者会自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：win事件使用</span></span><br><span class="line"><span class="comment">//1.初始化事件为未触发状态</span></span><br><span class="line">HANDLE g_event = CreateEvent(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);	</span><br><span class="line"><span class="comment">//2.等待事件被触发</span></span><br><span class="line">WaitForSingleObject(g_event, INFINITE);	</span><br><span class="line"><span class="comment">//3.触发事件</span></span><br><span class="line">SetEvent(g_event);	</span><br><span class="line"><span class="comment">//4.事件解绑</span></span><br><span class="line">CloseHandle(g_event);</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><span style="color:red; background:yellow">注意</span></h3><p>以上4种方式，只有临界区不是内核对象，所以必须手动释放，其他线程才能继续获取<code>相应代码段</code>的执行权限。而互斥量的释放是将该互斥量的所有权从某线程剥离，互斥量本身并没有被释放，内核对象的管理是操作系统完成的。<br>信号量也属于内核对象，可用于进程间的通信</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>进程间通信</tag>
        <tag>ipc</tag>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>深入C++内存模型</title>
    <url>/2020/03/26/%E6%B7%B1%E5%85%A5C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>C++是由C语言发展过来的，兼容了C语言的所有特性，外加面向对象编程。所以有人说Java才是真正的面向对象编程的语言。我也承认Java在面向对象方面比C++要好，那么C++是怎么做到兼容C又面向对象的呢？本文主要目的是分析C++的内存模型以方便我们理解记忆C++的一些特性，以及C语言的共性。</p>
<a id="more"></a>
<h2 id="C-C-程序内存模型保持一致分为4大块"><a href="#C-C-程序内存模型保持一致分为4大块" class="headerlink" title="C/C++程序内存模型保持一致分为4大块"></a>C/C++程序内存模型保持一致分为4大块</h2><p>当操作系统在调用一个二进制C/C++程序时，是如何分配内存的呢？</p>
<h3 id="1-全局数据区（data-area）"><a href="#1-全局数据区（data-area）" class="headerlink" title="1. 全局数据区（data area）"></a>1. 全局数据区（data area）</h3><p><strong>全局数据区存放全局变量，静态数据和常量</strong>。<br>1.该区空间系统分配时会自动初始化为0.<br>2.所有全局变量，这个好理解不多说。<br>3.静态数据（包括类静态成员，函数内静态变量），这里就说明了一个现象，类的静态函数是属于类的而不是对象的。另外函数内静态变量生命周期直至程序结束，只是访问权限仅限函数内部（那么对于类成员访问权限控制是不是也一样呢？）；所以我们通常用这个原则来记录函数的被调用次数。<br>4.常量（包括类常量成员，函数内常量），和全局变量类似，权限上加了访问控制。</p>
<h3 id="2-代码区（code-area"><a href="#2-代码区（code-area" class="headerlink" title="2. 代码区（code area)"></a>2. 代码区（code area)</h3><p><strong>所有类成员函数和非成员函数代码存放在代码区，也叫只读区</strong>。<br>这里是存放程序的所有代码的地方，不可修改，控制着程序的执行流程。</p>
<h3 id="3-栈区（stack-area）"><a href="#3-栈区（stack-area）" class="headerlink" title="3. 栈区（stack area）"></a>3. 栈区（stack area）</h3><p><strong>为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区</strong>。<br>这是操作系统会自动回收内存的区域，所以函数内的局部变量我们是不需要去手动释放内存的，因为当函数被调用的时候，它会自动分配内存也叫入栈，函数执行完后，会有出栈。这也是形参和实参的根本区别的地方，入栈的是从实参拷贝过来的形参，例如：我们要给一个新定义的指针分配内存，一定要传指针的地址，然后在函数中修改指针的值，才能真正得到一个有价值的指针；而不是传指针，如果传指针的话，该指针会被<code>copy</code>一份，所以其指向的内存是形参的而不是实参的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    New(p);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;(p!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果如下应该不意外了吧？</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="4-堆区（heap-area）"><a href="#4-堆区（heap-area）" class="headerlink" title="4. 堆区（heap area）"></a>4. 堆区（heap area）</h3><p><strong>用户自由分配内存区，所有用户new/delete操作的空间都在此区</strong>。<br>该区是用户动态申请的内存空间，程序不会自动回收，是因为程序压根不知道你什么时候需要释放，主动权在用户，而不是程序，栈区，函数结束了，程序就知道回收了，而堆区，只有进程结束了，才会自动回收内存。至于Java这种垃圾回收机制，也不是100%的，即时的回收，因为逻辑上做不到。另外我们能new的大小是多少？是全内存条的空间吗？答案不是，操作系统内核空间，或者说低区空间，应用程序是不能使用的，这是操作系统，为了保障系统的正常运行自我预留的空间。所以new是设计了抛异常的，具体关注throw。</p>
<p>C/C++的内存模型总结完了，那下面聊点别的衍生产品</p>
<h2 id="类的剖析"><a href="#类的剖析" class="headerlink" title="类的剖析"></a>类的剖析</h2><p>C++在编译过程中会将用户所有的定义的变量，接口等<strong>重命名</strong>,具体重命名规则由编译器决定。本文重点讲内存，不讲编译原理，所以以下都是伪代码。</p>
<ol>
<li>所有成员函数参数都带着this指针，如<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cpp文件编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Myclass::fun</span><span class="params">(<span class="keyword">int</span> args,...)</span></span></span><br><span class="line">#转换后，对应的函数大概如下</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Myclass::fun</span><span class="params">(Myclass *<span class="keyword">this</span>, <span class="keyword">int</span> args,...)</span></span></span><br></pre></td></tr></table></figure></li>
<li>成员函数与非成员函数的区别<br>成员函数编译后会带着类的信息在函数名，如<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cpp文件编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Myclass::fun</span><span class="params">(<span class="keyword">int</span> args,...)</span></span></span><br><span class="line">#转换后，对应的函数大概如下</span><br><span class="line"><span class="keyword">void</span>* Myclass@@fun(Myclass *<span class="keyword">this</span>, <span class="keyword">int</span> args,...)</span><br></pre></td></tr></table></figure></li>
<li>成员函数/变量访问权限控制<br>原理同2，如：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cpp文件编码</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">Myclass::fun</span><span class="params">(<span class="keyword">int</span> args,...)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> m_data</span>;</span><br><span class="line">#转换后，对应的函数大概如下</span><br><span class="line"><span class="keyword">void</span>* Myclass_pub@@fun(Myclass *<span class="keyword">this</span>, <span class="keyword">int</span> args,...)</span><br><span class="line"><span class="keyword">int</span> _pub_m_data;</span><br></pre></td></tr></table></figure></li>
<li>静态成员变量，常量成员变量<br>原理同2，不赘述，以及类的虚函数换名原则上还是一样的，虚函数单独分析</li>
</ol>
<h2 id="类的存储"><a href="#类的存储" class="headerlink" title="类的存储"></a>类的存储</h2><p>一个类，我们已经知道了其成员函数是直接放在代码区的，而静态的或者常量的成员是放在全局区的。那类占不占用空间？</p>
<blockquote>
<p>gcc，一个空类占用空间是1字节。<br>如果有成员，成员的空间是属于类的，但是类的空间扩展上有内存对齐，如果有一个<code>int m_data</code>,则会成4字节，再加一个<code>char m_c</code>则会变成8字节，和C语言的内存对齐基本一致。<br>一个类除了成员变量占用空间还有就是虚函数是占用空间的，那虚函数是怎么占用空间的呢？<br>给上述类中加一个<code>virtual void fun1(){cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;}</code>发现类空间扩大了8字节，这里原因是因为本人的电脑是64位Linux，如果是32位电脑应该是4字节。于是，一口气再加5个虚函数，发现类空间没变，原因是类空间维护的不是虚函数而是<code>虚函数表</code>（这是一个指针,指向一个类的虚函数地址数组）</p>
</blockquote>
<h2 id="虚函数与多态的关系"><a href="#虚函数与多态的关系" class="headerlink" title="虚函数与多态的关系"></a>虚函数与多态的关系</h2><p>我们如何访问类的虚函数表呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> (<span class="keyword">void</span>)(* vft)();</span><br><span class="line"><span class="comment">//获取对象obj的虚函数表</span></span><br><span class="line">vft* pVFT = (vft*)(*((<span class="keyword">long</span>*)&amp;obj));</span><br><span class="line"><span class="comment">//通过虚函数表访问虚函数</span></span><br><span class="line">(*pVFT)();</span><br><span class="line">pVFT++;</span><br></pre></td></tr></table></figure>
<p>代码中pVFT就是一个虚函数表指针，它其实也是一个数组指针，用<code>pVFT[index]()</code>同样能访问到对应的虚函数。那么接下来有一个灵魂拷问，多态是怎么实现的？一个子类指针是如何调用到自身的虚函数的呢？<br>每一个对象如果基类或者自身出现过虚函数，那么就一定有一个虚函数表，虚函数在内存分配上，和普通函数没有区别。那虚函数表里面的函数地址指向函数的指针。子类做法如下：<br>1.先将基类的虚表中的内容拷贝一份（没错整个函数指针数组都要拷贝）<br>2.如果子类对基类中的虚函数进行重写，使用子类的函数指针替换相同偏移量位置的虚函数指针，使之指向重写的函数。<br>3.如果子类中新增加了虚函数，按照声明次序，放在基类虚函数，也就是扩展数组。</p>
<p>所以，虚函数换来多态的代价也就是缺点也暴露出来了：<br>1.效率降低了，多了一次虚表查找<br>2.加大了空间占用</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>闲谈SQLite</title>
    <url>/2020/03/24/%E9%97%B2%E8%B0%88SQLite/</url>
    <content><![CDATA[<p>用了几年的sqlite了，一直觉得好用，但是没去梳理其特性，下面我们开始总结一下这到底是一个什么东西，凭什么成为世界上部署最广泛的数据库？我们什么时候选择它呢？现在每个智能手机都有用到甚至每台手机都有数百个sqlite的db文件。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们可以从<a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">官网</a>看到，基本一句话总结就是：<strong>SQLite是一个用C语言开发的小型，快速，自包含（无依赖），高可靠，功能齐全的sql数据库引擎库。</strong>SQLite是开源的，这意味着您可以根据需要制作任意数量的副本，并可以不受限制地对这些副本进行任何操作，以作任何目的用途。但是SQLite不是开放贡献的，该项目不接受来自未知人员的补丁。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://sqlite.org/download.html" target="_blank" rel="noopener">官方发布版连接</a>选择对应版本下载即可。目前最新版本是<code>3.31.1</code>，下载下来源代码我们看到这是一个巨大的单文件<code>sqlite3.c</code>。其实是从<code>3.9.0</code>版本开始，sqlite库就将源代码102个c文件合并成1个了。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="占空间小"><a href="#占空间小" class="headerlink" title="占空间小"></a>占空间小</h3><p>有多小：目前版本源文件7M多,22w+行代码。编译后的动态库sqlite3.dll多大呢？600kb+（和编译器优化相关，但是一般在<code>600~800kb</code>）。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ol>
<li>最大支持数据库文件大小为140Tb($2^{47}$).</li>
<li>表最大行大小支持1Gb</li>
<li>读写blobs（块数据 ）的速度比<code>fread()/fwrite()</code>快35%。<blockquote>
<p>这个测试数据其实是测试随机生成快数据进行写db与系统写文件的比较。当文件数足够多的时候，系统写文件会越来越慢的。而db是一直在同一个文件扩充大小，所以速度略快，但是我们可以肯定的一点是写db与写文件速度是相当的。或者写同一个文件的话db并不会比写文件快。另外官方说读数据是android/macos的两倍，windows的十倍，但是这个测试方法没有去除文件查找时间。db的文件查找时间是肯定比操作系统要快的，取决于红黑树与B树的区别。</p>
</blockquote>
</li>
<li>0配置，随软件一起发布运行，无其他依赖与配置即可正常工作<h3 id="高可靠"><a href="#高可靠" class="headerlink" title="高可靠"></a>高可靠</h3></li>
<li>SQLite是事务数据库，所有更改与查询操作读是原子的。<blockquote>
<p>数据库不会因为程序崩溃、操作系统崩溃、停电引起数据库损坏；SQLite中单个事务中的所有更改要么完全发生，要么根本不发生，即使将更改写到磁盘的行为被中断了也是如此。</p>
</blockquote>
</li>
<li>稳定、持久的文件格式<br>db文件格式详细参考地址：<a href="https://sqlite.org/fileformat.html" target="_blank" rel="noopener">https://sqlite.org/fileformat.html</a>。</li>
</ol>
<h2 id="与mysql比较"><a href="#与mysql比较" class="headerlink" title="与mysql比较"></a>与mysql比较</h2><p>同是sql数据库，sqlite<br>优点：<br>1.轻量<br>2.便捷<br>3.写速度远快于mysql。<br>相较于mysql每秒不过 1,000 条的数据写入，sqlite能轻松达到 100,000 条/秒.</p>
<p>缺点：<br>1.无安全性可言<br>2.不支持远程访问<br>3.不支持存储过程等复杂事务（跨表的复杂查询上速度肯定不如mysql）</p>
<h2 id="与nosql比较"><a href="#与nosql比较" class="headerlink" title="与nosql比较"></a>与nosql比较</h2><p>优点：<br>1.有nosql相当的写速度的前提下，还支持sql。</p>
<p>缺点：<br>1.扩展性不如nosql<br>2.不能远程访问，不支持分布式集群等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，</p>
<ol>
<li>sqlite只适合做单机系统。</li>
<li>自行动态分库的话能支持很好的读、写、查询（不要一个文件干到底，虽然官方支持很大的文件）。</li>
<li>当内存支撑不够的时候，选择sqlite存储，是一个不错的选择。<blockquote>
<p>如：笔者曾做个的一个证券交易软件<code>万能菜单</code>的模块,既能满足复杂的模糊匹配，又有足够的效率，还不占内存，排序也自由，而且扩展也方便，非常适合。</p>
</blockquote>
</li>
<li>是数据持久化的一种选择，但是如果对数据安全要求较高不建议使用。</li>
</ol>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16配置samba共享文件夹</title>
    <url>/2020/03/21/ubuntu16%E9%85%8D%E7%BD%AEsamba%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。本文主要讲解Linux安装samba实现共享文件夹。</p>
<a id="more"></a>
<h2 id="samba安装"><a href="#samba安装" class="headerlink" title="samba安装"></a>samba安装</h2><h3 id="Linux切换国内软件源"><a href="#Linux切换国内软件源" class="headerlink" title="Linux切换国内软件源"></a>Linux切换国内软件源</h3><p>默认源是国外的，由于墙的原因速度极慢。建议切清华、腾讯、淘宝的软件源皆可。如清华源如下；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份现有源</span></span><br><span class="line">cp /etc/apt/source.list /etc/apt/source.list.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑源</span></span><br><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim 清空文件</span></span><br><span class="line">d G</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim 插入清华源，本人是Ubuntu16</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted univ    erse multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricte    d universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restric    ted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main r    estricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restr    icted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main     restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restri    cted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main     restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main rest    ricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<p><code>:wq#保存退出</code></p>
<h3 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更新软件源</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装samba</span></span><br><span class="line">sudo apt install samba</span><br><span class="line"><span class="comment"># 安装成功能查看版本号</span></span><br><span class="line">samba -V</span><br></pre></td></tr></table></figure>
<h2 id="sambap配置"><a href="#sambap配置" class="headerlink" title="sambap配置"></a>sambap配置</h2><p>打开配置文件 <code>sudo vim /etc/samba/smb.conf</code> 修改配置在文件末尾添加如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义共享目录</span></span><br><span class="line"><span class="comment"># 共享名:ubuntu16</span></span><br><span class="line">[ubuntu16]</span><br><span class="line"><span class="comment"># 需要密码访问</span></span><br><span class="line">comment = Share Folder require password</span><br><span class="line"><span class="comment"># 允许浏览</span></span><br><span class="line">browseable = yes</span><br><span class="line"><span class="comment"># 共享路径</span></span><br><span class="line">path = /home/share</span><br><span class="line"><span class="comment"># 新建文件的权限掩码</span></span><br><span class="line">create mask = 0777</span><br><span class="line"><span class="comment"># 新建文件夹的权限掩码</span></span><br><span class="line">directory mask = 0777</span><br><span class="line"><span class="comment"># samba登录的用户名</span></span><br><span class="line">valid users = zhangsan</span><br><span class="line"><span class="comment"># 可以使用nobody nogroup</span></span><br><span class="line">force user = zhangsan</span><br><span class="line">force group = zhangsan</span><br><span class="line"><span class="comment"># 是否公开允许可见</span></span><br><span class="line">public = yes</span><br><span class="line"><span class="comment"># 资源可写</span></span><br><span class="line">writable = yes</span><br><span class="line"><span class="comment"># 资源可用</span></span><br><span class="line">available = yes</span><br></pre></td></tr></table></figure>
<p>如果共享目录没有，应该在服务器新建,并赋予777权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/share</span><br><span class="line"></span><br><span class="line">sudo chown 777 /home/share</span><br></pre></td></tr></table></figure>

<h2 id="samba服务启动与查看"><a href="#samba服务启动与查看" class="headerlink" title="samba服务启动与查看"></a>samba服务启动与查看</h2><p>启动服务：<code>sudo /etc/init.d/samba start</code><br>重启服务：<code>sudo /etc/init.d/samba restart</code><br>停止服务：<code>sudo /etc/init.d/samba stop</code><br>通常我们安装完之后是自动启动的，所以改完配置只需执行上面的restart即可。<br>上面启动任务时，会启动3个服务：<code>nmbd.service</code>, <code>smbd.service</code>和 <code>samba-ad-dc.service</code>.我们可以通过下面的命令分别看它们的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nmbd status</span><br><span class="line"></span><br><span class="line">service smbd status</span><br><span class="line"></span><br><span class="line">service samba-ad-dc status</span><br></pre></td></tr></table></figure>
<h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>经过上面的步骤，不出意外已经可以使用win来访问ip了，如果设置了用户密码，会弹出用户名密码的验证框。<br>samba设置密码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为配置的用户添加密码</span></span><br><span class="line">sudo smbpasswd -a zhangsan(配置文件的用户名)</span><br><span class="line"><span class="comment">#input new password</span></span><br><span class="line"><span class="comment">#这个密码是samba用于验证登录用户的</span></span><br></pre></td></tr></table></figure>

<h2 id="在Windows上验证"><a href="#在Windows上验证" class="headerlink" title="在Windows上验证"></a>在Windows上验证</h2><p>在windows上验证后输入ip并新建文件夹/文件试试？<br><img src="share.png" alt=""></p>
<p><img src="newfile.png" alt=""><br>在Linux端查看显示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat 新建文件夹/新建文本文档.txt </span><br><span class="line">有点意思</span><br></pre></td></tr></table></figure>
<p>至此，我们已经可以正常使用samba了。也可以在Windows上创建虚拟磁盘，Windows操作步骤参考下图<br><img src="vShare.png" alt=""></p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议梳理之TCP</title>
    <url>/2020/03/15/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BTCP/</url>
    <content><![CDATA[<p>上文已经介绍了TCP和UDP同属于传输层协议，本文将简单介绍TCP，重点分析TCP的特性以及与UDP的区别，如何选择通信协议等。</p>
<h2 id="TCP介绍"><a href="#TCP介绍" class="headerlink" title="TCP介绍"></a>TCP介绍</h2><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向<strong>连接的、可靠的、基于字节流的传输层通信协议</strong>，由IETF的RFC 793定义。</p>
<a id="more"></a>
<p>TCP是一个应用非常广泛的传输层协议，也有很多应用层协议栈是在TCP的基础上封装的。TCP是基于ICMP,IP协议之上的封装。如下图<br><img src="protocols.gif" alt="常用协议图表" title="常用协议图表"><br>TCP/IP协议簇也是非常丰富，如下图：<br><img src="tcp_ip.gif" alt="TCP/IP协议簇" title="TCP/IP协议簇"></p>
<h2 id="TCP协议头详解"><a href="#TCP协议头详解" class="headerlink" title="TCP协议头详解"></a>TCP协议头详解</h2><p>IP协议头（20字节）<br><img src="ip.gif" alt="ip协议头" title="ip协议头"></p>
<h3 id="tcp协议头（20字节）"><a href="#tcp协议头（20字节）" class="headerlink" title="tcp协议头（20字节）"></a>tcp协议头（20字节）</h3><p><img src="tcp_head.png" alt="tcp协议头" title="tcp协议头"></p>
<ul>
<li><p>2字节源端口号</p>
</li>
<li><p>2字节目的端口号</p>
</li>
<li><p>4字节序列号</p>
<blockquote>
<p>发送字节流的起始字节序列号</p>
</blockquote>
</li>
<li><p>4字节确认号</p>
<blockquote>
<p>接收端期望接收的下一个字节序列号</p>
</blockquote>
</li>
<li><p>2字节标志位 </p>
<blockquote>
<ol>
<li>TCP头长度：占4bit，以 <code>4Byte</code> 为单位显示TCP头长，TCP协议头固定20Byte，因此length最小为5，选项部分最长40Byte，加上固定头长总共60Byte，所以length最大值为15，4bit刚刚好；</li>
<li>Resv：占4bit，预留；</li>
<li>CWR（Congestion Window Reduce）：发送端收到ECE置位的数据后进行设置，用来通知接收端已收到ECE标志的数据，了解了拥塞情况，接收端收到CWR置位消息后，不再设置ECE标志，同时发送端发送CWR信息时，将开始减小拥塞窗口，以此减小数据发送量，避免拥塞；</li>
<li>ECE（ECN ECHO）：网络拥塞一般出现在路由交换时，在支持ECN功能情况下，发生拥塞时路由会设置IP中该标志位，接收端收到IP头中标志了ECN的报文后，在返回的数据ACK中设置ECE标志，表示链路发生拥塞，将拥塞消息通知发送端；</li>
<li>URG：紧急标志，置位后不需要按照正常报文按序处理，执行<code>优先处理</code>；</li>
<li>ACK：确认标志；</li>
<li>PSH：将缓存中的数据以及当前psh报文一起执行推送，从缓存区发出去；</li>
<li>RST：强行复位标志，发送数据包出现错误时，TCP会发送该状态包；</li>
<li>SYN：请求建立连接时置位该标志，第一个握手报文携带；</li>
<li>FIN：请求连接关闭时置位该标志。</li>
</ol>
</blockquote>
</li>
<li><p>2字节窗口大小</p>
<blockquote>
<p>表示接收端接收缓存剩余大小</p>
</blockquote>
</li>
<li><p>2字节校验和</p>
<blockquote>
<p>包括TCP协议头与数据整体的校验字段</p>
</blockquote>
</li>
<li><p>2字节紧急指针</p>
<blockquote>
<p>标志位URG置位后使用，为一个正的偏移量，表示当前报文中起始字节开始需要偏移的长度，这个偏移到的字节就是紧急数据的结束字节，也就是通过偏移量确定了数据中需要紧急发送的字节个数，16bit；</p>
</blockquote>
</li>
<li><p>Opention</p>
<blockquote>
<p>一般用于握手时接收端，发送端信息的交互，以及数据交互过程中；最大40Byte；</p>
</blockquote>
</li>
</ul>
<p>通过协议头，TCP即可通过五元组来确定哪个数据包来自哪个客户端。$五元组 = 四元组+协议类型（tcp/udp）$组成。</p>
<blockquote>
<p>四元组：源IP，源端口，目标IP，目标端口<br>五元组与socket的fd是对应的<br>send数据：是通过fd找到相应的五元组信息<br>recv数据：是通过五元组找到相应fd的信息</p>
</blockquote>
<h3 id="TCP分段"><a href="#TCP分段" class="headerlink" title="TCP分段"></a>TCP分段</h3><p><strong>最大报文段长度<code>MSS</code>（Maximum Segment Size）</strong><br>收发双方协商通信时每一个报文段所能承载的最大数据长度。</p>
<p>$MSS = MTU - TCP头 - IP头$</p>
<p><strong>最大传输单元<code>MTU</code>(Maximum Transmission Unit)</strong><br>是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看MTU值,通常Linux默认是1500字节</span></span><br><span class="line">cat /sys/class/net/eth0/mtu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.  修改MTU值，为1460字节</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1460"</span> &gt; /sys/class/net/eth0/mtu</span><br></pre></td></tr></table></figure>
<p>相比于UDP那样直接丢，TCP有自动分段的功能，TCP会根据实际MTU大小自动分包发送，这也是TCP<font color=red>连接可靠</font>的一个保证。</p>
<h3 id="TCP和MTU的关系"><a href="#TCP和MTU的关系" class="headerlink" title="TCP和MTU的关系"></a>TCP和MTU的关系</h3><ul>
<li>MTU（Maximum Transmission Unit）是指通信协议的链路层上面所能通过的最大数据包大小，LINUX默认1500字节。</li>
<li>单个UDP传输的最大内容 <font color=red>$1460 = 1500 - 20 - 20$</font> 字节，但由于不同的网络中转设备设置的MTU值并不相同。 </li>
<li><code>Internet</code>上的标准MTU值为 <font color=red>$576$</font> 字节，TCP的数据包长度控制在 <font color=red>$536 = 576-20-20$</font> 字节以内； </li>
<li>局域网环境下，UDP的数据长度控制在$1460$个字节以内。</li>
</ul>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP建立连接的过程是需要三次握手的，三次握手由客户端执行connect开始触发，服务器执行accept完成连接。代码太简单，我们分析代码层看不到的东西，三次握手是怎么进行的？先看下图<br><img src="conn.png" alt=""><br><strong>第一次握手</strong>：client将标志位<code>SYN=1</code> 生成一个随机序列号<code>seq=J</code>发送<br><strong>第二次握手</strong>：server将标志位<code>SYN=1</code>, <code>ACK=1</code>； 然后将收到的序列号加1赋值给确认号<code>ack=J+1</code>,并将自己的序列号发送给客户端<code>seq=K</code><br><strong>第三次握手</strong>：client将标志位<code>ACK=1</code>, 然后将收到的序列号加1赋值给确认号<code>ack=K+1</code>发送<br>完成三次握手后，客户端，服务器才能都进入ESTABLESHED(已确立的)状态，才能进行收发数据。</p>
<p><em>为何是三次握手？两次行不行？</em><br>答：两次不行，如果两次握手就建立连接，那客户端发完请求就关闭了，服务器还认为客户端已建立连接，显然这是一个无效的连接，又或者客户端连续发起了两次连接，显然只有一个有效请求，但服务器却分辨不出以为是两个有效连接。所以，TCP作为一个可靠连接协议必然是三次握手。<font color=red>另外在我个人看来，要确定连接只需确定彼此双方都能收发数据就行，而三次握手正好可以表明双方都能收发成功。两次握手不能证明客户端能收到数据</font></p>
<blockquote>
<p>好比如下情景：<br>A:在吗？<br>B:在，你在吗？<br>A:我在(试想一下如果A不回复这句，B如何确定A还在？)</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>前面我们已经知道了3次握手可以确定TCP的连接，那TCP是如何断开连接的呢？没错，四次挥手。先看下面两张图<br>客户端主动发起断开连接（服务器主动发起也是一样）<br><img src="disconn.png" alt=""><br>第一次挥手：Client发送一个FIN，<font color=red>用来关闭Client到Server的数据传送</font>，Client进入<code>FIN_WAIT_1</code>状态。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<code>CLOSE_WAIT</code>状态。<br>第三次挥手：Server发送一个FIN，<font color=red>用来关闭Server到Client的数据传送</font>，Server进入<code>LAST_ACK</code>状态。<br>第四次挥手：Client收到FIN后，Client进入<code>TIME_WAIT</code>状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入<code>CLOSED</code>状态，完成四次挥手。<br>双发同时发起断开连接<br><img src="disconn2.png" alt=""><br>后面这个图不再写每次挥手的作用，因为基本和上一个图一样。可以总结的是：4次挥手之后，无论客户端或是服务器都将进入<code>TIME_WAIT状态</code>或者<code>CLOSED状态</code>z,这两个状态都有关闭的意思，那区别是什么呢？为什么需要两个关闭状态呢一个不就行了吗或者说干嘛不直接进入<code>CLOSED状态</code>？带着这两个疑问继续往下看。</p>
<h2 id="TCP状态装换图"><a href="#TCP状态装换图" class="headerlink" title="TCP状态装换图"></a>TCP状态装换图</h2><p><img src="tcp_status_trans.jpg" alt="TCP状态装换图" title="TCP状态装换图"></p>
<ol>
<li>CLOSED：这是最开始的状态</li>
<li>LISTEN：服务器调用<code>listen()</code>之后的状态</li>
<li>SYN_SENT：客户端发起连接请求之后的状态</li>
<li>SYN_RECV：服务器收到客户端连接请求之后的状态</li>
<li>ESTABLISHED：这是双方建立连接之后的状态，该状态即可正常收发数据了。</li>
<li>FIN_WAIT_1：调用<code>close()</code>(发送完FIN)后的状态</li>
<li>CLOS_WAIT：等待关闭状态，在ESTABLISHED状态收到FIN后进入的状态，回发FIN，发完进入LAST_ASK</li>
<li>FIN_WAIT_2：在FIN_WAIT_1的状态先收到ack，然后收到FIN后的状态</li>
<li>LAST_ASK: 最后确认状态，在CLOS_WAIT状态回发FIN之后进入的状态</li>
<li>TIME_WAIT：由FIN_WAIT_1/FIN_WAIT_2发送ACK后的状态,或者在CLOSING接收到ACK后的状态。总之这是一个挥手完成后的状态</li>
<li>CLOSING：在FIN_WAIT_1状态的时候先收到FIN，然后收到ack的状态</li>
</ol>
<p>握手触发前5个状态，挥手触发后6个状态。有上图可知，TCP真正的关闭状态才是CLOSED,而TIME_WAIT并非关闭状态，TIME_WAIT需要经过2MSL(Maximum Segment Lifetime 报文最大生存时间)超时才会变成CLOSED状态。<br><font color=red>RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟（这个和操作系统有关，Solaris2.2MSL是2分钟，测试方法就是用netstat命令查看状态变化需要时间/2即可。）<br>2MSL TIME_WAIT状态的存在有两个理由：</font></p>
<ol>
<li>让4次挥手关闭流程更加可靠；<blockquote>
<p>4次挥手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</p>
</blockquote>
</li>
<li>防止<code>lost duplicate</code>对后续新建正常链接的传输造成破坏。<blockquote>
<p><code>lost duplicate</code>在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL（time to live的缩写，存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机），限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p>
</blockquote>
</li>
</ol>
<h2 id="TCP可靠性的保证"><a href="#TCP可靠性的保证" class="headerlink" title="TCP可靠性的保证"></a>TCP可靠性的保证</h2><p>TCP采用一种名为“带重传功能的肯定确认（positive acknowledge with retransmission）”的技术作为提供可靠数据传输服务的基础。这项技术要求接收方收到数据之后回发确认信息ACK。发送方对发出的每个分组都暂存着，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP译名传输控制协议，而tcpsocket叫流式套接字。流式也就是告诉我们tcp的数据包是有先后顺序的，先发先到而这又是由滑动窗口来处理的，滑动窗口又是如何保证顺序的呢？</p>
<p>滑动窗口由两个索引，一前，一后，中间部分即为滑动窗口大小。<br>对于发送端：前索引表示的是已发送的位置，后索引表示不允许发送的位置<br>对于接收端：前索引表示的是已确认的位置，后索引表示不允许接收的位置</p>
<h3 id="窗口边沿移动"><a href="#窗口边沿移动" class="headerlink" title="窗口边沿移动"></a>窗口边沿移动</h3><ol>
<li>左边沿右边沿靠近，叫窗口合拢。数据被发送和确认时</li>
<li>右边沿向右移动，叫窗口张开。接收端读取已经确认的数据并释放了TCP的接收缓存时</li>
<li>右边沿左边沿靠近，叫窗口收缩。<strong>不建议</strong>，一但出现零窗口（窗口大小为0），发送方将不能发送任何数据，却占用着资源，如何解决这种占坑不工作的现象？请看后面的坚持定时器。</li>
</ol>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>发送窗口的大小是由拥塞计算出来的，先小后大，最后趋于稳定波动，这是动态计算的，这将影响TCP性能。对于以太网，默认大小是4kb，当文件传输的时候，调到16kb可以增加40%左右的吞吐量。</p>
<p><img src="tcp_wnd1.png" alt=""></p>
<p><img src="tcp_wnd2.png" alt=""></p>
<h2 id="拥塞避免算法和慢启动算法"><a href="#拥塞避免算法和慢启动算法" class="headerlink" title="拥塞避免算法和慢启动算法"></a>拥塞避免算法和慢启动算法</h2><p><strong>拥塞</strong><br>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。如何解决拥塞？</p>
<p><font color=red>慢启动算法是一个在连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法就是一种处理丢失分组的方法。这是两个目的不同、独立的算法，前者目的是减少输入流大小；后者目的是判断中间网络是否发生分组丢失（通过发生超时和接收到重复的确认，以此来判断分组丢失）。所以这两个算法通常用于一起实现。</font></p>
<p>slow start算法，通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。<br>慢启动为发送方的TCP增加了另一个窗口：<strong>拥塞窗口</strong>，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中最小值作为发送上限。<strong>拥塞窗口是发送方使用的流量控制，而通告窗口是接收方使用的流量控制</strong>。<br>    拥塞窗口以指数方式增加，在某一时刻可能发送速率达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开的过大。</p>
<p>这两个算法对每个连接维持两个变量，<strong>一个拥塞窗口cwnd和一个慢启动阈值ssthresh</strong>.假设窗口大小变量为wnd_size,下面详细分析一下拥塞发生过程。</p>
<ol>
<li>给定的连接，初始化<code>cwnd=1;ssthresh=65535;</code></li>
<li>tcp输出不能超过cwnd和接收方通告窗口的大小。</li>
<li>当拥塞发生时（超时或者收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd&gt;=2）.此外如果是超时引起的拥塞，则<code>cwnd=1;</code></li>
<li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于正在进行慢启动还是拥塞避免，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//个人整理的伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line">cwnd = <span class="number">1</span>;</span><br><span class="line">ssthresh = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//慢启动</span></span><br><span class="line"><span class="keyword">if</span>( cwnd &lt;= ssthresh )</span><br><span class="line">&#123;</span><br><span class="line">    慢启动；</span><br><span class="line">    <span class="keyword">if</span>( cwnd &lt; <span class="number">2</span>*ssthresh )</span><br><span class="line">        cwnd = cwnd &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cwnd++;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//执行拥塞避免，增速急剧下降</span></span><br><span class="line">    <span class="comment">//当所有窗口数据全部发出并收到ACK的时候，cwnd += 1;</span></span><br><span class="line">    <span class="comment">//否则 cwnd += 0;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get</span>(ACK))</span><br><span class="line">        cwnd += <span class="number">1</span>/cwnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以假设 cwnd == 32 拥塞发生</span></span><br><span class="line"><span class="keyword">if</span>( cwnd&gt;? 拥塞发生)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(重复确认导致)</span><br><span class="line">    &#123;</span><br><span class="line">        ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line">        cwnd = ssthresh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(超时导致)</span><br><span class="line">    &#123;</span><br><span class="line">        cwnd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下图是慢启动和拥塞避免的一个可视化描述。我们以段为单位来显示cwnd和ssthresh，但它们实际上都是以字节为单位进行维护的。<br><img src="slowstart.jpg" alt=""><br>在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置 ssthresh为16个报文段，而cwnd为1个报文段。在时刻 0发送了一个报文段，并假定在时刻 1接收到它的 ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻 3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起， cwnd以线性方式增加，在<code>每个往返时间内</code>(窗口全部数据包被发出并收到ACK的时间)最多增加 1个报文段。<br>正如我们在这个图中看到的那样，术语“慢启动”并不完全正确。它只是采用了比引起拥塞更慢些的分组传输速率，但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。只有在达到ssthresh拥塞避免算法起作用时，这种增加的速率才会慢下来。</li>
</ol>
<h2 id="TCP的七种定时器"><a href="#TCP的七种定时器" class="headerlink" title="TCP的七种定时器"></a>TCP的七种定时器</h2><ol>
<li>建立连接定时器(connection-establishment timer)</li>
<li>重传定时器(retransmission timer)</li>
<li>延迟应答定时器(delayed ACK timer)</li>
<li>坚持定时器(persist timer)</li>
<li>保活定时器(keepalive timer)</li>
<li>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</li>
<li>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</li>
</ol>
<p>TCP的定时器是TCP协议很重呀的一个部分，我认为是TCP最难理解的地方了，搞清楚了定时器的运转，TCP的很多机制将会迎刃而解。<font color=red>个人理解的定时器的设计：连接时防止SYN丢失需要1个定时器，断开时FIN丢失和ACK丢失两个定时器，数据传输过程中4个定时器：包括窗口大小探测1个定时器，数据超时发送重传需要一个定时器，数据延时应答一个定时器（只有这个定时器是为了提升效率的，其他都是保证传输可靠的），防止长时间不工作的连接浪费资源需要一个保活定时器。</font></p>
<h3 id="建立连接定时器-connection-establishment-timer"><a href="#建立连接定时器-connection-establishment-timer" class="headerlink" title="建立连接定时器(connection-establishment timer)"></a>建立连接定时器(connection-establishment timer)</h3><p>顾名思义，这个定时器是在建立连接的时候使用的， 我们知道， TCP建立连接需要3次握手。<br>建立连接的过程中，在发送SYN时， 会启动一个定时器(默认应该是3秒)，如果SYN包丢失了， 那么3秒以后会重新发送SYN包的(当然还会启动一个新的定时器， 设置成6秒超时)，当然也不会一直没完没了的发SYN包， 在 <code>/proc/sys/net/ipv4/tcp_syn_retries</code> 可以设置到底要重新发送几次SYN包。</p>
<h3 id="重传定时器-retransmission-timer"><a href="#重传定时器-retransmission-timer" class="headerlink" title="重传定时器(retransmission timer)"></a>重传定时器(retransmission timer)</h3><p>重传定时器在TCP发送数据时设定，在计时器超时后没有收到返回的确认ACK，发送端就会重新发送队列中需要重传的报文段。使用RTO(Retransmission Timeout超时重传)超时重传计时器一般有如下规则：</p>
<ol>
<li>当TCP发送了位于发送队列最前端的报文段后就启动这个RTO计时器；</li>
<li>如果队列为空则停止计时器，否则重启计时器；</li>
<li>当计时器超时后，TCP会重传发送队列最前端的报文段；</li>
<li>当一个或者多个报文段被累计确认后，这个或者这些报文段会被清除出队列</li>
</ol>
<p>重传计时器保证了接收端能够接收到丢失的报文段，继而保证了接收端交付给接收进程的数据始终的有序完整的。因为接收端永远不会把一个失序不完整的报文段交付给接收进程。</p>
<h3 id="延迟应答定时器-delayed-ACK-timer"><a href="#延迟应答定时器-delayed-ACK-timer" class="headerlink" title="延迟应答定时器(delayed ACK timer)"></a>延迟应答定时器(delayed ACK timer)</h3><p>延迟应答也被成为捎带ACK， 这个定时器是在延迟应答的时候使用的。 为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。</p>
<p>举例说明，比如服务端收到客户端的数据后， 不是立刻回ACK给客户端， 而是等一段时间(一般最大200ms)，这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了， 这样比立即回给客户端一个ACK节省了一个数据包。</p>
<h3 id="坚持定时器-persist-timer"><a href="#坚持定时器-persist-timer" class="headerlink" title="坚持定时器(persist timer)"></a>坚持定时器(persist timer)</h3><p>我们已经知道TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。接收端窗口变为非0后，就会发送一个确认ACK指明需要的报文段序号以及窗口大小。</p>
<p>如果这个确认ACK丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 (window probe)。</p>
<h3 id="保活定时器-keepalive-timer"><a href="#保活定时器-keepalive-timer" class="headerlink" title="保活定时器(keepalive timer)"></a>保活定时器(keepalive timer)</h3><p>在TCP连接建立的时候指定了SO_KEEPALIVE，保活定时器才会生效。如果客户端和服务端长时间没有数据交互，那么需要保活定时器来判断是否对端还活着，但是这个其实很不实用，因为默认是2小时(<code>cat /proc/sys/net/ipv4/tcp_keepalive_time</code>)没有数据交互才探测，时间实在是太长了。如果你真的要确认对端是否活着， 那么应该自己实现心跳包，而不是依赖于这个保活定时器。</p>
<h3 id="FIN-WAIT-2定时器-FIN-WAIT-2-timer"><a href="#FIN-WAIT-2定时器-FIN-WAIT-2-timer" class="headerlink" title="FIN_WAIT_2定时器(FIN_WAIT_2 timer)"></a>FIN_WAIT_2定时器(FIN_WAIT_2 timer)</h3><p>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN，主动关闭的一端总不能一直傻等着，占着资源不撒手吧？这个时候就需要FIN_WAIT_2定时器出马了， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么不好意思， 不等了， 直接释放这个链接。FIN_WAIT_2定时器的时间可以从<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>中查看和设置。</p>
<h3 id="TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer"><a href="#TIME-WAIT定时器-TIME-WAIT-timer-也叫2MSL-timer" class="headerlink" title="TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)"></a>TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)</h3><p>TIME_WAIT是主动关闭连接的一端最后进入的状态， 而不是直接变成CLOSED的状态， 为什么呢？第一个原因是万一被动关闭的一端在超时时间内没有收到最后一个ACK， 则会重发最后的FIN，2MSL（报文段最大生存时间）等待时间保证了重发的FIN会被主动关闭的一端收到且重新发送最后一个ACK；另外一个原因是在2MSL等待时间时，任何迟到的报文段会被接收并丢弃，防止老的TCP连接的包在新的TCP连接里面出现。不可避免的，在这个2MSL等待时间内，不会建立同样(源IP, 源端口，目的IP，目的端口)的连接。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><em>1. 什么时候给对端发送确认消息？</em></p>
<blockquote>
<p>确认重传，接收端确认最小序号的包重传如：ack number=5,对方就会从5号包开始将窗口内的剩余数据全部重传一遍。这也导致了有些包被重传多次。</p>
</blockquote>
<p><em>2. 确认消息应该发送多少？</em></p>
<blockquote>
<p>只发送序号最小的包，但是回，却是回从最小序号开始到窗口尾端的包。</p>
</blockquote>
<p><em>3. 为何不只重传没收到的包，已收到的不重传？</em></p>
<blockquote>
<p>就TCP现有机制来说，实现难度太大。</p>
</blockquote>
<p><em>4. 有了TCP，为何还要UDP的可靠传输？</em></p>
<blockquote>
<p>也因为<code>延时确认</code>，tcp牺牲了一定量的实时性及带宽，对于游戏而言，UDP的可靠传输就应用更多了，UDP是实时性的。</p>
</blockquote>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议梳理之UDP</title>
    <url>/2020/03/14/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86%E4%B9%8BUDP/</url>
    <content><![CDATA[<p>计划用两篇文章梳理一下ip，upd，tcp协议，重点放在后两者，因为后两者目前在应用上非常广，可编程性也大很多，本文将重点介绍UDP协议。</p>
<h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><p>UDP又名用户数据报协议（User Datagram Protocol）。UDP 为应用程序提供了一种<strong>无需建立连接就可以发送封装的 IP 数据包的协议</strong>，可知UDP是基于IP协议的。</p>
<a id="more"></a>

<h3 id="UDP对应的网络层"><a href="#UDP对应的网络层" class="headerlink" title="UDP对应的网络层"></a>UDP对应的网络层</h3><p>OSI七层网络模型中：属于第4层——传输层协议</p>
<p>TCP/IP四层模型中：属于第3层——运输层协议</p>
<p>如下图：我们可以看出UDP和TCP是处于同一层的。<br><img src="osi.png" alt=""></p>
<h3 id="UDP-IP协议头"><a href="#UDP-IP协议头" class="headerlink" title="UDP/IP协议头"></a>UDP/IP协议头</h3><p><img src="ipHead.jpg" alt="IP协议头" title="IP协议头"></p>
<center>IP协议头</center>

<p><img src="udpHead.jpg" alt="UDP协议头" title="UDP协议头"></p>
<center>UDP协议头</center>

<p>有上图可知一个完整的UDP头是由<code>20字节IP协议头</code> + <code>8字节UDP协议头</code>组成，总长度：28个字节。 </p>
<blockquote>
<p>16位源端口号：1 ~ 65535<br>16位目标端口号：1 ~ 65535<br>16位数据报长度：65535字节=64kb<br>16位校验和：目的是防止数据报被更改。</p>
</blockquote>
<p><font color=red>所以，一个UDP包长度不能超过64kb，超过64kb数据，我们必须分包发送。否则，多余的数据会被直接丢掉，导致接收端接收数据不完整。</font>那什么时候适合用UDP呢？</p>
<h3 id="UDP的应用场景"><a href="#UDP的应用场景" class="headerlink" title="UDP的应用场景"></a>UDP的应用场景</h3><p>采用UDP有3个关键点：</p>
<ul>
<li>网络带宽需求较小，而实时性要求高；</li>
<li>大部分应用无需维持连接； </li>
<li>需要低功耗。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>网页浏览：新浪微博就已经用了QUIC协议 </li>
<li>流媒体：WebRTC就是基于UDP的， </li>
<li>实时游戏：Unity3D采用的RakNet也是基于UDP的协议</li>
</ul>
<h3 id="尽量避免IP分片"><a href="#尽量避免IP分片" class="headerlink" title="尽量避免IP分片"></a>尽量避免IP分片</h3><p><strong>IP层是没有超时重传机制的</strong>，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于 传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大；公网传输，需要经过多个网络设备，IP分片容易造成丢包。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。那我们只能重上层减少包大小，下面将介绍UDP如何分片和重组。</p>
<h2 id="UDP分片与重组"><a href="#UDP分片与重组" class="headerlink" title="UDP分片与重组"></a>UDP分片与重组</h2><h3 id="UDP分片原理"><a href="#UDP分片原理" class="headerlink" title="UDP分片原理"></a>UDP分片原理</h3><ol>
<li>对应用层的数据进行分片，以满足MTU传输的要求 </li>
<li>在发送端给分片编号，在接收端重组分片，解决乱序数据包重组的问题</li>
</ol>
<h3 id="UDP和MTU的关系"><a href="#UDP和MTU的关系" class="headerlink" title="UDP和MTU的关系"></a>UDP和MTU的关系</h3><ul>
<li>MTU（Maximum Transmission Unit）是指通信协议的链路层上面所能通过的最大数据包大小，LINUX默认1500字节。</li>
<li>单个UDP传输的最大内容 <font color=red>$1472 = 1500 - 20 - 8$</font> 字节，但由于不同的网络中转设备设置的MTU值并不相同。 </li>
<li><code>Internet</code>上的标准MTU值为 <font color=red>$576$</font> 字节，UDP的数据长度控制在 <font color=red>$548 = 576-8-20$</font> 字节以内； </li>
<li>局域网环境下，UDP的数据长度控制在$1472$个字节以内。</li>
</ul>
<h3 id="UDP协议格式"><a href="#UDP协议格式" class="headerlink" title="UDP协议格式"></a>UDP协议格式</h3><table>
<thead>
<tr>
<th>IP头</th>
<th>UDP头</th>
<th>报文</th>
</tr>
</thead>
<tbody><tr>
<td>20字节</td>
<td>8字节</td>
<td>UDP数据</td>
</tr>
</tbody></table>
<h3 id="UDP分片实现"><a href="#UDP分片实现" class="headerlink" title="UDP分片实现"></a>UDP分片实现</h3><p>如何实现分片？每个分片应该有哪些信息？下面我们用一个图来搞定。<br><img src="udp_peice.png" alt=""><br><font color=red>注意：如果同时接收多个client，上图分片有什么问题？</font></p>
<p>两种处理方式：</p>
<ol>
<li>我们应该注意到每个<code>clientid</code>，都应该对应一个环形缓冲区才行。</li>
<li>如果共用一个环形缓冲区，我们应该在分片的时候加上<code>clientid</code>以做区分。</li>
</ol>
<h3 id="源代码实现"><a href="#源代码实现" class="headerlink" title="源代码实现"></a>源代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp-piece.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UDP_PIECE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UDP_PIECE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circular_buffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_SYNC_WORD		0	<span class="comment">// 同步字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_TOTAL_SIZE 	2	<span class="comment">// 所有分片数据的大小（不包括HEAD） //total data length of all pieces</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_TOTAL_PIECES 	4 	<span class="comment">// 所有分片的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_P_INDEX 		6 	<span class="comment">// 分片序号，从0开始</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_POS_P_LENGTH 		8 	<span class="comment">// 当前分片数据的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_SIZE 				12	<span class="comment">// 头部大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIECE_FIX_SIZE 			(576 - 8 - 20 - 12)UL 	<span class="comment">//internat MTU - UDP_head - IP_head - 分片头</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_piece</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recv_pieces;			<span class="comment">// 当前已经接收的分片数量</span></span><br><span class="line">    <span class="keyword">int</span> total_size;				<span class="comment">// 总数据大小</span></span><br><span class="line">    <span class="keyword">int</span> total_pieces;			<span class="comment">// 分片总数量</span></span><br><span class="line">    <span class="keyword">int</span> left;					<span class="comment">// 最后一片的大小</span></span><br><span class="line">    <span class="keyword">int</span> piece_size;				<span class="comment">// 分片大小</span></span><br><span class="line">    <span class="keyword">int</span> recv_len;				<span class="comment">// 接收数据的长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *recv_buf;			<span class="comment">// 保存接收数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span>	*send_ptr;			<span class="comment">// 指向发送数据的buffer</span></span><br><span class="line">    <span class="keyword">uint8_t</span> piece_buf[PIECE_FIX_SIZE+HEAD_SIZE+<span class="number">1</span>];	<span class="comment">//单帧的buffer</span></span><br><span class="line">    <span class="keyword">circular_buffer_t</span> *circular_buffer;	<span class="comment">// 环形缓存</span></span><br><span class="line">&#125;<span class="keyword">udp_piece_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化资源</span></span><br><span class="line"><span class="comment"> * @param buf_size 设置环形缓冲区数据的最大长度</span></span><br><span class="line"><span class="comment"> * @return 成功则返回一个句柄，失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">udp_piece_t</span> *<span class="title">udp_piece_init</span><span class="params">(<span class="keyword">int</span> buf_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放资源</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_deinit</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重置，这里不会重新分配资源，只是讲部分参数重置到初始化状态</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_reset</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据长度进行切割，返回切割后的分片数量</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf       要分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size      要分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回分片的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_cut</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据分片编号获取切片指针及分片数据大小</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param index     分片编号</span></span><br><span class="line"><span class="comment"> * @param got_piece_size 获取指定编号分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回指定分片编号的数据指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">udp_piece_get</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">int</span> index, <span class="keyword">int</span> *got_piece_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片，使用环形缓存</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge_ex</span><span class="params">(<span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* end of __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//udp_piece.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udp-piece.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_ERR		printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_DEBUG	printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化资源</span></span><br><span class="line"><span class="comment"> * @param buf_size 设置缓冲区数据的最大长度</span></span><br><span class="line"><span class="comment"> * @return 成功则返回一个句柄，失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">udp_piece_t</span>* <span class="title">udp_piece_init</span><span class="params">( <span class="keyword">int</span> buf_size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">udp_piece_t</span> *udp_piece = (<span class="keyword">udp_piece_t</span> *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">udp_piece_t</span>) );</span><br><span class="line">    <span class="keyword">if</span> ( !udp_piece )</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memset</span>( udp_piece, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">udp_piece_t</span>) );</span><br><span class="line"></span><br><span class="line">    udp_piece-&gt;circular_buffer = circular_buffer_init( buf_size );</span><br><span class="line">    <span class="keyword">if</span> ( !udp_piece-&gt;circular_buffer )</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(udp_piece);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放资源</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_deinit</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 释放资源 */</span></span><br><span class="line">    <span class="keyword">if</span> ( udp_piece )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">            <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">        udp_piece-&gt;recv_buf	= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;recv_pieces	= <span class="number">0</span>;</span><br><span class="line">        udp_piece-&gt;total_size	= <span class="number">0</span>;    <span class="comment">/* 总数据大小 */</span></span><br><span class="line">        udp_piece-&gt;total_pieces = <span class="number">0</span>;    <span class="comment">/* 分片总数量 */</span></span><br><span class="line">        udp_piece-&gt;left		= <span class="number">0</span>;    	<span class="comment">/* 最后一片的大小 */</span></span><br><span class="line">        udp_piece-&gt;piece_size	= <span class="number">0</span>;    <span class="comment">/* 分片大小 */</span></span><br><span class="line">        udp_piece-&gt;recv_len	= <span class="number">0</span>;</span><br><span class="line">        circular_buffer_deinit( udp_piece-&gt;circular_buffer );</span><br><span class="line">        udp_piece-&gt;circular_buffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重置，这里不会重新分配资源，只是讲部分参数重置到初始化状态</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_piece_reset</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 数据重置 */</span></span><br><span class="line">    <span class="keyword">if</span> ( udp_piece )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">            <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">        udp_piece-&gt;recv_buf	= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;send_ptr		= <span class="literal">NULL</span>;</span><br><span class="line">        udp_piece-&gt;recv_pieces	= <span class="number">0</span>;</span><br><span class="line">        udp_piece-&gt;total_size	= <span class="number">0</span>;    <span class="comment">/* 总数据大小 */</span></span><br><span class="line">        udp_piece-&gt;total_pieces = <span class="number">0</span>;    <span class="comment">/* 分片总数量 */</span></span><br><span class="line">        udp_piece-&gt;left		= <span class="number">0</span>;    <span class="comment">/* 最后一片的大小 */</span></span><br><span class="line">        udp_piece-&gt;piece_size	= <span class="number">0</span>;    <span class="comment">/* 分片大小 */</span></span><br><span class="line">        udp_piece-&gt;recv_len	= <span class="number">0</span>;</span><br><span class="line">        circular_buffer_reset( udp_piece-&gt;circular_buffer );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据长度进行切割，返回切割后的分片数量</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf       要分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size      要分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回分片的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_cut</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!udp_piece || <span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    udp_piece-&gt;send_ptr = buf;</span><br><span class="line">    udp_piece-&gt;total_size = <span class="built_in">size</span>;</span><br><span class="line">    udp_piece-&gt;left = <span class="built_in">size</span> % PIECE_FIX_SIZE;	<span class="comment">// 最后一个分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;total_pieces = </span><br><span class="line">        (udp_piece-&gt;left &gt; <span class="number">0</span>) ? (<span class="built_in">size</span> / PIECE_FIX_SIZE + <span class="number">1</span>) :(<span class="built_in">size</span> / PIECE_FIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> udp_piece-&gt;total_pieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据分片编号获取切片指针及分片数据大小</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param index     分片编号</span></span><br><span class="line"><span class="comment"> * @param got_piece_size 获取指定编号分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return 返回指定分片编号的数据指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">udp_piece_get</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">int</span> index, <span class="keyword">int</span> *got_piece_size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> piece_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!udp_piece || !got_piece_size &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *got_piece_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片大小</span></span><br><span class="line">    <span class="keyword">if</span>(((udp_piece-&gt;total_pieces - <span class="number">1</span>) == index)		<span class="comment">// 是不是最后一个分片</span></span><br><span class="line">        &amp;&amp; (udp_piece-&gt;left &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        piece_size = udp_piece-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;	</span><br><span class="line">        piece_size = PIECE_FIX_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>( udp_piece-&gt;piece_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(udp_piece-&gt;piece_buf) );</span><br><span class="line">    <span class="comment">// 填充分片帧头</span></span><br><span class="line">    <span class="comment">// 同步字</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_SYNC_WORD] = <span class="number">0xAF</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_SYNC_WORD + <span class="number">1</span>] = <span class="number">0xAE</span>;</span><br><span class="line">    <span class="comment">// 所有分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_SIZE] = udp_piece-&gt;total_size &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_SIZE + <span class="number">1</span>] = (udp_piece-&gt;total_size &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 所有分片的数量</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_PIECES] = udp_piece-&gt;total_pieces &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_TOTAL_PIECES + <span class="number">1</span>] = (udp_piece-&gt;total_pieces &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 分片编号，从0开始</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_INDEX] = index &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_INDEX + <span class="number">1</span>] = (index &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="comment">// 分片数据的大小</span></span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_LENGTH] = piece_size &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    udp_piece-&gt;piece_buf[HEAD_POS_P_LENGTH + <span class="number">1</span>] = (piece_size &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把用户数据拷贝到分片数据区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;udp_piece-&gt;piece_buf[HEAD_SIZE], &amp;udp_piece-&gt;send_ptr[PIECE_FIX_SIZE * index], piece_size);</span><br><span class="line">    *got_piece_size = piece_size + HEAD_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> udp_piece-&gt;piece_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *piece_buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_total_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_total_pieces = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> get_all_pieces = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测头部是否有同步字</span></span><br><span class="line">    piece_buf = buf;</span><br><span class="line">    temp_size = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((piece_buf[<span class="number">0</span>] == <span class="number">0xAF</span>) &amp;&amp; (piece_buf[<span class="number">1</span>] == <span class="number">0xAE</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        piece_buf++;</span><br><span class="line">        temp_size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果检测到同步字，且剩余数据长度还超过 分片帧头长度</span></span><br><span class="line">    <span class="keyword">while</span> (temp_size &gt; HEAD_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前分片的数据长度</span></span><br><span class="line">        <span class="keyword">int</span> data_len = (piece_buf[HEAD_POS_P_LENGTH] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_P_LENGTH+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(temp_size &gt;= (HEAD_SIZE + data_len))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取分片编号</span></span><br><span class="line">            p_index = (piece_buf[HEAD_POS_P_INDEX] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_P_INDEX+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(udp_piece-&gt;total_size == <span class="number">0</span>)		<span class="comment">// 重置后第一次收到数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取分片数据的总大小</span></span><br><span class="line">                udp_piece-&gt;total_size = (piece_buf[HEAD_POS_TOTAL_SIZE] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_SIZE+<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 获取总的分片数量</span></span><br><span class="line">                udp_piece-&gt;total_pieces = (piece_buf[HEAD_POS_TOTAL_PIECES] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_PIECES+<span class="number">1</span>]);</span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces  = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_buf)</span><br><span class="line">                    <span class="built_in">free</span>(udp_piece-&gt;recv_buf);</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>(udp_piece-&gt;total_size + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"malloc recv_buf filed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UDP_DEBUG( <span class="string">"buf size: %d, piece_data_len: %d, p_index: %d, recv_pieces: %d, total_size: %d, total_pieces: %d\n"</span>,</span><br><span class="line">                   temp_size, data_len, p_index, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, udp_piece-&gt;total_pieces );</span><br><span class="line">            temp_total_size = (piece_buf[HEAD_POS_TOTAL_SIZE] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_SIZE+<span class="number">1</span>]);</span><br><span class="line">            temp_total_pieces = (piece_buf[HEAD_POS_TOTAL_PIECES] &lt;&lt; <span class="number">8</span>) + (piece_buf[HEAD_POS_TOTAL_PIECES+<span class="number">1</span>]);</span><br><span class="line">            udp_piece-&gt;recv_pieces++;</span><br><span class="line">            <span class="comment">// 分析下新的分片是否和原来的分片组有区别</span></span><br><span class="line">            <span class="keyword">if</span>((temp_total_size != udp_piece-&gt;total_size) || (temp_total_pieces != udp_piece-&gt;total_pieces))</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_size = temp_total_size;</span><br><span class="line">                udp_piece-&gt;total_pieces = temp_total_pieces;</span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_buf)</span><br><span class="line">                    <span class="built_in">free</span>(udp_piece-&gt;recv_buf);</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>(udp_piece-&gt;total_size + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"malloc recv_buf filed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            piece_buf += HEAD_SIZE;</span><br><span class="line">            temp_size -= HEAD_SIZE;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;udp_piece-&gt;recv_buf[PIECE_FIX_SIZE * p_index], piece_buf, data_len);</span><br><span class="line">            piece_buf += data_len;</span><br><span class="line">            temp_size -= data_len;</span><br><span class="line"></span><br><span class="line">            udp_piece-&gt;recv_len += data_len;		<span class="comment">// 分片数据的累加</span></span><br><span class="line">            <span class="keyword">if</span>(udp_piece-&gt;recv_pieces == udp_piece-&gt;total_pieces)</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_pieces = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(udp_piece-&gt;recv_len == udp_piece-&gt;total_size)</span><br><span class="line">                &#123;</span><br><span class="line">                    get_all_pieces = <span class="number">1</span>;		<span class="comment">// 把所有分片组成完整的数据帧</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"recv_len != total_size! recv_len: %d, total_size: %d"</span>, udp_piece-&gt;recv_len, udp_piece-&gt;total_size );</span><br><span class="line">                    get_all_pieces = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_all_pieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重组分片，使用环形缓存</span></span><br><span class="line"><span class="comment"> * @param udp_piece 句柄</span></span><br><span class="line"><span class="comment"> * @param buf   分片数据的指针</span></span><br><span class="line"><span class="comment"> * @param size  分片数据的长度</span></span><br><span class="line"><span class="comment"> * @return  返回-1则重组失败，返回0则正在重组中，返回1则重组成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_piece_merge_ex</span><span class="params">( <span class="keyword">udp_piece_t</span> *udp_piece, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>	tmp_total_size		= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>	tmp_total_pieces	= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>	p_index	= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>	get_all_pieces = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>	bytes_to_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>	bytes_to_read  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>		value0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>		value1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bytes_to_write = circular_buffer_write( udp_piece-&gt;circular_buffer, buf, <span class="built_in">size</span> );</span><br><span class="line">    <span class="keyword">if</span> ( bytes_to_write != <span class="built_in">size</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        UDP_ERR( <span class="string">"%s(%d) There is not enough space, only %d bytes, but need %d bytes\n"</span>,</span><br><span class="line">             __FUNCTION__, __LINE__, bytes_to_write, <span class="built_in">size</span> );</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从新收到的数据检测是否包含 片头</span></span><br><span class="line"><span class="comment">     * 检测头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, <span class="number">0</span>, &amp;value0 );          <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, <span class="number">1</span>, &amp;value1 );</span><br><span class="line">        <span class="keyword">if</span> ( value0 == <span class="number">0xAF</span> &amp;&amp; value1 == <span class="number">0xAE</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            circular_buffer_pop_front( udp_piece-&gt;circular_buffer, <span class="number">1</span>);        <span class="comment">/* 出队列一个元素 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果剩余的数据长度仍大于于 */</span></span><br><span class="line">    <span class="keyword">while</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt; HEAD_SIZE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前分片的数据长度（不含帧头） */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_LENGTH, &amp;value0 ); <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">        circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_LENGTH + <span class="number">1</span>, &amp;value1 );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> data_len = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">        <span class="comment">//data_len	&lt;&lt;= 8;</span></span><br><span class="line">        <span class="comment">//data_len	+= value1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* UDP_DEBUG("%s(%d)\n", __FUNCTION__, __LINE__); */</span></span><br><span class="line">        <span class="keyword">if</span> ( circular_buffer_size( udp_piece-&gt;circular_buffer ) &gt;= (HEAD_SIZE + data_len) )</span><br><span class="line">        &#123;</span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_INDEX, &amp;value0 );                   <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_P_INDEX + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            p_index = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">            <span class="keyword">if</span> ( udp_piece-&gt;total_size == <span class="number">0</span> )                                                               <span class="comment">/* 重置后第一次收到分片 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 计算当前分片所属分片组数据的总大小 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE, &amp;value0 );        <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">                udp_piece-&gt;total_size = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 计算当前分片所属分片组的总分片数量 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES, &amp;value0 );      <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">                circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">                udp_piece-&gt;total_pieces = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 重置当前接收分片的数量 */</span></span><br><span class="line">                udp_piece-&gt;recv_pieces = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* 重置当前接收到的数据长度 */</span></span><br><span class="line">                udp_piece-&gt;recv_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* 如果缓存区有数据则先释放 */</span></span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">                    <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">                <span class="comment">/* 分配能够存储一个分片组所有的数据的空间 */</span></span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>( udp_piece-&gt;total_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UDP_DEBUG( <span class="string">"buf size: %d, piece_data_len: %d, p_index: %d, recv_pieces: %d, total_size: %d, total_pieces: %d"</span>,</span><br><span class="line">                   circular_buffer_size( udp_piece-&gt;circular_buffer ), data_len, p_index, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, udp_piece-&gt;total_pieces );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算当前分片所属分片组数据的总大小 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE, &amp;value0 );        <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_SIZE + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            tmp_total_size = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算当前分片所属分片组的总分片数量 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES, &amp;value0 );      <span class="comment">/* 通过索引获取当前值 */</span></span><br><span class="line">            circular_buffer_get( udp_piece-&gt;circular_buffer, HEAD_POS_TOTAL_PIECES + <span class="number">1</span>, &amp;value1 );</span><br><span class="line">            tmp_total_pieces = (value0 &lt;&lt; <span class="number">8</span>) + value1;</span><br><span class="line">            udp_piece-&gt;recv_pieces++;</span><br><span class="line">            <span class="keyword">if</span> ( (tmp_total_pieces != udp_piece-&gt;total_pieces) || (tmp_total_size != udp_piece-&gt;total_size) )</span><br><span class="line">            &#123;</span><br><span class="line">                UDP_DEBUG( <span class="string">"Discard current frame, total_pieces:%d, cur_total_pieces:%d, recv_pieces:%d, total_size:%d, cur_total_size:%d\n"</span>,</span><br><span class="line">                       udp_piece-&gt;total_pieces, tmp_total_pieces, udp_piece-&gt;recv_pieces, udp_piece-&gt;total_size, tmp_total_size );</span><br><span class="line">                <span class="comment">/* one piece of a new frame is coming, reset the variables */</span></span><br><span class="line">                udp_piece-&gt;total_size	= tmp_total_size;</span><br><span class="line">                udp_piece-&gt;total_pieces = tmp_total_pieces;</span><br><span class="line">                udp_piece-&gt;recv_pieces	= <span class="number">1</span>;</span><br><span class="line">                udp_piece-&gt;recv_len	= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_buf )</span><br><span class="line">                    <span class="built_in">free</span>( udp_piece-&gt;recv_buf );</span><br><span class="line">                udp_piece-&gt;recv_buf = <span class="built_in">malloc</span>( udp_piece-&gt;total_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( !udp_piece-&gt;recv_buf )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将帧头出队列</span></span><br><span class="line">            circular_buffer_pop_front( udp_piece-&gt;circular_buffer, HEAD_SIZE);</span><br><span class="line">            <span class="comment">// 读取分片数据</span></span><br><span class="line">            bytes_to_read = circular_buffer_read( udp_piece-&gt;circular_buffer,</span><br><span class="line">                                  &amp;udp_piece-&gt;recv_buf[PIECE_FIX_SIZE * p_index],</span><br><span class="line">                                  data_len );</span><br><span class="line">            <span class="keyword">if</span> ( bytes_to_read != data_len )</span><br><span class="line">            &#123;</span><br><span class="line">                UDP_ERR( <span class="string">"%s(%d) There is not enough space, only %d bytes, but need %d bytes\n"</span>,</span><br><span class="line">                     __FUNCTION__, __LINE__, bytes_to_write, <span class="built_in">size</span> );</span><br><span class="line">                <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            UDP_DEBUG( <span class="string">"remain size = %d\n"</span>, circular_buffer_size( udp_piece-&gt;circular_buffer ) );</span><br><span class="line"></span><br><span class="line">            udp_piece-&gt;recv_len += data_len;</span><br><span class="line">            <span class="keyword">if</span> ( udp_piece-&gt;recv_pieces == udp_piece-&gt;total_pieces )</span><br><span class="line">            &#123;</span><br><span class="line">                udp_piece-&gt;total_pieces = <span class="number">0</span>;</span><br><span class="line">                udp_piece-&gt;recv_pieces	= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( udp_piece-&gt;recv_len == udp_piece-&gt;total_size ) <span class="comment">/* current frame is received completely, call Process() */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 组成了一帧数据 */</span></span><br><span class="line">                    get_all_pieces = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    UDP_ERR( <span class="string">"recv_len != total_size! recv_len: %d, total_size: %d"</span>, udp_piece-&gt;recv_len, udp_piece-&gt;total_size );</span><br><span class="line">                    get_all_pieces - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">        &#123;</span><br><span class="line">            UDP_DEBUG( <span class="string">"temp_size = %d, HEAD_SIZE + data_len = %d\n"</span>,</span><br><span class="line">                   circular_buffer_size( udp_piece-&gt;circular_buffer ), HEAD_SIZE + data_len );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(get_all_pieces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>通信协议</tag>
        <tag>upd</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron之识</title>
    <url>/2020/03/11/Electron%E4%B9%8B%E8%AF%86/</url>
    <content><![CDATA[<p>当我第一次享受到nodejs的美好的时候是玩hexo的时候。说起electron缘于和顺丰的一个大佬的愉快聊天，虽然我很诚恳的表达了我对electron的未知，但还是很感谢他给我耐心介绍了一番。事后，我记下了这个关键字，闲来无事搜索认知。</p>
<a id="more"></a>
<h2 id="Electron之化繁为简"><a href="#Electron之化繁为简" class="headerlink" title="Electron之化繁为简"></a>Electron之化繁为简</h2><p>定义：<a href="https://www.electronjs.org/" target="_blank" rel="noopener" title="官网地址">使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</a></p>
<p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 <code>JavaScript</code>, <code>HTML</code> 和 <code>CSS</code> 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。这是官网的一段原文。由此我们可以得知electron的核心设计思想就是<font color=red><strong>化繁为简</strong></font>。</p>
<h2 id="Electron特点"><a href="#Electron特点" class="headerlink" title="Electron特点"></a>Electron特点</h2><h3 id="1-Web-技术"><a href="#1-Web-技术" class="headerlink" title="1. Web 技术"></a>1. Web 技术</h3><p><code>Electron</code> 基于 <code>Chromium</code> 和 <code>Node.js</code>, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。</p>
<h3 id="2-开源"><a href="#2-开源" class="headerlink" title="2. 开源"></a>2. 开源</h3><p><code>Electron</code> 是一个由 <code>GitHub</code> 及众多贡献者组成的活跃社区共同维护的开源项目。</p>
<h3 id="3-跨平台"><a href="#3-跨平台" class="headerlink" title="3. 跨平台"></a>3. 跨平台</h3><p><code>Electron</code> 兼容 <code>Mac</code>、<code>Windows</code> 和 <code>Linux</code>，可以构建出三个平台的应用程序。</p>
<p><em>那electron是怎样化繁为简的呢？</em></p>
<blockquote>
<p>l.利用chromium项目基于c++开发的原因，chromium是跨平台的，如此便简化了跨平台的繁琐操作；<br>2.相比于传统桌面前端技术，没了各种语言的api（如：c/c++），没了系统gui框架api(如：mfc)，累活基本让chromium干了，开发人员只需关注业务代码，实现高定制的个性化界面，electron做到了类似于qt一样的实现自己的api，一处编写，各处运行。且呈现效果一致。js的学习难度与c/c++这种底层语言相比学习难度不知道低了多少。如此便简化了编程学习的曲线及难度；<br>3.electron如何保证高效的运行,拥抱开源。<font color=#ff4777><em>（这一点其实有点牵强，高不高效全建立在chromium渲染以及v8引擎，所以不适合极高速的渲染工程，像ps，3dmax这种图形图像软件或者工程测绘等实时性要求高的软件是不合适用electron框架来做的）</em></font></p>
</blockquote>
<h2 id="Electron开发入门"><a href="#Electron开发入门" class="headerlink" title="Electron开发入门"></a>Electron开发入门</h2><p>初识 Electron，可参考下列资料，了解如何使用 Electron 封装你的前端代码，调用丰富的 API，以及生成安装程序。</p>
<h3 id="探索-Electron-的-API"><a href="#探索-Electron-的-API" class="headerlink" title="探索 Electron 的 API"></a>探索 Electron 的 API</h3><p><a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">Electron API 示例程序</a>采用交互式界面展示了 Electron API 最关键的功能。发布版地址在这<br><a href="https://github.com/electron/electron-api-demos/releases" target="_blank" rel="noopener">从GitHub下载</a>。</p>
<h3 id="借助-Electron-Fiddle-深入探索"><a href="#借助-Electron-Fiddle-深入探索" class="headerlink" title="借助 Electron Fiddle 深入探索"></a>借助 <code>Electron Fiddle</code> 深入探索</h3><p>你可以使用 <code>Electron Fiddle</code> 创建并运行小段 <code>Electron</code> 程序，从一个简单的模板开始，随心所欲地挥洒你的创意，选择一个 <code>Electron</code> 版本欣赏运行效果。最后，你可以将其下载保存，或推送 <code>GitHub Gist</code> 上，所有人都可以输入网址运行你的 <code>Fiddle</code>。<br><a href="https://github.com/electron/fiddle/releases/latest" target="_blank" rel="noopener">从Github下载</a><br><a href="https://www.electronjs.org/fiddle" target="_blank" rel="noopener">详细</a></p>
<h3 id="关于help文档"><a href="#关于help文档" class="headerlink" title="关于help文档"></a>关于help文档</h3><p><a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">快速启动</a> 应用程序，看看 Electron 是如何运转的：<br><strong><em>一个有帮助内容的 Electron 应用。</em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆示例项目的仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入这个仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖并运行</span></span><br><span class="line">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure>
<p>或开始钻研<a href="https://www.electronjs.org/docs" target="_blank" rel="noopener">文档</a>。<br>使用 <code>Electron</code> 构建的应用<br>最初为 <code>GitHub</code> 开发 <a href="https://atom.io/" target="_blank" rel="noopener">Atom 编辑器</a>, <code>Electron</code> 此后被世界各地的公司采纳，如微软的<code>Visual Studio Code</code>。</p>
<p>有了官方文档，就可以开始干活了。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>首先，安装最新版本的<code>Node.js</code> 。 我们推荐您安装最新的 <code>长期支持版本</code> 或者 <code>当前发行版本</code> 。 访问<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js下载页面</a>，这里我选择 <code>Windows Installer</code>。 下载完成后， 执行安装程序，根据引导完成安装即可。</p>
<p>在安装过程中的配置界面, 请勾选<code>Node.js runtime</code>、<code>npm package manager</code>和<code>Add to PATH</code>这三个选项。</p>
<p>安装完成后，我们需要来确认<code>Node.js</code>是不是可以正常工作。 点击 <code>开始</code> 按钮，输入<code>PowerShell</code>，找到<code>Windows PowerShell</code>。 打开<code>PowerShell</code>或其他你喜欢的<code>命令行客户端</code>后，通过以下命令来确认 <code>node</code> 和 <code>npm</code>已经安装成功：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面这行的命令会打印出Node.js的版本信息</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这行的命令会打印出npm的版本信息</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h3 id="开发第一个程序"><a href="#开发第一个程序" class="headerlink" title="开发第一个程序"></a>开发第一个程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#当前项目在线安装electron，各项目选择版本不同，可以使用此方法</span></span><br><span class="line">npm install --save-dev electron</span><br><span class="line"><span class="comment">#后面为空，是默认下载最新发布版electron的意思</span></span><br><span class="line">npm install </span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#全局安装</span></span><br><span class="line">npm install electron -g</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想修改下载安装的位版本(例如, 在x64机器上安装ia32位版本), 你可以使用npm install中的--arch标记，或者设置npm_config_arch 环境变量:</span></span><br><span class="line">npm install --arch=ia32 electron</span><br><span class="line"></span><br><span class="line"><span class="comment">#此外, 您还可以使用 --platform 来指定开发平台 (例如, win32、linux 等):</span></span><br><span class="line">npm install --platform=win32 electron</span><br></pre></td></tr></table></figure>
<p>离线安装<br>去<a href="https://github.com/electron/electron/releases" target="_blank" rel="noopener">electron/electron/releases</a><br>选择相应release版本下载安装文件。</p>
<p><font color=red>个人对这个安装包的理解：<br>就是一个小型chrome浏览器</font>，直接解压就可以使用，可以把这个解压目录加到环境变量，从而就可以直接运行<code>electron 项目路径</code>，如果不用环境变量，这每次执行需要运行：<code>electron.exe的路径 项目路径</code>.如下图我下载了一个<code>electron-quick-start-master</code>项目，然后把一个<code>blog</code>首页替换<code>index.html</code>即可得到一个和web一样效果的程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用electron启动</span></span><br><span class="line">.\electron-v8.1.1-win32-x64\electron.exe .\electron-quick-start-master\ </span><br><span class="line"></span><br><span class="line"><span class="comment">#用npm启动，前提是electron在环境变量中或者electron.exe和工程在同一个目录</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p><img src="electron_demo.png" alt="demo效果图" title="demo效果图"></p>
<h2 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h2><p>由上步骤，我们已经得到了一个完整的web项目，可是如何发布打包成一个exe呢？<br>在 Windows 上, 你必须使用安装程序将你的应用装到用户的计算机上才能使用<code>autoUpdater</code>, 所以比较推荐的方法是用 <a href="https://github.com/electron/windows-installer" target="_blank" rel="noopener">electron-winstaller</a>, <a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">electron-forge</a>或 <a href="https://github.com/electron/grunt-electron-installer" target="_blank" rel="noopener">grunt-electron-installer</a> 模块来生成Windows安装程序。</p>
<p>当使用 electron-winstaller 或 electron-forge 时，确保不要在第一次运行时更新你的应用程序 (详情参阅 这个问题的更多信息). 还建议使用 <code>electron-squirrel-startup</code> 来创建应用程序的桌面快捷方式。</p>
<p>使用Squirrel生成的安装程序将以<code>com.squirrel.PACKAGE_ID.YOUR_EXE_WITHOUT_DOT_EXE</code>,的格式创建一个带有<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85).aspx" target="_blank" rel="noopener">Application User Model ID</a> 的快捷图标,例子是 <code>com.squirrel.slack.Slack</code> 和 <code>com.squirrel.code.Code.</code>。 你应该在自己的应用中使用 <code>app.setAppUserModelId</code> API 方法设置相同的 API和ID，不然 Windows 将不能正确地把你的应用固定在任务栏上。</p>
<p>与 Squirrel.Mac 不同，Windows 版可以将更新文件放在 S3 或者其他静态主机上。 你可以阅读 <a href="https://github.com/Squirrel/Squirrel.Windows" target="_blank" rel="noopener">Squirrel.Windows</a>的文档来获得更多详细信息。</p>
<p>具体哪种打包怎么做参考相应GitHub链接即可。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>VS使用WSL开发Linux程序配置说明</title>
    <url>/2020/03/05/VS%E4%BD%BF%E7%94%A8WSL%E5%BC%80%E5%8F%91Linux%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>自Visual Studio 2019（简称vs）16.1版本开始，vs已经能够很好的支持WSL了，我们可以通过ssh连接在WSL上开发并调试c/c++程序。</p>
<a id="more"></a>
<p>Windows Subsystem for Linux (WSL) 第一次出现是在2016年的微软开发者大会上。现在win10的应用商店已经有好几版本的WSL系统了，尤其Ubuntu LTS版本最为受欢迎，下面也以Ubuntu为例。</p>
<h2 id="安装WSL-ubuntu"><a href="#安装WSL-ubuntu" class="headerlink" title="安装WSL(ubuntu)"></a>安装WSL(ubuntu)</h2><ol>
<li>首先我们要在win10启用开发者模式</li>
<li>然后去应用商店下载即可，<br>安装完成后，会提升我们呢输入用户名密码如下图<br><img src="bash-install-500x282.png" alt=""></li>
<li>安装c/c++必要的编译调试环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment">#We’ll also need to install gdbserver, a program that allows you to debug with a remote GDB debugger.</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install -y gdbserver</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装-amp-配置SSH"><a href="#安装-amp-配置SSH" class="headerlink" title="安装&amp;配置SSH"></a>安装&amp;配置SSH</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装ssh</span></span><br><span class="line">$ sudo apt install -y openssh-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh</span></span><br><span class="line"></span><br><span class="line">$ sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>找到 “PasswordAuthentication” 设置成 “yes”然后保存退出,如下图。<br><img src="bash-nanosshd-454x350.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成ssh keys</span></span><br><span class="line"></span><br><span class="line">$ sudo ssh-keygen -A</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动ssh，如果已经启动可以用restar替换start</span></span><br><span class="line"></span><br><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure>

<h2 id="安装-amp-配置Visual-Studio"><a href="#安装-amp-配置Visual-Studio" class="headerlink" title="安装&amp;配置Visual Studio"></a>安装&amp;配置Visual Studio</h2><p>下载安装vs17版本以上，最好19以上，安装的时候注意选择<code>Visual C++ for Linux</code>，安装完成后打开vs就有一下界面<br><img src="bashinstalllinux-500x293.png" alt=""><br>现在就可以连接到WSL了，操作如下：<br><code>Tools &gt; Options &gt; Cross Platform &gt; Connection Manager</code>.<br>如下图让你输入ip，端口，用户名，密码远程连接Linux了。其实如果不是wsl，是其他的Linux系统如子网或者公网的Linux系统都是可以的，前提是我们配置正确。<br><img src="bashconnectionmanager-500x290.png" alt=""></p>
<p>如果连接成功，vs会下载一些系统头文件到本地，方便我们编码时的智能感知提醒。至此我们的编译器就可使用了，新建工程试试。<br><code>File &gt; New Project &gt; Visual C++ &gt; Cross Platform &gt; Linux</code>.</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>vs</tag>
        <tag>visual studio</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker介绍及使用</title>
    <url>/2020/03/01/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<a id="more"></a>
<h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>Docker 包括三个基本概念: </p>
<ul>
<li><p>镜像（Image）：<br>Docker 镜像（Image），就相当于是一个 root 文件系统。 比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系 统的 root 文件系统。 </p>
</li>
<li><p>容器（Container）：<br>镜像（Image）和容器（Container）的关系，就像是 面向对象程序设计中的类和实例一样如下表，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建Docker 容器。</p>
<table>
<thead>
<tr>
<th align="center">docker概念</th>
<th align="center">面向对象概念</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容器</td>
<td align="center">对象</td>
</tr>
<tr>
<td align="center">镜像</td>
<td align="center">类</td>
</tr>
</tbody></table>
</li>
<li><p>仓库（Repository）：<br>仓库可看着一个代码控制中心，用来保存镜像</p>
<h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><h3 id="1-安裝"><a href="#1-安裝" class="headerlink" title="1. 安裝"></a>1. 安裝</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不到300M</span></span><br><span class="line"><span class="comment">#sudo apt-get install docker在Ubuntu16以上要加.io</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="comment">#查看docker版本</span></span><br><span class="line">docker –v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安裝必要的系統工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment">#安裝GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/dockerce/linux/ubuntu/gpg | sudo apt-key add – </span><br><span class="line"></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span> </span><br><span class="line"> </span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install docker-ce –y </span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看 docker-ce 版本 </span></span><br><span class="line">sudo apt-cache madison docker-ce </span><br><span class="line"><span class="comment">#安装指定版本的 Docker-CE </span></span><br><span class="line">sudo apt-get install docker-ce=17.06.0~ce-0~ubuntu</span><br></pre></td></tr></table></figure></li>
<li><p><em>docker安装成功后，后续docker操作基本都要root权限，所以建议干脆直接切root账号。*</em></p>
</li>
</ul>
<h3 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2. 镜像仓库"></a>2. 镜像仓库</h3><p>查看可用的 Ubuntu 版本 访问 <a href="https://hub.docker.com" target="_blank" rel="noopener">Ubuntu 镜像库地址</a>。 可以通过 Sort by 查 看 其 他 版 本 的 Ubuntu 。 默 认 是 最 新 版 本 ubuntu:latest 。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所以镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 拉取ubuntu14.04</span></span><br><span class="line">docker pull ubuntu:14.04</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 启动已停止运行的容器'df9c1758dde1'，命令如下： </span></span><br><span class="line">docker start df9c1758dde1</span><br><span class="line"><span class="comment"># 查看容器所以命令</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 停止容器的命令如下： </span></span><br><span class="line">docker stop df9c1758dde1</span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart df9c1758dde1</span><br><span class="line"><span class="comment"># 进入容器两种方式attach与exec</span></span><br><span class="line">docker attach df9c1758dde1</span><br><span class="line">docker <span class="built_in">exec</span> -it df9c1758dde1 /bin/bash </span><br><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> df9c1758dde1 &gt; ubuntu.tar</span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">cat ubuntu.tar | docker import - ubuntu:v1</span><br><span class="line"><span class="comment"># 删除容器 </span></span><br><span class="line">docker rm -f b87fcf19d529 </span><br><span class="line"><span class="comment"># 拉取最新版Nginx</span></span><br><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>
<p>容器不退出，返回宿主机快捷键：<kbd>ctrl</kbd>+<kbd>p</kbd>+<kbd>q</kbd>，进入容器推荐<code>exec</code>；如果使用<code>attach</code>，多个终端登入的话会相互影响。<br>安装完成后，我们可以使用以下命令来运行 nginx 容器：<br><code>docker run --name nginx-test -p 8080:80 -d nginx</code> </p>
<ul>
<li>–name nginx-test：容器名称。 </li>
<li>-p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。 </li>
<li>-d nginx： 设置容器在在后台一直运行。 </li>
</ul>
<h3 id="3-定制镜像-Dockerfile"><a href="#3-定制镜像-Dockerfile" class="headerlink" title="3. 定制镜像 Dockerfile"></a>3. 定制镜像 Dockerfile</h3><pre><code>编写`Dockerfile`，然后执行`docker build -t 名称:tag .` </code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定制nginx的Dockfile如下</span></span><br><span class="line"><span class="comment"># This is dockerfile for nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># base image</span></span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># author</span></span><br><span class="line">MAINTAINER 作者名 myname@email.com</span><br><span class="line"></span><br><span class="line">ADD nginx-1.13.7.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD pcre-8.41.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD zlib-1.2.11.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line">ADD openssl-1.1.0g.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line"></span><br><span class="line">ADD sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install build-essential -y</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span>/src/nginx-1.13.7</span><br><span class="line"></span><br><span class="line">RUN ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_realip_module --with-http_addition_module --with-http_gzip_static_module --with-http_secure_link_module --with-http_stub_status_module --with-stream --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 --with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 --with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.1.0g &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"daemon off;"</span> &gt;&gt; /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/usr/local/nginx/sbin/nginx"</span>, <span class="string">"-c"</span>, <span class="string">"/usr/local/nginx/conf/nginx.conf"</span>]</span><br></pre></td></tr></table></figure>

<h2 id="文件系统隔离"><a href="#文件系统隔离" class="headerlink" title="文件系统隔离"></a>文件系统隔离</h2><p>docker里面不能直接使用<code>apt</code>这些系统命令，需要在前面加<code>/usr/bin/</code>如：<code>/usr/bin/apt-get</code>,加环境变量也可以</p>
<h3 id="docker实现原理："><a href="#docker实现原理：" class="headerlink" title="docker实现原理："></a>docker实现原理：</h3><ol>
<li>Mount namespace:挂载隔离，可以将日志文件共享到物理机，也可以通过该机制从docker拷贝文件到物理机。</li>
<li>UTS namespace:主机名的隔离，进入docker后，我们能看到终端的主机名会发生改变，不再是宿主机的hostname。</li>
<li>IPC namespace:两个进程间不能通过ipc技术通信</li>
<li>PID namespace:单独的pid系统，各docker都是从1开始，相当于Linux的init进程</li>
<li>Network namespace:网络不复用，网络不共享</li>
<li>User namespace:用户名隔离，与系统用户不一样</li>
</ol>
<p>以上6种隔离技术原理推荐阅读链接</p>
<p><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（上）</a><br><a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE（下）</a><br>下面详述一下复杂的<code>Network namespace</code>.内容是copy上述链接中的，如果原链接能访问建议访问原链接，感谢<code>作者陈皓</code>。<br>在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p>
<p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）<br><img src="networknamespace.jpg" alt="" title="network namespace"><br>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p>
<p>当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...</span><br><span class="line">    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<p>那么，要做成这个样子应该怎么办呢？我们来看一组命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 接下来，我们要创建一个network namespace - ns1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1   ip link <span class="built_in">set</span> dev lo up </span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 <span class="built_in">type</span> veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1  ip link <span class="built_in">set</span> dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1     ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure>
<p>上面基本上就是docker网络的原理了，只不过，</p>
<ul>
<li>Docker的resolv.conf没有用这样的方式，而是用了<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">上篇中的Mount Namesapce的那种方式</a></li>
<li>另外，docker是用进程的PID来做Network Namespace的名称的。<br>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link add peerA <span class="built_in">type</span> veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link <span class="built_in">set</span> peerA up </span><br><span class="line">ip link <span class="built_in">set</span> peerB netns <span class="variable">$&#123;container-pid&#125;</span> </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> dev peerB name eth1 </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip link <span class="built_in">set</span> eth1 up ; </span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$&#123;container-pid&#125;</span> ip addr add <span class="variable">$&#123;ROUTEABLE_IP&#125;</span> dev eth1 ;</span><br></pre></td></tr></table></figure>
上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</li>
</ul>
<p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p>
<p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p>
<p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a href="https://lwn.net/Articles/620087/" target="_blank" rel="noopener">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>zmq使用入门</title>
    <url>/2020/02/21/zmq%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="zmq简介"><a href="#zmq简介" class="headerlink" title="zmq简介"></a>zmq简介</h2><p>超快开源c++消息队列库ZeroMQ (也写作 ØMQ, 0MQ or ZMQ)，是一个高性能异步消息库，专注于分布式或高并发应用。不同于传统消息中间件，它可以不依赖于Broker运行。<br>zmq库有多个本文以<code>Linux</code>环境使用<code>libzmq</code>为例。</p>
<a id="more"></a>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/zeromq/libzmq/releases" target="_blank" rel="noopener">github地址</a>下载最新发布版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget https://github.com/zeromq/libzmq/releases/xxx.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf xxx.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开<code>README.md</code>可以看到</p>
<blockquote>
<p><strong>Build from sources</strong><br>To build from sources, see the INSTALL file included with the distribution.</p>
</blockquote>
<p>所以查看INSTALL文档可以找到安装方法</p>
<blockquote>
<p><strong>Basic Installation</strong></p>
<p>Briefly, the shell commands <font color=red><code>./configure; make; make install</code> </font>should<br>configure, build, and install this package. </p>
</blockquote>
<p>正常情况通过上面几步就安装成功了，如果没有<code>./configure</code>文件？那就照下面步骤干吧。</p>
<p>use <code>./autogen.sh</code> to generate <code>configure</code><br>and other necessary installation scripts.</p>
<p>The simplest way to compile this package is:</p>
<ol>
<li><p><code>cd</code> to the directory containing the package<code>s source code and type</code>./configure` to configure the package for your system.</p>
<p>Running <code>configure</code> might take a while.  While running, it prints<br>some messages telling which features it is checking for.</p>
</li>
<li><p>Type <code>make</code> to compile the package.</p>
</li>
<li><p>Optionally, type <code>make check</code> to run any self-tests that come with<br>the package. Note that <code>make -j check</code> is not supported as some<br>tests share infrastructure and cannot be run in parallel.</p>
</li>
<li><p>Type <code>make install</code> to install the programs and any data files and<br>documentation.</p>
</li>
<li><p>You can remove the program binaries and object files from the<br>source code directory by typing <code>make clean</code>.  To also remove the<br>files that <code>configure</code> created (so you can compile the package for<br>a different kind of computer), type <code>make distclean</code>.  There is<br>also a <code>make maintainer-clean</code> target, but that is intended mainly<br>for the package`s developers.  If you use it, you may have to get<br>all sorts of other programs in order to regenerate files that came<br>with the distribution.</p>
</li>
<li><p>Often, you can also type <code>make uninstall</code> to remove the installed<br>files again.</p>
</li>
</ol>
<p>库文件路径生成目录在<code>src/.lib</code>，安装后的目录在<code>/usr/local/lib</code>,如果运行报错找不到库请执行<code>sudo ldconfig</code>刷新系统库路径。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写个测试文档或者用给出的test文件夹下面的文档，进行编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意要加-lzmq</span></span><br><span class="line">g++ -o test zmq_test.cpp -lzmq</span><br></pre></td></tr></table></figure>
<p>生成test成功就说明库没问题了，安装成功。</p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>zmq</tag>
        <tag>ZeroMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github,hexo,next搭建个人博客</title>
    <url>/2020/02/11/%E4%BD%BF%E7%94%A8github-hexo-next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>其实之前一直用csdn写博客，后来闲来无事别想着自己搭一个平台，于是用了wordpress，不愧是出自大厂（Facebook），可以说的上是简单、优美、功能完善一应俱全。然而，让我放弃的原因有点单调，设想自己N年后，把自己的记录整理一番，发现某些博客平台导出非常不友好，而wordpress虽然能做很多事情，但是。。。好吧不但是了，我是一个有强迫症的人，我就是要用markdown文档，记得第一次接触这种格式是在GitHub的<code>readme.md</code>，没想到用了几年后蓦然回首才发现被她的美深深吸引。因为我觉得这种文档格式非常好，精简高效地实现了较为友好的阅读效果，所以当我知道hexo原生支持<code>markdown</code>做博客文档时候，我就明确我要干些啥了。</p>
<a id="more"></a>

<p>抒情完了，介于做博客，本文将介绍如何使用GitHub pages和hexo来搭建一个个人博客。github pages 是一个静态网页博客平台。建立好git仓库之后，可以直接在github上配置生成一个简单的首页index.html <strong>(没错还是hello world)</strong>，另外还支持域名配置。hexo是一个基于nodeJS实现的博客框架。它的最大的作用就是能将 <strong>markdown文档</strong>自动转化成 <strong>html文档</strong>。再搭配一些主题（比如：<strong>next主题</strong>）,将显示的非常美观，而且next主题是一个开源的可以自由定制的主题。</p>
<h2 id="关于hexo的安装及使用"><a href="#关于hexo的安装及使用" class="headerlink" title="关于hexo的安装及使用"></a>关于hexo的安装及使用</h2><p>先安装nodejs，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>下载安装即可。Linux 安装npm即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure>
<p>输入 <code>npm -v</code> ，如果出现版本号，那说明安装成功了并且环境变量也配置好了，如果是未知命令那就要配置一下环境变量。</p>
<p><strong>windows的安装</strong><br>如果已经安装了<em>git bash</em>,可以在<em>git bash</em>中使用以下安装命令（网上有人反应过失败，用cmd能成功，但应该是个例），否则使用<em>cmd</em>（快捷键<kbd>Win</kbd>+<kbd>R</kbd>然后输入cmd）窗口也是一样。后面的就和命令行安装一摸一样了。<br><strong>命令行安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#windows环境的话</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment">#linux环境的话</span></span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>这一步安装可能略慢，原因大家都懂，就不说了。输入<code>hexo -v</code>如果能看到版本信息就说明成功了,另附<a href="https://www.w3cschool.cn/nodejs/nodejs-npm.html" target="_blank" rel="noopener">npm W3C教程</a>。<br>接下来就可以用hexo来生成博客了。新建一个博客文件夹，如blog,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo init</span><br><span class="line">hexo generate   //可以简写成hexo g</span><br><span class="line">hexo server     //可以简写成hexo s</span><br></pre></td></tr></table></figure>
<p>成功后，我们可以看到提示 localhost:4000 可以访问，用浏览器打开，可以看到首页。<br><img src="localhost.png" alt="生成博客成功" title="博客首页"><br>个人调试可以用以下命令去一键生成：<br><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code><br>意思是先清除现有博客，然后生成，发布。另外hexo的远程部署命令是<code>hexo d</code>.</p>
<h2 id="hexo配合github建站"><a href="#hexo配合github建站" class="headerlink" title="hexo配合github建站"></a>hexo配合github建站</h2><p>当我们需要远程部署的时候，需要先安装<em>hexo-deployer-git</em>。<br><code>npm install hexo-deployer-git --save</code><br>安装好之后在博客目录配置文件_config.yml最后面添加deploy字段如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:UserName/Blog.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>如果git仓库是ssh则需要生成rsa key,添加公钥到github，后续用远程更新代码即可不用输入用户名密码验证。这是git的操作，本文部再赘述。</p>
<blockquote>
<p>此外，如果您的 <code>Github Pages</code> 需要使用 <code>CNAME</code> 文件自定义域名，请将 <code>CNAME</code> 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 <code>CNAME</code> 文件一并推送至部署分支。</p>
</blockquote>
<p>关于hexo的工程文件说明如下：</p>
<blockquote>
<p>_config.yml ——工程配置文件<br>source/ ——该目录为我们存放markdown文件的地方<br>theme/ ———存放主题的目录<br>public/ ——发布生成的路径，hexo clean可以删除该目录</p>
</blockquote>
<h3 id="hexo-创建文章、标签、分类"><a href="#hexo-创建文章、标签、分类" class="headerlink" title="hexo 创建文章、标签、分类"></a>hexo 创建文章、标签、分类</h3><ul>
<li><p>创建文章<code>hexo new &quot;文章名称&quot;</code></p>
<pre><code>---
title: CentOS7下Tomcat启动慢的原因及解决方案
date: 2017-12-02 21:01:24
comments: true #是否可评论
toc: true #是否显示文章目录
categories: &quot;云服务器&quot; #分类
tags:   #标签
    - centOS
    - tomcat
---</code></pre></li>
<li><p>创建标签<code>hexo new page tags</code></p>
<pre><code>title: tags
date: 2017-12-02 21:01:24
type: &quot;tags&quot;</code></pre></li>
<li><p>创建分类<code>hexo new page categories</code></p>
<pre><code>title: categories
date: 2017-12-02 21:01:24
type: &quot;categories&quot;</code></pre><p>更多hexo详细说明如<code>API，主题，插件</code>等请参阅<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文官方文档</a>。<br>注意标签和分类中，title可以为空，但是type:一定要写对，否则网站不能自动关联。</p>
</li>
</ul>
<h2 id="next教程"><a href="#next教程" class="headerlink" title="next教程"></a>next教程</h2><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；称为 <code>站点配置文件</code>， 另一份位于主题目录下，称为 <code>主题配置文件</code>。<br><strong>nexT</strong>是一个<a href="https://github.com/iissnan/hexo-theme-next/releases/tag/v5.1.4" target="_blank" rel="noopener">github 上的开源主题</a>。<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">nexT官网</a>有教程教怎么使用、配置等。</p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><ul>
<li><p>克隆最新版本</p>
<blockquote>
<p>在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> your-hexo-site</span><br><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载稳定版本</p>
<blockquote>
<p>1.前往 NexT 版本 <a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">发布页面</a>。<br>2.选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。例如，下载 v0.4.0 版本。<br>3.解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（<code>hexo-theme-next-0.4.0</code>）更改为 next。</p>
</blockquote>
</li>
</ul>
<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 <code>克隆/下载</code> 完成后，打开 站点配置文件， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>
<table>
<thead>
<tr>
<th>启用 NexT 主题</th>
</tr>
</thead>
<tbody><tr>
<td>theme:<code></code>next</td>
</tr>
</tbody></table>
<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p>
<h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<br><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，检查站点是否正确运行。<br>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p>
<h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<blockquote>
</blockquote>
<p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新</p>
<p>Scheme 的切换通过更改 <code>主题配置文件</code>，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p>
<table>
<thead>
<tr>
<th>选择 Pisces Scheme</th>
</tr>
</thead>
<tbody><tr>
<td>#scheme: Muse</td>
</tr>
<tr>
<td>#scheme: Mist</td>
</tr>
<tr>
<td>scheme: Pisces</td>
</tr>
</tbody></table>
<h4 id="设置-界面语言"><a href="#设置-界面语言" class="headerlink" title="设置 界面语言"></a>设置 界面语言</h4><p>编辑 站点配置文件， 将 <code>language</code> 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：<br>` language: zh-Hans<br>目前 NexT 支持的语言如以下表格所示：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定示例</th>
</tr>
</thead>
<tbody><tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>Français</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>Português</td>
<td>pt</td>
<td>language: pt or language: pt-BR</td>
</tr>
<tr>
<td>繁體中文</td>
<td>zh-hk 或者 zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Русский язык</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>Deutsch</td>
<td>de</td>
<td>language: de</td>
</tr>
<tr>
<td>日本語</td>
<td>ja</td>
<td>language: ja</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
<td>language: id</td>
</tr>
<tr>
<td>Korean</td>
<td>ko</td>
<td>language: ko</td>
</tr>
</tbody></table>
<h4 id="设置-菜单"><a href="#设置-菜单" class="headerlink" title="设置 菜单"></a>设置 菜单</h4><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p>
<p>编辑 <code>主题配置文件</code>，修改以下内容：</p>
<ul>
<li>设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：<code>item name: link</code>。其中 <code>item name</code> 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。<blockquote>
</blockquote>
菜单示例配置<br>menu:<br>home: /<br>archives: /archives<br>#about: /about<br>#categories: /categories<br>tags: /tags<br>#commonweal: /404.html</li>
</ul>
<blockquote>
<p>若你的站点运行在子目录中，请将链接前缀的 <code>/</code> 去掉</p>
</blockquote>
<p>NexT 默认的菜单项有（标注  的项表示需要手动创建这个页面）：</p>
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>显示文本（简体中文）</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td>home: /</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404</td>
</tr>
</tbody></table>
<ul>
<li>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/{language}.yml</code> （{language} 为你所使用的语言）。</li>
</ul>
<p>以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 <code>languages/zh-Hans.yml</code>，在 <code>menu</code> 字段下添加一项：</p>
<blockquote>
</blockquote>
<p>menu:<br>  home: 首页<br>  archives: 归档<br>  categories: 分类<br>  tags: 标签<br>  about: 关于<br>  search: 搜索<br>  commonweal: 公益404<br>  something: 有料</p>
<ul>
<li><p>设定菜单项的图标，对应的字段是 <code>menu_icons</code>。 此设定格式是 <code>item name: icon name</code>，其中 <code>item name</code> 与上一步所配置的菜单名字对应，<code>icon name</code> 是 Font Awesome 图标的 名字。而 <code>enable</code> 可用于控制是否显示图标，你可以设置成 <code>false</code> 来去掉图标。</p>
<blockquote>
</blockquote>
<p>菜单图标配置示例<br>menu_icons:</p>
<pre><code>enable: true
\# Icon Mapping.
home: home
about: user
categories: th
tags: tags
archives: archive
commonweal: heartbeat</code></pre></li>
<li><p>在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 :?  作为图标。</p>
</li>
<li><p>请注意键值（如 <code>home</code>）的大小写要严格匹配</p>
<h4 id="设置-侧栏"><a href="#设置-侧栏" class="headerlink" title="设置 侧栏"></a>设置 侧栏</h4><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p>
</li>
<li><p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p>
<blockquote>
</blockquote>
<p>left - 靠左放置<br>right - 靠右放置</p>
</li>
</ul>
<p>目前仅 Pisces Scheme 支持 <code>position</code> 配置。影响版本5.0.0及更低版本。</p>
<blockquote>
</blockquote>
<p>sidebar:<br>  position: left</p>
<ul>
<li>设置侧栏显示的时机，修改 <code>sidebar.display</code> 的值，支持的选项有：<blockquote>
</blockquote>
</li>
<li>post - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li>always - 在所有页面中都显示</li>
<li>hide - 在所有页面中都隐藏（可以手动展开）</li>
<li>remove - 完全移除</li>
</ul>
<blockquote>
</blockquote>
<p>sidebar:<br>  display: post</p>
<ul>
<li>已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。</li>
</ul>
<h4 id="设置-头像"><a href="#设置-头像" class="headerlink" title="设置 头像"></a>设置 头像</h4><p>编辑 主题配置文件， 修改字段 <code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>完整的互联网 URI</td>
<td><a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></td>
</tr>
<tr>
<td>站点内的地址</td>
<td>将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）</td>
</tr>
<tr>
<td></td>
<td>配置为：avatar: /uploads/avatar.png</td>
</tr>
<tr>
<td></td>
<td>或者 放置在 source/images/ 目录下</td>
</tr>
<tr>
<td></td>
<td>配置为：avatar: /images/avatar.png</td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<p>头像设置示例<br>avatar: <a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></p>
<h4 id="设置-作者昵称"><a href="#设置-作者昵称" class="headerlink" title="设置 作者昵称"></a>设置 作者昵称</h4><p>编辑 <code>站点配置文件</code>， 设置 <code>author</code> 为你的昵称。</p>
<h4 id="设置-站点描述"><a href="#设置-站点描述" class="headerlink" title="设置 站点描述"></a>设置 站点描述</h4><p>编辑 <code>站点配置文件</code>， 设置 <code>description</code> 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>请参考连接<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">主题配置</a></p>
<h2 id="注意，踩坑记录："><a href="#注意，踩坑记录：" class="headerlink" title=" 注意，踩坑记录："></a><span style=color:red;> 注意，踩坑记录：</span></h2><ol>
<li><p>正文中表示超链接时，前后应该用空格流出或者用特殊标签标记如:`http:localhost:4000`。原因：md语法问题导致的编译工程报错!</p>
</li>
<li><p>正文中输入#等特殊字符应该使用转义，否则也会因为解析失败，不能编译成功。</p>
</li>
<li><p>关于定制样式。chrome调配置样式，使用<kbd>F12</kbd>进入调试模式，找到相应的css或者js再去IDE（如：<code>vs code</code>）中打开的工程中搜索并修改即可。</p>
</li>
<li><p>表格不显示，前面一定要空一行，且表头不能省略<code>|</code>。</p>
</li>
<li><p>404公益是直接将<code>/404/</code>改成<code>/404.html</code>.</p>
</li>
<li><p>主题(next)里面访问的资源路径总是根目录，即使站点设置了child目录为根目录也不行（设置upload目录也不会被生成，即使站点打开了asset，目录乱绝对是一个bug。待修复）。<br>似乎现在已经修复了这个bug（待验证）。总之官方的使用方式很麻烦且阅读性烂，<del>推荐 <code>hexo-asset-image</code> 插件，使用方法就是通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹</del>（新版本已经不再需要）。修改 <code>_config.yml</code>下的 <code>post_asset_folder: true</code> 将其改成true.用的时候只要 <code>![a](a.jpg)</code> 即可，插件会自动修改具体的路径。完整的目录结构如下:</p>
<blockquote>
</blockquote>
<p>TEST<br>├── a.jpg<br>├── b.jpg<br>└── c.jpg<br>TEST.md</p>
</li>
<li><p>数学公式不显示，在_config.yml文件中启用mathjax，并在文章<code>font-matter</code>里面添加：<code>mathjax: true</code><br>这是一个公式渲染引擎，默认是关闭的，每篇文章加这个是为了避免拖慢访问速度。 </p>
</li>
<li><p>关于插件，推荐<br> 1.使用RSS:<code>npm install --save hexo-generator-feed</code><br> 2.博客管理:<code>npm install --save hexo-admin</code><br> 3.<del>Asset管理:<code>npm install --save hexo-asset</code>,也许是新版修复了bug的问题，在新版中使用这个会导致有图片的文章重复解析一遍，害我找了半天，但我更相信这还是一个bug，（不推荐）</del>没试<code>hexo-asset-image</code>这个插件。<br> 4.文章字数统计:<code>npm i --save  hexo-symbols-count-time</code><br> 5.文章搜索插件:<code>npm install hexo-generator-searchdb --save</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>github page</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建gitlab仓库</title>
    <url>/2020/02/09/%E6%90%AD%E5%BB%BAgitlab%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>我们熟知github这个强大的源代码管理仓库，利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。但是介意外网访问速度的原因，以及企业安全的角度，我们通常考虑自己搭建自己的类似hub站点，其实个人使用的话，我觉得完全没必要搭建hub，在公网平台上搭一个远程仓库就够用了。而本文将主要以Ubuntu18为例讲解如何搭建一个自己的gitlab仓库，好了写本文的目的估计都猜到了，没错，就是出于练手。</p>
<a id="more"></a>
<h2 id="github的特点"><a href="#github的特点" class="headerlink" title="github的特点"></a>github的特点</h2><p>Repo：项目，绝大多数的开源项目都会放在github上，包括<code>Linus Torvalds</code>参与的linux内核，基于repo可以提<br>      issue，可以review code，可以有wiki，branch，tag等等都支持，还可以star和fork这样的repo。<br>Explore：基于兴趣显示了一些开源项目<br>Topics：按照主题显示的一些项目，可以选择某个主题继续观察<br>Trending：流行repo，可以选择语言和周期来显示<br>Events：显示github官方的一些活动</p>
<p>我们可以通过搜索关键字、stars:&gt;1000、fork:&gt;100、语言等来搜索高质量的仓库。</p>
<h2 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h2><p>GitLab是利用 <code>Ruby on Rails</code> 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。很多公司都是基于gitlab进行版本管理的。</p>
<h2 id="搭建gitlab"><a href="#搭建gitlab" class="headerlink" title="搭建gitlab"></a>搭建gitlab</h2><h3 id="第一步：安装一些依赖软件"><a href="#第一步：安装一些依赖软件" class="headerlink" title="第一步：安装一些依赖软件"></a>第一步：安装一些依赖软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br><span class="line">sudo apt-get install -y postfix  # postfix发送邮件，其它的邮件配置见：https://docs.gitlab.com/omnibus/settings/smtp.html</span><br></pre></td></tr></table></figure>
<h3 id="第二步：添加下载源："><a href="#第二步：添加下载源：" class="headerlink" title="第二步：添加下载源："></a>第二步：添加下载源：</h3><p>添加下载源之前，如果没有添加GPG信任，需要先信任 GitLab 的 GPG 公钥:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>已信任的可以跳过，如果不添加信任，更新源的时候会有如下错误提示<br><img src="GPG.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list.d/gitlab_gitlab-ee.list </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打开该文件添加：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：版本号别错ubuntu16是xenial,18是bionic</span></span><br><span class="line">deb https://mirrors.tencent.com/gitlab-ce/ubuntu bionic main</span><br><span class="line"><span class="meta">#</span><span class="bash">更新源列表</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>更新源成功如下图：<br><img src="addGPG.png" alt=""></p>
<h3 id="第三步：安装gitlab"><a href="#第三步：安装gitlab" class="headerlink" title="第三步：安装gitlab"></a>第三步：安装gitlab</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure>
<p>安装成功后，如下图：<br><img src="gitlab.png" alt=""></p>
<h3 id="第四步：配置gitlab"><a href="#第四步：配置gitlab" class="headerlink" title="第四步：配置gitlab"></a>第四步：配置gitlab</h3><p>下面的命令基本要用root权限，所以建议提前<code>sudo -i</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">external_url ‘http://192.168.2.129’ <span class="comment"># 把external_url修改成访问的IP，当然更复杂的配置信息可以参考,</span></span><br><span class="line"><span class="comment">#https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab</span></span><br><span class="line"><span class="comment">#如果用nginx代理可以不配置这个。</span></span><br><span class="line">gitlab-ctl reconfigure  <span class="comment"># 开始配置</span></span><br></pre></td></tr></table></figure>
<h3 id="第五步：启动重启查看状态："><a href="#第五步：启动重启查看状态：" class="headerlink" title="第五步：启动重启查看状态："></a>第五步：启动重启查看状态：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart/start/status/stop     <span class="comment"># 通过gitlab-ctl help都能查看到该信息</span></span><br></pre></td></tr></table></figure>
<p>启动浏览器访问试试？<br><img src="502.png" alt=""><br>不慌，此时我们可以使用<code>gitlab-ctl tail</code>来查看gitlab的服务日志，通过日志可以看到8080端口被别的进程占用了，那就改个端口咯。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>此时需要修改gitlab的配置信息，如下：<br>由于默认gitlab使用80端口，所以，我们需要修改gitlab的默认端口（unicorn会占用8080端口，nginx会占用80端口）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line">nginx[<span class="string">'listen_port'</span>] = 8988 <span class="comment">#nginx外部访问的端口</span></span><br><span class="line">unicorn[<span class="string">'port'</span>] = 8989 <span class="comment">#这个端口是内部nginx跳转的端口这个可以随意设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新配置</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>
<p>如果不出意外应该可以看到站点已经可以访问，如下图：<br><img src="succeed.png" alt=""><br>这是第一次登录让你添加新密码的。输入完密码，你会发现要登录，用户名是啥？不要慌，试试：<code>root+您刚设置的新密码</code>。<br>惊喜过后，添加个test仓库试试玩玩？<br><img src="down.png" alt=""></p>
<h3 id="有没有疑问您的仓库存储在了哪里？"><a href="#有没有疑问您的仓库存储在了哪里？" class="headerlink" title="有没有疑问您的仓库存储在了哪里？"></a>有没有疑问您的仓库存储在了哪里？</h3><p>gitlab默认路径是：<code>/var/opt/gitlab/git-data/repositories</code><br>cd进去看看？看不出就对了，这是git的文件镜像，不是给人读的文件。<br>如果要进行git仓库的迁移,做如下操作</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 准备迁移之前要停止GitLab服务，防止用户写入数据。</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"><span class="meta"># 注意 'repositories'后面不带斜杠，而</span></span><br><span class="line"><span class="meta"># '/home/gitlab-data'后面是有斜杠的。</span></span><br><span class="line"> rsync -av /<span class="keyword">var</span>/opt/gitlab/git-data/repositories /home/gitlab-data/</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果需要修复权限设置，</span></span><br><span class="line"><span class="meta"># 可运行下面的命令进行修复。</span></span><br><span class="line"> gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="meta"># 再次检查下  /home/gitlab-data 的目录. 正常情况应该有下面这个子目录:</span></span><br><span class="line"><span class="meta"># repositories</span></span><br><span class="line"></span><br><span class="line"> ls /home/gitlab-data/</span><br><span class="line">repositories</span><br><span class="line"><span class="meta"># 完工! 启动GitLab，验证下是否能</span></span><br><span class="line"><span class="meta"># 通过web访问Git仓库。</span></span><br><span class="line"> gitlab-ctl start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2020/02/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。过滤器还能干啥？老东西为何又突然热了起来？假设我们要做一个爬虫程序，如何判断某个地址已经被爬过了？一个海量数据集中如何判断某个值是否存在？带着问题去思考，请看下面详解。</p>
<a id="more"></a>

<p>我们已经知道map（前面已经说过基于红黑树实现的）已经起到了很好的查找效率，如100w的数据量，我们也只需要20次查找即可。</p>
<p>就算嫌弃速度慢了，我们也可以用hashmap这样的数据结构，hashmap能保证我们O(1)查找，但是我们需要知道的是hashmap是一个空间换时间的数据结构，由一个巨大的hash(key)组成的数组，且每个数值下面还有一个列表用以保存hash碰撞的数据。4G内存空间也就是$2^{32}$字节。假设我们用的是32位hash算法也就10亿数据量，再留空一部分，以及保存hash碰撞的数据，我们一般不能存储超过5亿数据量，否则hash碰撞多了，效率会下降。</p>
<p><span style=color:red>那有没有省时省空间的算法呢？<span><br>那么这就算布隆过滤器又被人们热谈的原因了。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>由一系列hash函数转换之后得到的值作为position的<code>bitmap数据结构</code></strong>——本人自定义，不嫌麻烦的还是去百度搜吧。</p>
<p>百度盗个图，以图解说bloom算法<br><img src="bloom.jpg" alt="布隆过滤器" title="布隆过滤器"><br>这是一个通过3个hash函数得到3个pos,将bitmap的这3个pos置1，即得到了集合S转化后的布隆过滤器B。<br>如图S中的元素a,b,c都是通过3个hash得到的值作为B的下标,然后将<code>相应位置的值 | 1</code>即可。这样当判断d,e是否在集合S中的时候，同样对d,e分别做3次hash得到的3个pos,是否都为1？</p>
<blockquote>
<ol>
<li>如果不全为1，必不在集合S中；</li>
<li>如果全为1，可能在集合S中</li>
</ol>
</blockquote>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li>速度快O(1)</li>
<li>占空间小<blockquote>
<p>与hashMap相比，<br>以100w数据量为例，k次hash，也就是 1/k（当然这里k肯定是一个很小的数，k这里绝不是一个线性递减的，而是当k大到一定程度，将趋于不变，而k越大时间开销会成倍增大。具体见文末链接） Mb空间,当然这样的空间是不合理的，碰撞率接近1了，但是与hashmap相比，hashmap碰撞率也将这么高.<br>而hashmap，32位hash算法为例，约用32M空间做key，还没算value对应的list空间。<br>占$&lt; 1/32k$.</p>
</blockquote>
</li>
</ol>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol>
<li>不能删除元素，只能增加元素</li>
<li>只能判断可能在，这是一个概率结果，该算法能优化的也就是在大概率存在。不能保证存在。</li>
</ol>
<h2 id="布隆过滤器具体参数关系参考"><a href="#布隆过滤器具体参数关系参考" class="headerlink" title="布隆过滤器具体参数关系参考"></a>布隆过滤器具体参数关系参考</h2><p><a href="https://hur.st/bloomfilter" target="_blank" rel="noopener">各参数对应假阳概率关系</a></p>
<blockquote>
<p>n为容量<br>p为假阳概率<br>m为所需内存空间<br>k为hash数量</p>
</blockquote>
<iframe src="https://hur.st/bloomfilter/?n=1000000&p=1.0E-7&m=&k=" width="100%" height="100%" frameborder="0">
您的浏览器不支持iframe，请升级
</iframe>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>过滤器</tag>
        <tag>bloom</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>B树与B+树</title>
    <url>/2020/02/02/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</url>
    <content><![CDATA[<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>B树又写做B-树，做索引的时候，hash ，红黑树效率已经很高了，什么时候要用到B树？</p>
<a id="more"></a>
<p>B树的应用：当我们的内存不够支撑的时候，往往B树的效率更好。hash,红黑树都是基于内存内数据的高效查找。文件系统的索引，数据库的索引都是采用B树实现。<br>那为什么B树在磁盘访问的时候更高效呢？<br>原因：如果用二叉树，1024个节点，我们需要一个10层高的二叉树。10层高，就相当于我们需要访问10次磁盘才能找到相应值。磁盘的访问速度是远不如内存的。故二叉树性能会显得格外低，那我们必然会考虑到多叉树，如果是毫无约束的多叉树，<strong>树就可能变成一个链表，性能将降到最低状态。</strong>所以有必要对多叉树做适当的约束，而B树就是这样的一个<strong>自平衡的多叉树</strong>数据结构。</p>
<h3 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h3><p>一颗M阶B树T，满足以下条件 </p>
<ol>
<li>每个结点至多拥有M棵子树 </li>
<li>根结点至少拥有两棵子树 </li>
<li>除了根结点以外，其余每个分支结点至少拥有M/2棵子树 </li>
<li><span style=color:red> 所有的叶子结点都在同一层上 </span></li>
<li><span style=color:red>有k棵子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序</span> </li>
<li>关键字数量满足 ceil(M/2) - 1 &lt;= n &lt;= M-11</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义M的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEGREE		5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KEY_VALUE;</span><br><span class="line"><span class="comment">//B树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> &#123;</span></span><br><span class="line">    KEY_VALUE *keys;				<span class="comment">//key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">btree_node</span> **<span class="title">childrens</span>;</span>	<span class="comment">//子结点地址</span></span><br><span class="line">    <span class="keyword">int</span> num;						<span class="comment">//子结点长度应该是M-1</span></span><br><span class="line">    <span class="keyword">int</span> leaf;						<span class="comment">//是否叶子结点</span></span><br><span class="line">&#125; btree_node;</span><br><span class="line"><span class="comment">//B树的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">btree</span> &#123;</span></span><br><span class="line">    btree_node *root;</span><br><span class="line">    <span class="keyword">int</span> t;				<span class="comment">//M值</span></span><br><span class="line">&#125; btree;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol>
<li>插入值，总是从根结点开始插入</li>
<li>插入结点长度 &lt;M 直接插入</li>
<li>等于M 需要裂变，裂变从根结点开始裂变<ol>
<li>创建一个空的结点</li>
<li>将裂变位置右边的给新结点，准备将裂变位置给父节点</li>
<li>遍历父节点从i位置开始全部右移一位，给裂变点空出位置</li>
<li>将裂变点赋值给父节点i位置</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//树T的x结点从i位置开始裂变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_split_child</span><span class="params">(btree *T, btree_node *x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = T-&gt;t;</span><br><span class="line"></span><br><span class="line">    btree_node *y = x-&gt;childrens[i];<span class="comment">//y是开始裂变的结点</span></span><br><span class="line">    btree_node *z = btree_create_node(t, y-&gt;leaf);<span class="comment">//创建一个空结点位置以便插入新值</span></span><br><span class="line"></span><br><span class="line">    z-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将i右边的值先移到新的结点z中</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t<span class="number">-1</span>;j ++) &#123;</span><br><span class="line">        z-&gt;keys[j] = y-&gt;keys[j+t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;leaf == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; t;j ++) &#123;</span><br><span class="line">            z-&gt;childrens[j] = y-&gt;childrens[j+t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父结点x大于i的右移,给子结点y空出位置</span></span><br><span class="line">    y-&gt;num = t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num;j &gt;= i+<span class="number">1</span>;j --) &#123;</span><br><span class="line">        x-&gt;childrens[j+<span class="number">1</span>] = x-&gt;childrens[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;childrens[i+<span class="number">1</span>] = z;</span><br><span class="line">    <span class="comment">//key值也右移</span></span><br><span class="line">    <span class="keyword">for</span> (j = x-&gt;num<span class="number">-1</span>;j &gt;= i;j --) &#123;</span><br><span class="line">        x-&gt;keys[j+<span class="number">1</span>] = x-&gt;keys[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将y移向父节点x</span></span><br><span class="line">    x-&gt;keys[i] = y-&gt;keys[t<span class="number">-1</span>];</span><br><span class="line">    x-&gt;num += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在树T的x结点插入k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert_nonfull</span><span class="params">(btree *T, btree_node *x, KEY_VALUE k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = x-&gt;num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leaf == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) &#123;</span><br><span class="line">            x-&gt;keys[i+<span class="number">1</span>] = x-&gt;keys[i];</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;keys[i+<span class="number">1</span>] = k;</span><br><span class="line">        x-&gt;num += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在非叶子节点插入值</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; x-&gt;keys[i] &gt; k) i --;</span><br><span class="line">        <span class="comment">//需要非叶子节点数满，需要裂变</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;childrens[i+<span class="number">1</span>]-&gt;num == (<span class="number">2</span>*(T-&gt;t))<span class="number">-1</span>) &#123;</span><br><span class="line">            btree_split_child(T, x, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; x-&gt;keys[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归插入</span></span><br><span class="line">        btree_insert_nonfull(T, x-&gt;childrens[i+<span class="number">1</span>], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_insert</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int t = T-&gt;t;</span></span><br><span class="line"></span><br><span class="line">    btree_node *r = T-&gt;root;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;num == <span class="number">2</span> * T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//根结点裂变</span></span><br><span class="line">        <span class="comment">//1.为T创建一个根节点，T变成叶子节点</span></span><br><span class="line">        btree_node *node = btree_create_node(T-&gt;t, <span class="number">0</span>);</span><br><span class="line">        T-&gt;root = node;</span><br><span class="line">        <span class="comment">//2.将T加到根结点第一个位置</span></span><br><span class="line">        node-&gt;childrens[<span class="number">0</span>] = r;</span><br><span class="line">        <span class="comment">//3.将T当作叶子结点裂变</span></span><br><span class="line">        btree_split_child(T, node, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//4.在叶子结点插入新值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;keys[<span class="number">0</span>] &lt; key) i++;</span><br><span class="line">        btree_insert_nonfull(T, node-&gt;childrens[i], key);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接在叶子结点插入新值</span></span><br><span class="line">        btree_insert_nonfull(T, r, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol>
<li>找到删除节点位置</li>
<li>归并:把相邻两个节点+父节点的一个值 $\le M$,合二为一再删掉即可<br>当M为5的时候如下图：<br><img src="del1.png" alt="" title="归并删除"></li>
<li>借值:把相邻两个节点+父节点的一个值 $&gt; M$,将父节点拉下来，将子结点放父位置，再删除即可。<br>当M为5的时候如下图：<br><img src="del2.png" alt="" title="借值删除"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_merge</span><span class="params">(btree *T, btree_node *node, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">    btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////data merge</span></span><br><span class="line">    left-&gt;keys[T-&gt;t<span class="number">-1</span>] = node-&gt;keys[idx];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">        left-&gt;keys[T-&gt;t+i] = right-&gt;keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;leaf) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; T-&gt;t;i ++) &#123;</span><br><span class="line">            left-&gt;childrens[T-&gt;t+i] = right-&gt;childrens[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;num += T-&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destroy right</span></span><br><span class="line">    btree_destroy_node(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node </span></span><br><span class="line">    <span class="keyword">for</span> (i = idx+<span class="number">1</span>;i &lt; node-&gt;num;i ++) &#123;</span><br><span class="line">        node-&gt;keys[i<span class="number">-1</span>] = node-&gt;keys[i];</span><br><span class="line">        node-&gt;childrens[i] = node-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;childrens[i+<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;num -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;root = left;</span><br><span class="line">        btree_destroy_node(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除树T的node节点的key值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btree_delete_key</span><span class="params">(btree *T, btree_node *node, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx &lt; node-&gt;num &amp;&amp; key &gt; node-&gt;keys[idx]) &#123;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; node-&gt;num &amp;&amp; key == node-&gt;keys[idx]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;leaf) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = idx;i &lt; node-&gt;num<span class="number">-1</span>;i ++) &#123;</span><br><span class="line">                node-&gt;keys[i] = node-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node-&gt;keys[node-&gt;num - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            node-&gt;num--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;num == <span class="number">0</span>) &#123; <span class="comment">//root</span></span><br><span class="line">                <span class="built_in">free</span>(node);</span><br><span class="line">                T-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = node-&gt;childrens[idx];</span><br><span class="line">            node-&gt;keys[idx] = left-&gt;keys[left-&gt;num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, left, left-&gt;keys[left-&gt;num - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;childrens[idx+<span class="number">1</span>]-&gt;num &gt;= T-&gt;t) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line">            node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            btree_delete_key(T, right, right-&gt;keys[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            btree_merge(T, node, idx);</span><br><span class="line">            btree_delete_key(T, node-&gt;childrens[idx], key);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        btree_node *child = node-&gt;childrens[idx];</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Cannot del key = %d\n"</span>, key);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            btree_node *left = <span class="literal">NULL</span>;</span><br><span class="line">            btree_node *right = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                left = node-&gt;childrens[idx<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (idx + <span class="number">1</span> &lt;= node-&gt;num) </span><br><span class="line">                right = node-&gt;childrens[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((left &amp;&amp; left-&gt;num &gt;= T-&gt;t) ||</span><br><span class="line">                (right &amp;&amp; right-&gt;num &gt;= T-&gt;t)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> richR = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (right) richR = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; right) richR = (right-&gt;num &gt; left-&gt;num) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right &amp;&amp; right-&gt;num &gt;= T-&gt;t &amp;&amp; richR) &#123; <span class="comment">//borrow from next</span></span><br><span class="line">                    child-&gt;keys[child-&gt;num] = node-&gt;keys[idx];</span><br><span class="line">                    child-&gt;childrens[child-&gt;num+<span class="number">1</span>] = right-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    node-&gt;keys[idx] = right-&gt;keys[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; right-&gt;num - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">                        right-&gt;keys[i] = right-&gt;keys[i+<span class="number">1</span>];</span><br><span class="line">                        right-&gt;childrens[i] = right-&gt;childrens[i+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    right-&gt;keys[right-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    right-&gt;childrens[right-&gt;num<span class="number">-1</span>] = right-&gt;childrens[right-&gt;num];</span><br><span class="line">                    right-&gt;childrens[right-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    right-&gt;num --;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//borrow from prev</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (i = child-&gt;num;i &gt; <span class="number">0</span>;i --) &#123;</span><br><span class="line">                        child-&gt;keys[i] = child-&gt;keys[i<span class="number">-1</span>];</span><br><span class="line">                        child-&gt;childrens[i+<span class="number">1</span>] = child-&gt;childrens[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    child-&gt;childrens[<span class="number">1</span>] = child-&gt;childrens[<span class="number">0</span>];</span><br><span class="line">                    child-&gt;childrens[<span class="number">0</span>] = left-&gt;childrens[left-&gt;num];</span><br><span class="line">                    child-&gt;keys[<span class="number">0</span>] = node-&gt;keys[idx<span class="number">-1</span>];</span><br><span class="line">                    child-&gt;num ++;</span><br><span class="line"></span><br><span class="line">                    left-&gt;keys[left-&gt;num<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                    left-&gt;childrens[left-&gt;num] = <span class="literal">NULL</span>;</span><br><span class="line">                    left-&gt;num --;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!left || (left-&gt;num == T-&gt;t - <span class="number">1</span>))</span><br><span class="line">                &amp;&amp; (!right || (right-&gt;num == T-&gt;t - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &amp;&amp; left-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx<span class="number">-1</span>);					</span><br><span class="line">                    child = left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &amp;&amp; right-&gt;num == T-&gt;t - <span class="number">1</span>) &#123;</span><br><span class="line">                    btree_merge(T, node, idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btree_delete_key(T, child, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">btree_delete</span><span class="params">(btree *T, KEY_VALUE key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//调递归删除接口</span></span><br><span class="line">    btree_delete_key(T, T-&gt;root, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>首先简单说明一下B+树：<strong>B+树通常用于数据库和操作系统的文件系统中</strong>。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反，<strong>B+树只在叶子结点存储数据，其他结点只保存索引</strong>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:<br>(1)每个结点至多有m个子女；<br>(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；<br>(3)有k个子女的结点必有k个关键字。<br>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。 </p>
<ol>
<li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。 </li>
<li>如果没有节点处于违规状态则处理结束。 </li>
<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。 </li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>首先，查找要删除的值。接着从包含它的节点中删除这个值。 </li>
<li>如果没有节点处于违规状态则处理结束。 </li>
<li>如果节点处于违规状态则有两种可能情况： <ol>
<li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。 </li>
<li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li>
</ol>
</li>
</ol>
<h2 id="B-树与B-树比较"><a href="#B-树与B-树比较" class="headerlink" title="B+树与B-树比较"></a>B+树与B-树比较</h2><blockquote>
<p>B+树的优势：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>B+树的劣势：<br>1.单点查询，B-树有可能O(1),而B+树永远是B-树的最糟糕情况O(log n).</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><div style=color:red>注意</div></h2><p>这也导致在通用sql数据库中B+树更合适<br>而在mongoDb中，B-树更合适，因为对范围查找要求较低</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">这是一个很好的算法可视化学习网站</a></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>B树</tag>
        <tag>B-树</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>从二叉树到红黑树</title>
    <url>/2020/01/28/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>树有很多种，二叉树，多叉树(B-树，B+树)等，本文主要针对几种较为常用的树，做精要记录，梳理逻辑便于长时间之后的理解与记忆。</p>
<a id="more"></a>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（<code>left subtree</code>）和“右子树”（<code>right subtree</code>）。二叉树常被用于实现二叉查找树和二叉堆。</p>
<h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>由二叉树的定义，以及图中所示的二叉树的分析可以得出二叉树具有以下几个特点：</p>
<ol>
<li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<h3 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h3>除数据域外，主要区别体现形式是左右子树的表示不同</li>
<li>链式存储<br>用数组表示二叉树，二叉树中的某节点编号为i(i从1开始好理解)，左孩子编号为2i，右孩子编号为2i+1，父节点为i/2。实际情况$i&gt;=0$;左孩子为$2i+1$;右孩子为$2(i+1)$;父节点$(i-1)/2$。如下图<br><img src="heap.png" alt=""><br><img src="heapArr.png" alt=""><ul>
<li>优点：查找速度更快</li>
<li>缺点：不为<code>满二叉树</code>时，浪费了空间，扩展性差或者说插入新数据慢。</li>
</ul>
</li>
<li>链表存储<br>用链表表示二叉树，左右子树用结点指针表示<ul>
<li>优点：无空间浪费，扩展性好，插入数据快。</li>
<li>缺点：查找速度略慢。</li>
</ul>
</li>
</ol>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>记住一句话即可。</p>
<blockquote>
<p>所有叶子结点都在最下层</p>
</blockquote>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的 <strong><code>满二叉树</code></strong> 中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<blockquote>
<p>所有叶子结点都在最下层与次下层</p>
</blockquote>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>左右子树的高度相差不超过1的树为平衡二叉树，也叫AVL树。<br>注意点：<strong>实现了树的自平衡以提升树的查找效率</strong><br>如何做到自平衡的：<br><img src="rotate.png" alt="" title="自平衡操作"></p>
<ol>
<li>左旋<blockquote>
<p>1.结点的右孩子替代此结点位置<br>2.右孩子的左子树变为该结点的右子树<br>3.结点本身变为右孩子的左子树</p>
</blockquote>
</li>
<li>右旋<blockquote>
<p>1.结点的左孩子代表此结点<br>2.结点的左孩子的右子树变为结点的左子树<br>3.将此结点作为左孩子结点的右子树</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//y是x的右子结点</span></span><br><span class="line">    rbtree_node *y = x-&gt;right;  <span class="comment">// x  --&gt; y  ,  y --&gt; x,   right --&gt; left,  left --&gt; right</span></span><br><span class="line"></span><br><span class="line">    x-&gt;right = y-&gt;left; <span class="comment">//1 1</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123; <span class="comment">//1 2</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent = x-&gt;parent; <span class="comment">//1 3</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == T-&gt;nil) &#123; <span class="comment">//1 4</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x; <span class="comment">//1 5</span></span><br><span class="line">    x-&gt;parent = y; <span class="comment">//1 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T, rbtree_node *y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//x为y的左子结点</span></span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>红黑树是一种非常重要且应用广泛的数据结构。它是在AVL树的基础上加以改进优化得出的一个高效算法。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：<strong>它可以在O(log n)时间内做查找，插入和删除</strong>。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3></li>
</ol>
<ul>
<li>Linux进程调度CFS</li>
<li>Nginx Timer事件管理</li>
<li>Epoll事件块的管理</li>
<li>STL中set, multiset, map, multimap的实现<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3></li>
</ul>
<ol>
<li>结点是红色或黑色</li>
<li>根结点是黑色</li>
<li>每个叶子结点(nil)是黑色</li>
<li>每个红色结点的两个子结点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色结点)</li>
<li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</strong><br>从性质5可以知道：如果一个结点存在黑子结点，那么该结点肯定有两个子结点<br>下图Nil为叶子结点，并且它的颜色一定是黑色的。<br><img src="2392382-4996bbfb4017a3b2.png" alt="一颗简单的红黑树" title="一颗简单的红黑树"><br>由图可见，红黑树并不是一个<code>完美平衡二叉查找树</code>,根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<code>黑高平衡</code>。<br>为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如下图<br><img src="2392382-abedf3ecc733ccd5.webp" alt="结点的叫法" title="结点的叫法"></li>
</ol>
<h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。从根结点开始查找；</p>
<blockquote>
<p>若根结点为空，那么插入结点作为根结点，结束。<br>若根结点不为空，那么把根结点作为当前结点；<br>若当前结点为null，返回当前结点的父结点，结束。<br>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。<br>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；<br>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p>
</blockquote>
<p><img src="2392382-7521866b50683a24.webp" alt="数据插入" title="数据插入"></p>
<p>插入完成后，但插入结点是应该设置成什么颜色呢？<br>答案是<strong>红色</strong>。<em>因为红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡</em>。</p>
<p><img src="2392382-fa2b78271263d2c8.webp" alt="插入操作脑图" title="插入操作脑图"></p>
<h3 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h3><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。<br>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡，最后调色。<br>二叉树删除结点找替代结点有3种情情景：</p>
<p>情景1：若删除结点无子结点，直接删除<br>情景2：若删除结点只有一个子结点，用子结点替换删除结点<br>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</p>
<p>同样的，我们也是先来总体看下删除操作的所有情景，如图所示。<br><img src="2392382-edaf96e55f08c198.webp" alt="插入操作脑图" title="插入操作脑图"></p>
<h3 id="红黑树插入删除代码："><a href="#红黑树插入删除代码：" class="headerlink" title="红黑树插入删除代码："></a>红黑树插入删除代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; <span class="comment">//z ---&gt; RED</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right;<span class="comment">//y是z的叔父结点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_left_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">//z --&gt; RED</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_right_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_left_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != T-&gt;nil) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//Exist</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    rbtree_insert_fixup(T, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_delete_fixup</span><span class="params">(rbtree *T, rbtree_node *x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((x != T-&gt;root) &amp;&amp; (x-&gt;color == BLACK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">         <span class="comment">//w是x的叔父结点   </span></span><br><span class="line">            rbtree_node *w= x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_right_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                rbtree_left_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            rbtree_node *w = x-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    rbtree_left_rotate(T, w);</span><br><span class="line">                    w = x-&gt;parent-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                rbtree_right_rotate(T, x-&gt;parent);</span><br><span class="line"></span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rbtree_node *<span class="title">rbtree_delete</span><span class="params">(rbtree *T, rbtree_node *z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == T-&gt;nil) || (z-&gt;right == T-&gt;nil)) &#123;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = rbtree_successor(T, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x = y-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left) &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) &#123;</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line">        z-&gt;value = y-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;color == BLACK) &#123;</span><br><span class="line">        rbtree_delete_fixup(T, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"><a href="#我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解" class="headerlink" title="我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解"></a>我们需要知道的是红黑树也许不是最优解但是绝对是一个较优解</h3><p><span style=color:red><strong>红黑树有着目前算法中内存读写综合性能最好的数据结构</strong></span>代码要求：不要求能盲打，但是最好能对照定义敲出。另外红黑树的算法论证见算法导论。</p>
<ol>
<li>查询速度仅次于hash，但是比hash省空间，几乎等于AVL树</li>
<li>搜索稳定性能最佳，算法耗时稳定<code>O(long n)</code>（不会因为数据是顺序的、倒序的还是乱序的情况而出现耗时波动问题）</li>
<li>伸缩性好，写操作也能很快</li>
<li>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较</li>
<li>红黑树在插入和删除上优于avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">红黑树图片引用原文链接</a></li>
</ol>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>rbtree</tag>
        <tag>红黑树</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>几种经典排序算法</title>
    <url>/2020/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>几种常见排序算法比较<br>排序算法有很多，下面统计几种经典排序算法并做比较。</p>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>个人认为是最简单的排序方式，越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<blockquote>
<p>每次循环都是为了去找未排序数组中最小的那个数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])   <span class="comment">//后者比前者小就交换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = data[i];</span><br><span class="line">                data[i] = data[j];</span><br><span class="line">                data[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由<code>C. A. R. Hoare</code>在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。这和分治思想非常相似。</p>
<blockquote>
<p>对数组A[N]快速排序的算法是:</p>
<ol>
<li>设置两个变量i、j，排序开始的时候：i=0，j=N-1;</li>
<li>以第一个数组元素作为关键数据，赋值给key;</li>
<li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换; </li>
<li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换; </li>
<li>重复第3、4步，直到i=j。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = data[left];   <span class="comment">//找到关键数。这里以第一个为准</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0   </span></span><br><span class="line">    <span class="comment">/*这段代码比下面那段代码更精简，但是下面那段代码更易理解</span></span><br><span class="line"><span class="comment">    while (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">        //1.比key大的放右边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span></span><br><span class="line"><span class="comment">            j --;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[i] = data[j];</span></span><br><span class="line"><span class="comment">        //2.比key小的放左边</span></span><br><span class="line"><span class="comment">        while (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span></span><br><span class="line"><span class="comment">            i ++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        data[j] = data[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    data[i] = key;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//1.比key大的放右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt;= data[j]) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = key;      </span><br><span class="line">        <span class="comment">//2.比key小的放左边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &gt;= data[i]) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = data[i];</span><br><span class="line">        data[i] = key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    sort(data, left, i - <span class="number">1</span>);</span><br><span class="line">    sort(data, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    sort(data, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,算法适用于少量数据的排序。</p>
<blockquote>
<p>从第2个数开始，依次与前面的数比较。<br>如果比前面的数大，不用移动<br>如果比前面的数小，前面的数依次后移，直至出现不小于该值的数，或者位置已以至最前面。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历查找插入位置j</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos&gt;= <span class="number">1</span> &amp;&amp; tmpData &lt; data[pos<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                data[pos] = data[pos<span class="number">-1</span>];</span><br><span class="line">                pos--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[pos] = tmpData;<span class="comment">//找到插入位置，赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>基于插入排序的优化，类似的还有二分查找算法也叫折半查找算法。</p>
<blockquote>
<p>在直接插入排序的思维下，加快查找插入位置pos。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找，返回该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b_insert</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">int</span>* data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)   <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> npos = (left + right) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, left, npos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; data[npos])</span><br><span class="line">        <span class="keyword">return</span> b_insert(value, data, npos+<span class="number">1</span>, right);<span class="comment">//注意这里是npos+1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b_insert_sort</span><span class="params">(<span class="keyword">int</span> * data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> npos = i;</span><br><span class="line">        <span class="keyword">int</span> tmpData = data[i];	</span><br><span class="line">        <span class="keyword">if</span>(tmpData &lt; data[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            npos = b_insert(tmpData, data, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> n = i;</span><br><span class="line">            <span class="keyword">while</span>( n &gt; npos )</span><br><span class="line">            &#123;</span><br><span class="line">                data[n] = data[n<span class="number">-1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[npos] = tmpData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序法又称缩小增量法，按其设计者希尔（Donald Shell）的名字命名。</p>
<blockquote>
<p>先选定一个整数，把待排序文件中所有记录分成2个组，所有距离为 gap = length/2 的记录分在同一组内，并对每一组内的记录进行排序。<br>然后，取重复上述分组和排序的工作。当到达gap=1时，所有记录在同一组内排好序。<br>各组内的排序通常采用直接插入法。由于开始时gap的取值较大，每组内记录数较少，所以排序比较快。<br>随着gap不断减小，每组内的记录数逐步增多，但由于已经按排好序，因此排序速度也比较快</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//外层循环控制增量gap，每次缩减一倍</span></span><br><span class="line">    <span class="keyword">for</span> (gap = length / <span class="number">2</span>;gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对新的数组做 直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap;i &lt; length;i ++) &#123;</span><br><span class="line"></span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i-gap;j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; data[j];j = j - gap) &#123;</span><br><span class="line">                data[j+gap] = data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+gap] = temp;	<span class="comment">//将 temp 插入 j+gap 位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（<code>Divide and Conquer</code>）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。</p>
<blockquote>
<p>归并操作的工作原理如下：<br>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复上一步直到某一指针超出序列尾,将另一序列剩下的所有元素直接复制到合并序列尾</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start, j = middle+<span class="number">1</span>, k = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start;i &lt;= <span class="built_in">end</span>;i ++) &#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *temp, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        middle = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        merge_sort(data, temp, start, middle);</span><br><span class="line">        merge_sort(data, temp, middle+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        merge(data, temp, start, middle, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各路算法比较："><a href="#各路算法比较：" class="headerlink" title="各路算法比较："></a>各路算法比较：</h2><p>道不完的算法，最后采个图比较。<br><img src="20200225125447.png" alt=""></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>select与epoll的比较与选择</title>
    <url>/2020/01/17/select%E4%B8%8Eepoll%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>在多路复用模型上，通常有select/poll/epoll/iocp这几种。select与poll基本相似，所以本文主要分析select与epoll。首先我们编写两个简单的程序，一个select实现，一个epoll实现。</p>
<a id="more"></a>
<h2 id="select编程"><a href="#select编程" class="headerlink" title="select编程"></a>select编程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//listen成功后</span></span><br><span class="line"><span class="comment">//1.初始化fd_set</span></span><br><span class="line">    fd_set rfds, rset;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(sockfd, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_fd = sockfd;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        rset = rfds;</span><br><span class="line"><span class="comment">//2.select():该函数能返回相应的rset（wset，eset等根据相应传参返回）</span></span><br><span class="line">        <span class="keyword">int</span> nready = select(max_fd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//使用select模型</span></span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select error : %d\n"</span>, errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//3.判断select接管fd成功</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123; <span class="comment">//判断文件描述符是否是rset集合的一部分。</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">            <span class="keyword">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="comment">//4.可以调用accept		</span></span><br><span class="line">            <span class="keyword">int</span> clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">            <span class="keyword">if</span> (clientfd &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> str[INET_ADDRSTRLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recvived from %s at port %d, sockfd:%d, clientfd:%d\n"</span></span><br><span class="line">            , inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, <span class="keyword">sizeof</span>(str))</span><br><span class="line">            , ntohs(client_addr.sin_port), sockfd, clientfd);</span><br><span class="line">            <span class="keyword">if</span> (max_fd == FD_SETSIZE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"clientfd --&gt; out range\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FD_SET(clientfd, &amp;rfds);</span><br><span class="line">            <span class="keyword">if</span> (clientfd &gt; max_fd) max_fd = clientfd;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sockfd:%d, max_fd:%d, clientfd:%d\n"</span>, sockfd, max_fd, clientfd);</span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = sockfd + <span class="number">1</span>;i &lt;= max_fd;i ++) &#123;</span><br><span class="line"><span class="comment">//5.accept后，每次读写数据前，判断rset</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;rset)) &#123;           </span><br><span class="line">                <span class="keyword">char</span> <span class="built_in">buffer</span>[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> ret = recv(i, <span class="built_in">buffer</span>, BUFFER_LENGTH, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"read all data"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//6.关闭fd的时候，清除fd的rset，wset等等					</span></span><br><span class="line">                    FD_CLR(i, &amp;rfds);</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" disconnect %d\n"</span>, i);</span><br><span class="line">                    FD_CLR(i, &amp;rfds);</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv: %s, %d Bytes\n"</span>, <span class="built_in">buffer</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll编程"><a href="#epoll编程" class="headerlink" title="epoll编程"></a>epoll编程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//listen之后</span></span><br><span class="line"><span class="comment">//1.创建epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">EPOLL_SIZE</span>] = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = sockfd;</span><br><span class="line"><span class="comment">//2.epoll控制</span></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//3.等待epoll接管fd</span></span><br><span class="line">        <span class="keyword">int</span> nready = epoll_wait(epoll_fd, events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"epoll_wait\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; nready;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == sockfd) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">                <span class="keyword">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="comment">//4.可以调用accept			</span></span><br><span class="line">                <span class="keyword">int</span> clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (clientfd &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">char</span> str[INET_ADDRSTRLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recvived from %s at port %d, sockfd:%d, clientfd:%d\n"</span></span><br><span class="line">                , inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, <span class="keyword">sizeof</span>(str))</span><br><span class="line">                , ntohs(client_addr.sin_port), sockfd, clientfd);</span><br><span class="line"><span class="comment">//5.将fd添加到epoll监控起来，epoll是用红黑树管理fd的。</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;<span class="comment">//EPOLLET与EPOLLLT区别见后文</span></span><br><span class="line">                ev.data.fd = clientfd;</span><br><span class="line">                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, clientfd, &amp;ev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clientfd = events[i].data.fd;</span><br><span class="line"><span class="comment">//6.epoll返回的fd一定是可读的，所以直接recv即可</span></span><br><span class="line">                <span class="keyword">char</span> <span class="built_in">buffer</span>[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> ret = recv(clientfd, <span class="built_in">buffer</span>, BUFFER_LENGTH, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"read all data"</span>);</span><br><span class="line">                    &#125;				</span><br><span class="line">                    <span class="built_in">close</span>(clientfd);</span><br><span class="line"><span class="comment">//7.关闭fd的时候也要从epoll的监控fd中删除	</span></span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = clientfd;</span><br><span class="line">                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" disconnect %d\n"</span>, clientfd);</span><br><span class="line">                    <span class="built_in">close</span>(clientfd);</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = clientfd;</span><br><span class="line">                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv: %s, %d Bytes\n"</span>, <span class="built_in">buffer</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="epoll的ET与LT"><a href="#epoll的ET与LT" class="headerlink" title="epoll的ET与LT"></a>epoll的ET与LT</h3><p><strong>ET 边缘触发（Edge-Trigger）</strong>：轮询fd的时候数据更新时触发。相对LT更高效，但是在ET模式下，read一个fd的时候一定要把它的buffer读完，否则只能等到下次fd数据更新才能读到。<br><strong>LT 水平触发（Level-Trigger）</strong>：轮询fd的时候只要有数据就触发。默认模式，每次 epoll_wait都会返回它的事件。buffer第一次没读完下次还能读到。</p>
<h2 id="select与epoll的异同"><a href="#select与epoll的异同" class="headerlink" title="select与epoll的异同"></a>select与epoll的异同</h2><h3 id="select源码分析"><a href="#select源码分析" class="headerlink" title="select源码分析"></a>select源码分析</h3><h4 id="fd-set的定义"><a href="#fd-set的定义" class="headerlink" title="fd_set的定义"></a>fd_set的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))];</span><br><span class="line">&#125; __kernel_fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __kernel_fd_set		fd_set;</span><br></pre></td></tr></table></figure>

<h4 id="对集合操作的4个宏"><a href="#对集合操作的4个宏" class="headerlink" title="对集合操作的4个宏"></a>对集合操作的4个宏</h4><p>FD_ZERO() 清除集合<br>FD_SET()/FD_CLR() 从fd集合添加或删除fd.<br>FD_ISSET() 用于调用select()之后，判断是否有数据可读</p>
<h4 id="select执行流程"><a href="#select执行流程" class="headerlink" title="select执行流程"></a>select执行流程</h4><p>应用层调用select函数，到内核的调用顺序<code>select()-&gt;SYSCALL_DEFINE5()-&gt;kernel_select()-&gt;core_sys_select()-&gt;do_select()</code>.</p>
<h4 id="gt-kern-select"><a href="#gt-kern-select" class="headerlink" title="-&gt;kern_select()"></a>-&gt;kern_select()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, struct __kernel_old_timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这就是一个壳，直接调用kern_select()</span></span><br><span class="line">    <span class="keyword">return</span> kern_select(n, inp, outp, <span class="built_in">exp</span>, tvp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kern_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct __kernel_old_timeval __user *tvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">kernel_old_timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.用户态定时器拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) </span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.内核调用</span></span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.poll_select_finish函数主要是将拷贝到内核的定时器返回给用户态</span></span><br><span class="line">    <span class="keyword">return</span> poll_select_finish(&amp;end_time, tvp, PT_TIMEVAL, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gt-core-sys-select"><a href="#gt-core-sys-select" class="headerlink" title="-&gt;core_sys_select()"></a>-&gt;core_sys_select()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds;</span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, alloc_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line"><span class="comment">//考虑到max_fds是可能自增的，所以要加读锁避免竞态引起的fd出错</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    fdt = files_fdtable(current-&gt;files);<span class="comment">//注意一下这个函数</span></span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">     * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">     * long-words. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//内核分配集合空间，并初始化为0</span></span><br><span class="line">    <span class="built_in">size</span> = FDS_BYTES(n);</span><br><span class="line">    bits = stack_fds;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &gt; (SIZE_MAX / <span class="number">6</span>))</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">        alloc_size = <span class="number">6</span> * <span class="built_in">size</span>;</span><br><span class="line">        bits = kvmalloc(alloc_size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   <span class="built_in">size</span>;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    zero_fd_set(n, fds.res_in);</span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用do_select</span></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合拷贝回用户态</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kvfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面函数我们已经可以看出内核态会根据传入的fd集合大小分配内存，并调用do_select将结构赋值到内核fd_set,最后又将内核fd_set拷贝回用户态的fd_set.那do_select干了些啥呢？我们继续。<br>注意一下files_fdtable(current-&gt;files)这个函数；fdtable是内核为每个socket维护的fd表，实际也是一个fd指针数组。返回基地址，偏移量对应的就是fd指针。fd深层研究本文不再赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> lineno;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//fdtable定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_fds;   <span class="comment">//file指针数组长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* file指针数组基地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *close_on_exec;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *open_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *full_fds_bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="gt-do-select，"><a href="#gt-do-select，" class="headerlink" title="-&gt;do_select，"></a>-&gt;do_select，</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">    u64 slack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">__poll_t</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> busy_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先判断fd是否有效</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line"><span class="comment">//poll初始化</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = select_estimate_accuracy(end_time);</span><br><span class="line"><span class="comment">//死循环</span></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">        <span class="keyword">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, <span class="built_in">bit</span> = <span class="number">1</span>, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">__poll_t</span> mask;</span><br><span class="line"></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;</span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">                i += BITS_PER_LONG;</span><br><span class="line"><span class="comment">//这个contine意味着什么？</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, <span class="built_in">bit</span> &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">bit</span> &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//开始逐个fd轮询</span></span><br><span class="line">                f = fdget(i);</span><br><span class="line">                <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">                    wait_key_set(wait, in, out, <span class="built_in">bit</span>,</span><br><span class="line">                             busy_flag);</span><br><span class="line"><span class="comment">//调用fd的poll操作，获取对应的fd掩码。</span></span><br><span class="line">                    mask = vfs_poll(f.file, wait);</span><br><span class="line"><span class="comment">//通过poll去判断是否可读、可写、异常，并赋值给内核</span></span><br><span class="line">                    fdput(f);</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_in |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_out |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_ex |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* got something, stop busy polling */</span></span><br><span class="line">                    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                        can_busy_loop = <span class="literal">false</span>;</span><br><span class="line">                        busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * only remember a returned</span></span><br><span class="line"><span class="comment">                     * POLL_BUSY_LOOP if we asked for it</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (busy_flag &amp; mask)</span><br><span class="line">                        can_busy_loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line"><span class="comment">//抢占调度，设置need_resched后生效</span></span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span></span><br><span class="line">        <span class="keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!busy_start) &#123;</span><br><span class="line">                busy_start = busy_loop_current_time();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!busy_loop_timeout(busy_start))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec64_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//poll结束</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述源码我们可以知道select模型底层和poll都是一样的，do_select()是通过poll去轮询收集fd的读、写、异常信息。</p>
<p>综上，fd_set就是一个容量为1024字节的bitmap结构。select用三个这样的bitmap管理着读、写、异常集合，<font color=red>并没有直接管理fd,所以需要调用FD_ISSET去判断fd是否在select管理的集合中。</font>。例如：将10号fd读集合(rset)置1，那就在rset的第10位置1，当调用FD_ISSET的时候，直接<code>retrun (bool)fds_bits[fd];</code>总结select的两个问题：</p>
<ol>
<li>只要没有任何fd操作，不读不写，cpu将保持空转，cpu占有极高这也是poll的最大诟病；</li>
<li>select要么不拷贝，要么拷贝所有fd集合，一旦拷贝就要拷贝两次，用户态到内核，内核到用户态；哪怕只有1个fd有操作，都是全部拷贝，所以这也是导致select效率不高的最主要原因。</li>
</ol>
<h3 id="epoll源码分析"><a href="#epoll源码分析" class="headerlink" title="epoll源码分析"></a>epoll源码分析</h3><p>epoll的实现在内核的fs/eventpoll.c文件,epoll_create(int)函数会调用下面两个函数</p>
<h4 id="gt-eventpoll-init"><a href="#gt-eventpoll-init" class="headerlink" title="-&gt;eventpoll_init"></a>-&gt;eventpoll_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">eventpoll_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">si</span>;</span></span><br><span class="line"><span class="comment">//获取系统信息，目的是拿取低端内存信息</span></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allows top 4% of lomem to be allocated for epoll watches (per user).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//最多占用4%的低端内存用于建立事件监控</span></span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / <span class="number">25</span>) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    BUG_ON(max_user_watches &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initialize the structure used to perform epoll file descriptor</span></span><br><span class="line"><span class="comment">     * inclusion loops checks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化嵌套调用（初始化就绪队列及自旋锁）</span></span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can have many thousands of epitems, so prevent this from</span></span><br><span class="line"><span class="comment">     * using an extra cache line on 64-bit (and smaller) CPUs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;= <span class="number">8</span> &amp;&amp; <span class="keyword">sizeof</span>(struct epitem) &gt; <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates slab cache used to allocate "struct epitem" items */</span></span><br><span class="line"><span class="comment">//（slab分配器）分配内存用来存放struct epitem</span></span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, <span class="keyword">sizeof</span>(struct epitem),</span><br><span class="line">            <span class="number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates slab cache used to allocate "struct eppoll_entry" */</span></span><br><span class="line">（slab分配器）分配内存用来存放<span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span>。</span></span><br><span class="line"><span class="class">    <span class="title">pwq_cache</span> = <span class="title">kmem_cache_create</span>("<span class="title">eventpoll_pwq</span>",</span></span><br><span class="line"><span class="class">        <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">eppoll_entry</span>), 0, <span class="title">SLAB_PANIC</span>|<span class="title">SLAB_ACCOUNT</span>, <span class="title">NULL</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(eventpoll_init);</span><br></pre></td></tr></table></figure>
<h4 id="gt-do-epoll-create"><a href="#gt-do-epoll-create" class="headerlink" title="-&gt;do_epoll_create"></a>-&gt;do_epoll_create</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开一个eventpoll文件描述符——fd</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the internal data structure ("struct eventpoll").</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//创建ep实例</span></span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Creates all the items needed to setup an eventpoll file. That is,</span></span><br><span class="line"><span class="comment">     * a file structure and a free file descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//创建空的fd</span></span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建文件挂载到inode上，所有创建的file共用这一个inode</span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将file赋值给epoll的私有成员变量</span></span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line"><span class="comment">//将文件插入fd，epoll与fd通过file间接关联起来</span></span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gt-do-epoll-wait"><a href="#gt-do-epoll-wait" class="headerlink" title="-&gt;do_epoll_wait"></a>-&gt;do_epoll_wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The maximum number of event must be greater than zero */</span></span><br><span class="line">    <span class="comment">//events数组长度不合理直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify that the area passed by the user is writeable */</span></span><br><span class="line"><span class="comment">//检查用户态传入的events是否可写</span></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line"><span class="comment">//通过fd获取文件f</span></span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line"><span class="comment">//没有和ep关联的file直接报错。</span></span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(f.file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the "private_data" contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//通过文件f反向查找对应的ep</span></span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Time to fish for events ... */</span></span><br><span class="line"><span class="comment">//挂到了这个epoll的等待队列上，睡眠，等待事件到来或者超时（真正的ep_poll）</span></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gt-ep-poll"><a href="#gt-ep-poll" class="headerlink" title="-&gt;ep_poll"></a>-&gt;ep_poll</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, eavail, timed_out = <span class="number">0</span>;</span><br><span class="line">    u64 slack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> waiter = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">    <span class="keyword">ktime_t</span> expires, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//警告判断</span></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"><span class="comment">//超时判断</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">end_time</span> = <span class="title">ep_set_mstimeout</span>(<span class="title">timeout</span>);</span></span><br><span class="line"></span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">        to = &amp;expires;</span><br><span class="line">        *to = timespec64_to_ktime(end_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Avoid the unnecessary trip to the wait queue loop, if the</span></span><br><span class="line"><span class="comment">         * caller specified a non blocking operation. We still need</span></span><br><span class="line"><span class="comment">         * lock because we could race and not see an epi being added</span></span><br><span class="line"><span class="comment">         * to the ready list while in irq callback. Thus incorrectly</span></span><br><span class="line"><span class="comment">         * returning 0 back to userspace.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">        write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        eavail = ep_events_available(ep);</span><br><span class="line">        write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        <span class="keyword">goto</span> send_events;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//取event操作：</span></span><br><span class="line">fetch_events:</span><br><span class="line"><span class="comment">//1.ep是否有事件发生，没有继续等待</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep))</span><br><span class="line">        ep_busy_loop(ep, timed_out);</span><br><span class="line"><span class="comment">//2.有事件就发送</span></span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line">    <span class="keyword">if</span> (eavail)</span><br><span class="line">        <span class="keyword">goto</span> send_events;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Busy poll timed out.  Drop NAPI ID for now, we can add</span></span><br><span class="line"><span class="comment">     * it back in when we have moved a socket with a valid NAPI</span></span><br><span class="line"><span class="comment">     * ID onto the ready list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//忙等待超时，则将fd移到就绪列表末尾</span></span><br><span class="line">    ep_reset_busy_poll_napi_id(ep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We don't have any available event to return to the caller.  We need</span></span><br><span class="line"><span class="comment">     * to sleep here, and we will be woken by ep_poll_callback() when events</span></span><br><span class="line"><span class="comment">     * become available.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化一个等待队列，挂载ep到队列中，准备进入sleep，直到被ep_poll_callback唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (!waiter) &#123;</span><br><span class="line">        waiter = <span class="literal">true</span>;</span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line"></span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">         * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment">         * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//线程sleep，直到被ep_poll_callback唤醒</span></span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Always short-circuit for fatal signals to allow</span></span><br><span class="line"><span class="comment">         * threads to make a timely exit without the chance of</span></span><br><span class="line"><span class="comment">         * finding more events available and fetching</span></span><br><span class="line"><span class="comment">         * repeatedly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">            res = -EINTR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//有就绪事件，唤醒</span></span><br><span class="line">        eavail = ep_events_available(ep);</span><br><span class="line">        <span class="keyword">if</span> (eavail)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//有信号产生，唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">            res = -EINTR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//等待超时，唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line"><span class="comment">//发送事件到用户态：</span></span><br><span class="line">send_events:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">     * there's still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">     * more luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line"><span class="comment">//事件发送不成功或者超时继续等待</span></span><br><span class="line">        <span class="keyword">goto</span> fetch_events;</span><br><span class="line"><span class="comment">//将ep移除等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (waiter) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//事件发送成功，返回准备数据copy给用户态</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gt-epoll-ctl"><a href="#gt-epoll-ctl" class="headerlink" title="-&gt;epoll_ctl"></a>-&gt;epoll_ctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    error = -EFAULT;</span><br><span class="line"><span class="comment">//如果是更改或者添加那就需要把从用户空间将epoll_event结构copy到内核空间</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    error = -EBADF;</span><br><span class="line"><span class="comment">//从epoll获取文件f</span></span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the "struct file *" for the target file */</span></span><br><span class="line">    tf = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tf.file)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The target file descriptor must support poll */</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line"><span class="comment">//判断fd是否支持poll</span></span><br><span class="line">    <span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if EPOLLWAKEUP is allowed */</span></span><br><span class="line"><span class="comment">//检查ep是否是EPOLLWAKEUP状态</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">        ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the file descriptor</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file. And also we do not permit</span></span><br><span class="line"><span class="comment">     * adding an epoll file descriptor inside itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line"><span class="comment">//判断传入的fd是不是自身，判断epfd是不是epoll文件</span></span><br><span class="line">    <span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span></span><br><span class="line"><span class="comment">     * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.</span></span><br><span class="line"><span class="comment">     * Also, we do not currently supported nested exclusive wakeups.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//EPOLLEXCLUSIVE标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的“惊群”问题</span></span><br><span class="line"><span class="comment">//多线程，以及epoll_create在fork之前的多进程可以使用EPOLLEXCLUSIVE避免惊群</span></span><br><span class="line"><span class="comment">//如果是epoll_create在fork之后的多进程，则要用户自己解决惊群问题</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line"><span class="comment">//epoll仅在EPOLL_CTL_ADD时添加到唤醒队列，</span></span><br><span class="line"><span class="comment">//因此不允许有EPOLLEXCLUSIVE事件时进行EPOLL_CTL_MOD操作。</span></span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">            <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"><span class="comment">//不支持嵌套epoll的独占唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">                (epds.events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">            <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the "private_data" contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When we insert an epoll file descriptor, inside another epoll file</span></span><br><span class="line"><span class="comment">     * descriptor, there is the change of creating closed loops, which are</span></span><br><span class="line"><span class="comment">     * better be handled here, than in more critical paths. While we are</span></span><br><span class="line"><span class="comment">     * checking for loops we also determine the list of files reachable</span></span><br><span class="line"><span class="comment">     * and hang them on the tfile_check_list, so we can check that we</span></span><br><span class="line"><span class="comment">     * haven't created too many possible wakeup paths.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We do not need to take the global 'epumutex' on EPOLL_CTL_ADD when</span></span><br><span class="line"><span class="comment">     * the epoll file descriptor is attaching directly to a wakeup source,</span></span><br><span class="line"><span class="comment">     * unless the epoll file descriptor is nested. The purpose of taking the</span></span><br><span class="line"><span class="comment">     * 'epmutex' on add is to prevent complex toplogies such as loops and</span></span><br><span class="line"><span class="comment">     * deep wakeup paths from forming in parallel through multiple</span></span><br><span class="line"><span class="comment">     * EPOLL_CTL_ADD operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;</span><br><span class="line"><span class="comment">//如果f没有被epoll监听，则添加到f_tfile_llink到epoll的tfile_check_list</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;f.file-&gt;f_ep_links) ||</span><br><span class="line">                        is_file_epoll(tf.file)) &#123;</span><br><span class="line">            full_check = <span class="number">1</span>;</span><br><span class="line">            mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">            mutex_lock(&amp;epmutex);</span><br><span class="line">            <span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">                error = -ELOOP;</span><br><span class="line">                <span class="keyword">if</span> (ep_loop_check(ep, tf.file) != <span class="number">0</span>) &#123;</span><br><span class="line">                    clear_tfile_check_list();</span><br><span class="line">                    <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                list_add(&amp;tf.file-&gt;f_tfile_llink,</span><br><span class="line">                            &amp;tfile_check_list);</span><br><span class="line">            mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">                tep = tf.file-&gt;private_data;</span><br><span class="line">                mutex_lock_nested(&amp;tep-&gt;mtx, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to lookup the file inside our RB tree, Since we grabbed "mtx"</span></span><br><span class="line"><span class="comment">     * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="comment">     * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//fd红黑树上查找epi</span></span><br><span class="line">    epi = ep_find(ep, tf.file, fd);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            epds.events |= EPOLLERR | EPOLLHUP;</span><br><span class="line"><span class="comment">//如果增加：找不到，插入fd</span></span><br><span class="line">            error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">if</span> (full_check)</span><br><span class="line">            clear_tfile_check_list();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line"><span class="comment">//如果删除：找到了，直接删除</span></span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line"><span class="comment">//如果修改：找到了，才修改</span></span><br><span class="line">            <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">                epds.events |= EPOLLERR | EPOLLHUP;</span><br><span class="line">                error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tep != <span class="literal">NULL</span>)</span><br><span class="line">        mutex_unlock(&amp;tep-&gt;mtx);</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">    <span class="keyword">if</span> (full_check)</span><br><span class="line">        mutex_unlock(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">    fdput(tf);</span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="epoll为什么比select强？"><a href="#epoll为什么比select强？" class="headerlink" title="epoll为什么比select强？"></a>epoll为什么比select强？</h3><p>select会将3个fd集合从用户空间拷贝到内核，待读取完后，又从内核空间拷贝到用户空间，且每次都是将所有fd集合都拷贝走。<br>而epoll设计了一个就绪队列，这个就绪队列，内核态和用户态都能访问。当epoll将fd添加到队列之后，用户态可以直接读取。<br>epoll_ctrl：实现了一个管理fd的红黑树，一个个fd加入到集合中。当fd有数据的时候，将相应fd加入到就绪队列<br>epoll_wait: 就绪队列的fd拷贝出来<br>当1024个并发以内，建议select,超过用epoll，epoll能做到100w的并发。<br><span color=red>总之，select适合低并发高密度传输</span></p>
<h3 id="epoll与iocp的区别"><a href="#epoll与iocp的区别" class="headerlink" title="epoll与iocp的区别"></a>epoll与iocp的区别</h3><p>iocp是真正意义上的异步io设计,而epoll只是在fd的管理上做了优化。<br>epoll关注的是io是否有数据可读写。<br>iocp关注的是io是否已经读写完成。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>epoll</tag>
        <tag>iocp</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核编译与升级</title>
    <url>/2020/01/17/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>一，Linux内核源码下载</p>
<p>在<a href="http://www.kernel.org/" target="_blank" rel="noopener">Linux官网</a>下载对应的内核代码<br><img src="20200117143333282.png" alt=""></p>
<a id="more"></a>
<p>建议下载文档版本源码，解压到当前目录。</p>
<p>二、编译内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.解压</span></span><br><span class="line">xd -d linux_xxx.tar.xd</span><br><span class="line"> </span><br><span class="line">tar -xvf linux_xxx.tar</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.拷贝配置文件到当前目录</span></span><br><span class="line">cp /boot/config-xxx ./.config</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3.编译图型菜单</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p><img src="20200117143836562.png" alt=""></p>
<p> save保存。退出后，即可开始编译内核。建议系统空闲空间在30g以上，因为编译后的系统有十多g。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译内核，j后面的数字是cpu总核心数。这样编译速度更快</span></span><br><span class="line">make -j8</span><br><span class="line"><span class="comment">#编译组件</span></span><br><span class="line">make modules</span><br><span class="line"><span class="comment">#安装组件</span></span><br><span class="line">make modules_install</span><br><span class="line"><span class="comment">#生成镜像3</span></span><br><span class="line">make bzImage</span><br></pre></td></tr></table></figure>
<p>三、安装内核步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp arch/x86/boot/bzImage /boot/vmlinux-4.xxx</span><br><span class="line">cp .config /boot/config-4.xxx</span><br><span class="line"><span class="built_in">cd</span> /lib/modules/4.xxx/</span><br><span class="line">update-initramfs -c -k 4.xxx</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure>
<p>四、依赖库安装</p>
<p>编译过程出现错误，可能需要安装一下库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符端处理库，显示菜单，需要这个依赖</span></span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"><span class="comment">#ssl库</span></span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line"><span class="comment">#bc</span></span><br><span class="line">sudo apt-get install bc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO模型</title>
    <url>/2020/01/02/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>网络 IO，会涉及到两个系统对象，<span style=color:#ff3366>一个是用户空间调用IO的进程或者线程，另一个是内核空间的内核系统</span>，比如发生 IO 操作 read 时，它会经历两个阶段： </p>
<ol>
<li>等待数据准备就绪 </li>
<li>将数据从内核拷贝到进程或者线程中。</li>
</ol>
<p>因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型 。本文主要介绍五种网络IO模型</p>
<a id="more"></a>
<h2 id="阻塞IO-blocking-io"><a href="#阻塞IO-blocking-io" class="headerlink" title="阻塞IO(blocking io)"></a>阻塞IO(blocking io)</h2><p>在 linux 中，默认情况下所有的 socket 都是 blocking，一个典型的读操作流程<br><img src="blocking.png" alt="" title="blocking io"><br>当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于 <code>network io</code> 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包）， 这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果， 用户进程才解除 block 的状态，重新运行起来。<br>所以，<span style=color:#ff3366>blocking IO 的特点就是在 IO 执行的两个阶段（等待数据和拷贝数据两个阶段）都被 block 了</span>。<br>一般程序员接触到的网络编程都是从 <code>listen()</code>、<code>send()</code>、<code>recv()</code> 等接口开始的， 这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一 个简单地“一问一答”的服务器。<br><img src="block.png" alt="" title="一问一答服务器"><br>大部分的 <code>socket</code> 接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是 IO 接口） 不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返 回。 实际上，除非特别指定，几乎所有的 IO 接口 ( 包括 <code>socket</code> 接口 ) 都是阻塞型的。这给 网络编程带来了一个很大的问题，如在调用 <code>send()</code>的同时，线程将被阻塞，在此期间，线程 将无法执行任何运算或响应任何的网络请求。 一个简单的改进方案是在服务器端使用多线程（或多进程）。<span style=color:#ff3366><strong>多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接</strong></span>。具体使用多进程还是多进程，并没有一个特定的模式。</p>
<blockquote>
<p>多线程还是多进程的选择：<br>传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问， 则进程较为安全。通常，使用 <code>pthread_create ()</code>创建新线程，<code>fork()</code>创建新进程。 </p>
</blockquote>
<p>我们让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型<br><img src="multiThreadsvr.png" alt=""></p>
<center>多线程服务器模型</center>

<blockquote>
<p>在上述的<code>线程/时间</code>图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。 很多初学者可能不明白为何一个 socket 可以 accept 多次。实际上 socket 的设计者 可能特意为多客户机的情况留下了伏笔，让 accept()能够返回一个新的 socket。下面是 accept 接口的原型：<code>int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</code><br> 输入参数 s 是从 <code>socket()</code>，<code>bind()</code>和 <code>listen()</code>中沿用下来的 socket 句柄。执行完 <code>bind()</code>和 <code>listen()</code>后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用 <code>accept()</code>接口正是从 <code>socket s</code> 的请求队列抽 取第一个连接信息，创建一个与 <code>s</code> 同类的新的 <code>socket</code> 返回句柄。新的 <code>socket</code> 句柄即是后 续 <code>read()</code>和 <code>recv()</code>的输入参数。如果请求队列当前没有请求，则 <code>accept()</code> 将进入阻塞 状态直到有请求进入队列。</p>
</blockquote>
<p> <strong>上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实 并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据 系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</strong> </p>
<p> 很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在<span style=color:#ff3366>减少创建和销毁线程的频率</span>，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接,<span style=color:#ff3366>减少创建和关闭连接的频率</span>。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如 <code>websphere</code>、<code>tomcat</code> 和各种<code>数据库</code>等。 但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用 <code>IO</code> 接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p>
<p>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。<strong>总之，多线程模型可以方便高效的 解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p>
<h2 id="非阻塞-IO（non-blocking-IO）"><a href="#非阻塞-IO（non-blocking-IO）" class="headerlink" title="非阻塞 IO（non-blocking IO）"></a>非阻塞 IO（non-blocking IO）</h2><p>Linux 下，可以通过设置 <code>socket</code> 使其变为 <code>non-blocking</code>。当对一个 <code>non-blocking socket</code> 执行读 操作时，流程是这个样子:<br><img src="non-blockingio.png" alt=""></p>
<center>非阻塞 IO</center>

<blockquote>
<p>从图中可以看出，当用户进程发出 read 操作时，如果 <code>kernel</code> 中的数据还没有准备好，那 么它并不会 <code>block</code> 用户进程，而是立刻返回一个 <code>error</code>。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 <code>error</code> 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 <code>kernel</code> 中的数据 准备好了，并且又再次收到了用户进程的 <code>system call</code>，那么它马上就将数据拷贝到了用 户内存，然后返回，所以，在<code>非阻塞式 IO</code> 中，用户进程其实是需要不断的主动询问 <code>kernel</code> 数据准备好了没有。 在非阻塞状态下，<code>recv()</code> 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中， </p>
</blockquote>
<ul>
<li>recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数； </li>
<li>recv() 返回 0，表示连接已经正常断开； </li>
<li>recv() 返回 -1，且 <code>errno</code> 等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作还没执行完成； </li>
<li>recv() 返回 -1，且 <code>errno</code> 不等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作遇到系统错误 <code>errno</code>。</li>
</ul>
<p><strong>非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。</strong>使用如下 的函数可以将某句柄 <code>fd</code> 设为非阻塞状态。<br><code>fcntl( fd, F_SETFL, O_NONBLOCK );</code><br>下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。<br><img src="non-blocking-single.png" alt=""></p>
<center>使用非阻塞io的单线程服务器</center>

<blockquote>
<p>可以看到服务器线程可以通过循环调用 <code>recv()</code>接口，可以在单个线程内实现对所有连 接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用 <code>recv()</code>将大幅度推高 CPU 占用率；此外，在这个方案中 <code>recv()</code>更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如 <code>select()多路复用模式</code>， 可以一次检测多个连接是否活跃。 </p>
</blockquote>
<p><font color=red>综上两种方式，我们发现无论阻塞非阻塞，主线程与子线程都是一直占用着cpu的（空转，就算使用了sleep，也会定时唤醒线程）。对于高并发情景这绝不是一种合理的设计，我们期待一种更高效的由内核通知我们唤醒线程的方式，有数据读写时唤醒，无数据读写就保持挂起状态。</font></p>
<h2 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h2><p><code>IO multiplexing</code> 这个词可能有点陌生，但是提到 <code>select/poll/epoll</code>，大概就都能明白了。有些地方 也称这种 <code>IO</code> 方式为事件驱动 <code>IO</code>(<code>event driven IO</code>)。我们都知道，<code>select/poll/epoll</code> 的好处就在于单个 <code>process</code> 就可以同时处理多个网络连接的 IO。它的基本原理就是 <code>select/poll/epoll</code> 这个 <code>function</code> 会不断的轮询所负责的所有 <code>socket</code>，当某个 <code>socket</code> 有数据到达了，就通知用户进程。它的流程如图：<br><img src="io-multiplexing.png" alt=""></p>
<center>IO多路复用</center>

<blockquote>
<p>当用户进程调用了 <code>select</code>，那么整个进程会被 <code>block</code>，而同时，<code>kernel</code> 会“监视”所有 <code>select</code> 负责的 <code>socket</code>，当任何一个 <code>socket</code> 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从 <code>kernel</code> 拷贝到用户进程。 这个图和 <code>blocking IO</code> 的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(<code>select</code> 和 <code>read</code>)，而 <code>blocking IO</code> 只调用了一个系统调用(<code>read</code>)。 但是使用 <code>select</code> 以后最大的优势是用户可以在一个线程内同时处理多个 <code>socket</code> 的 <code>IO 请求</code>。用户可以注册多个 <code>socket</code>，然后不断地调用 <code>select</code> 读取被激活的 <code>socket</code>，即可达到 在同一个线程内同时处理多个 <code>IO</code> 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。（多说一句：所以，如果处理的连接数不是很高的话，使用 <code>select/epoll</code> 的 <code>web server</code> 不一定比使用 <code>multi-threading</code> + <code>blocking IO</code> 的 <code>web server</code> 性能更好，可能延迟还更大。<code>select/epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在多路复用模型中，对于每一个 <code>socket</code>，一般都设置成为 <code>non-blocking</code>，但是，上图所示，整个用户的 <code>process</code> 其实是一直被 <code>block</code> 的。只不过 <code>process</code> 是被 <code>select</code> 这个函数 <code>block</code>，而不是被 <code>socket IO</code> 给 <code>block</code>。因此 <code>select()</code>与<code>非阻塞IO</code> 类似。<br>大部分 Unix/Linux 都支持 select 函数，该函数用于探测多个文件句柄的状态变化。 下面给出 select 接口的原型：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_ZERO(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set* fds)      </span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fds)     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds</span></span></span><br><span class="line"><span class="function"><span class="params">    , fd_set *exceptfds, struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>这里，<code>fd_set</code> 类型可以简单的理解为按 <code>bit</code> 位标记句柄的队列，例如要在某 <code>fd_set</code> 中标记一个值为 16 的句柄，则该 <code>fd_set</code> 的第 16 个 bit 位被标记为 1。具体的置位、验证 可使用 <code>FD_SET</code>、<code>FD_ISSET</code> 等宏实现。在 <code>select()</code>函数中，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 同时作为输入参数和输出参数。如果输入的 <code>readfds</code> 标记了 16 号句柄，则 <code>select()</code>将检测 16 号句柄是否可读。在 <code>select()</code>返回后，可以通过检查 <code>readfds</code> 有否标 记 16 号句柄，来判断该“可读”事件是否发生。另外，用户可以设置 <code>timeout</code> 时间。 下面将重新模拟上例中从多个客户端接收数据的模型。<br><img src="select.png" alt=""></p>
<center>select 模型</center>

<blockquote>
<p>上述模型只是描述了使用 <code>select()</code>接口同时从多个客户端接收数据的过程；由于 <code>select()</code> 接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个客户端提供独立问答服务的服务器系统。 </p>
</blockquote>
<p><img src="select-event.png" alt=""></p>
<center>基于事件驱动的select模型</center>

<blockquote>
<p>这里需要指出的是，客户端的一个 <code>connect()</code> 操作，将在服务器端激发一个“可读事件”，所以 <code>select()</code> 也能探测来自客户端的 <code>connect()</code> 行为。 </p>
</blockquote>
<p>上述模型中，最关键的地方是如何动态维护 <code>select()</code>的三个参数 <code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>。作为输入参数，<code>readfds</code> 应该标记所有的需要探测的“可读事件”的句柄， 其中永远包括那个探测 <code>connect()</code> 的那个“母”句柄；同时，<code>writefds</code> 和 <code>exceptfds</code> 应 该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 <code>FD_SET()</code> 标记 )。 作为输出参数，<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 中的保存了 <code>select()</code> 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用 <code>FD_ISSET()</code>检查 )，以确定到底哪些句柄发生了事件。</p>
<p>上述模型主要模拟的是“一问一答”的服务流程，所以如果 <code>select()</code>发现某句柄捕捉到了“可读事件”，服务器程序应及时做<code>recv()</code>操作，并根据接收到的数据准备好待发送数据， 并将对应的句柄值加入 <code>writefds</code>，准备下一次的“可写事件”的 <code>select()</code>探测。同样，如果 <code>select()</code>发现某句柄捕捉到“可写事件”，则程序应及时做 <code>send()</code>操作，并准备好下一 次的“可读事件”探测准备。<br><strong>这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发 某个特定的响应。我们可以将这种模型归类为“事件驱动模型”。</strong><br>相比其他模型，使用 <code>select()</code> 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。 </p>
<p>但这个模型依旧有着很多问题。</p>
<ol>
<li>首先 <code>select()</code>接口并不是实现“事件驱动”的最好选择。 因为当需要探测的句柄值较大时，<code>select()</code>接口本身需要消耗大量时间去轮询各个句柄。 很多操作系统提供了更为高效的接口，如<code>linux</code>提供了<code>epoll</code>，<code>BSD</code>提供了<code>kqueue</code>，<code>Solaris</code> 提供了<code>/dev/poll</code>，…。如果需要实现更高效的服务器程序，类似 epoll 这样的接口更被推 荐。遗憾的是不同的操作系统特供的 epoll 接口有很大差异，所以使用类似于 epoll 的接 口实现具有较好跨平台能力的服务器会比较困难。 </li>
<li>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整 个模型是灾难性的。如，庞大的执行体 1 将直接导致响应事件 2 的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。 </li>
</ol>
<p>幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有 <code>libevent</code> 库，还有作为 <code>libevent</code> 替代者的 <code>libev</code> 库。这些库会根据操作系统的特点选择 最合适的事件探测接口，并且加入了信号(<code>signal</code>) 等技术以支持异步响应，这使得这些库成为构建事件驱动模型的不二选择。下章将介绍如何使用 <code>libev</code> 库替换 <code>select</code> 或 <code>epoll</code> 接口，实现高效稳定的服务器模型。<br>实际上，<code>Linux</code> 内核从 2.6 开始，也引入了支持异步响应的 IO 操作，如 <code>aio_read</code>, <code>aio_write</code>，这就是异步IO。</p>
<h2 id="异步IO（Asynchronous-I-O）"><a href="#异步IO（Asynchronous-I-O）" class="headerlink" title="异步IO（Asynchronous I/O）"></a>异步IO（Asynchronous I/O）</h2><p>Linux 下的 asynchronous IO 用在磁盘 IO 读写操作，不用于网络 IO，从内核 2.6 版本才开始引 入。先看一下它的流程<br><img src="asynchrIO.png" alt=""></p>
<center>异步IO</center>

<blockquote>
<p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 <code>kernel</code> 的角度，当它受到一个 <code>asynchronous read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何 <code>block</code>。然后，<code>kernel</code> 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 <code>signal</code>，告诉它 <code>read</code> 操作完成了。 </p>
</blockquote>
<p><strong>异步 IO 是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。</strong></p>
<p>到目前为止，已经将四个 IO 模型都介绍完了。<font size=4>现在回过头来回答最初的两个问题： <code>blocking</code> 和 <code>non-blocking</code> 的区别在哪?<code>synchronous IO</code> 和 <code>asynchronous IO</code> 的区别在哪?</font></p>
<blockquote>
<p>先回答最简单的这个：<code>blocking</code> 与 <code>non-blocking</code>。前面的介绍中其实已经很明确的 说明了这两者的区别。调用 <code>blocking IO</code> 会一直 <code>block</code> 住对应的进程直到操作完成，而 <code>non-blocking IO</code> 在 <code>kernel</code> 还在准备数据的情况下会立刻返回。<br>两者的区别就在于 <code>synchronous IO</code> 做<font color=red>“IO operation”</font>的时候会将 <code>process</code> 阻塞。 按照这个定义，之前所述的 <code>blocking IO</code>，<code>non-blocking IO</code>，<code>IO multiplexing</code> 都属于 <code>synchronous IO</code>。有人可能会说，<code>non-blocking IO</code>并没有被 <code>block</code> 啊。这里有个非常 “狡猾”的地方，<font color=red>定义中所指的”IO operation”是指真实的 IO 操作，就是例子中的 read 这个系统调用。</font><code>non-blocking IO</code> 在执行 <code>read</code> 这个系统调用的时候，如果 <code>kernel</code> 的数据没有准备好，这时候不会 <code>block</code> 进程。但是当 <code>kernel</code> 中数据准备好的时候，<code>read</code> 会将数据 从 <code>kernel</code> 拷贝到用户内存中，这个时候进程是被 <code>block</code> 了，在这段时间内进程是被 <code>block</code> 的。而 <code>asynchronous IO</code> 则不一样，当进程发起 IO 操作之后，就直接返回再也不理睬了， 直到<code>kernel</code>发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被<code>block</code>。</p>
</blockquote>
<h2 id="信号驱动IO（signal-driven-I-O，-SIGIO）"><a href="#信号驱动IO（signal-driven-I-O，-SIGIO）" class="headerlink" title="信号驱动IO（signal driven I/O， SIGIO）"></a>信号驱动IO（signal driven I/O， SIGIO）</h2><p>首先我们允许套接口进行信号驱动 I/O,并安装一个信号处理函数，进程继续运行并不阻 塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函 数处理数据。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后既可 以在信号处理函数中调用 read 读取数据报，并通知主循环数据已准备好待处理，也可以立 即通知主循环，让它来读取数据报。无论如何处理 SIGIO 信号，这种模型的优势在于等待数 据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了 select 的阻塞与轮询，当 有活跃套接字时，由注册的 handler 处理。<br><img src="singalIO.png" alt=""></p>
<center>信号驱动IO</center>

<blockquote>
<p>经过上面的介绍，会发现 <code>non-blocking IO</code> 和 <code>asynchronous IO</code> 的区别还是很明显的。在 <code>non-blocking IO</code> 中，虽然进程大部分时间都不会被 <code>block</code>，但是它仍然要求进程去主动的 <code>check，</code> 并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而 <code>asynchronous IO</code> 则完全不同。它就像是用户进程将整个 <code>IO</code> 操作交给了他人（<code>kernel</code>）完 成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 IO 操作的状态，也不需要主动的去拷贝数据.</p>
</blockquote>
<h2 id="服务器模型-Reactor-与-Proactor"><a href="#服务器模型-Reactor-与-Proactor" class="headerlink" title="服务器模型 Reactor 与 Proactor"></a>服务器模型 Reactor 与 Proactor</h2><p>对高并发编程，网络连接上的消息处理，可以分为两个阶段：等待消息准备、消息处理。当使用默认的阻塞套接字时（例如上面提到的 1 个线程捆绑处理 1 个连接），往往是把 这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了高并发下线程会频繁的睡眠、唤醒，从而影响了 CPU 的使用效率。<br>高并发编程方法当然就是把两个阶段分开处理。即，等待消息准备好的代码段，与处理消息的代码段是分离的。当然，这也要求套接字必须是非阻塞的，否则，处理消息的代码段 很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。那么问题来了，<strong>等待消息准备好这个阶段怎么实现？</strong>它毕竟还是等待，这意味着线程还是要睡眠的！解决办法就是，线程主动查询，或者让 1 个线程为所有连接而等待！这就是 IO 多路复用了。多路复用就是处理 等待消息准备好这件事的，但它可以同时处理多个连接！它也可能“等待”，所以它也会导致 线程睡眠，然而这不要紧，因为它一对多、它可以监控所有连接。这样，当我们的线程被唤醒执行时，就一定是有一些连接准备好被我们的代码执行了。<br>作为一个高性能服务器程序通常需要考虑处理三类事件： <strong>I/O 事件，定时事件及信号</strong>。 下面介绍两种高效的事件处理模型：Reactor 和 Proactor。</p>
<h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><p>首先来回想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将 结果和控制权返回给程序，程序继续处理。Reactor 释义“反应堆”，是一种事件驱动机制。 和普通函数调用的不同之处在于：应用程序不是主动的调用某个 API 完成处理，而是恰恰相反，Reactor 逆置了事件处理流程，<font color=red>应用程序需要提供相应的接口并注册到 Reactor 上， 如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</font><br><img src="reactor-class.png" alt=""></p>
<center>reactor模式uml图</center>
Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，中心思想是将所有要处理的 I/O 事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上； 一旦有 I/O 事件到来或是准备就绪(文件描述符或 socket 可读、写)，多路复用器返回并将事 先注册的相应 I/O 事件分发到对应的处理器中。 

<p><strong>Reactor 模型有三个重要的组件：</strong> </p>
<ul>
<li>多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。 </li>
<li>事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。 </li>
<li>事件处理器：负责处理特定事件的处理函数。 </li>
</ul>
<p><img src="reactor.png" alt=""></p>
<center>reactor模式时序图</center>

<p>具体流程如下： </p>
<ol>
<li>注册读就绪事件和相应的事件处理器；  </li>
<li>事件分离器等待事件； </li>
<li>事件到来，激活分离器，分离器调用事件对应的处理器； </li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ol>
<p>Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点： </p>
<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的； </li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进 程的切换开销；</li>
<li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源； </li>
<li>可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；</li>
</ul>
<p>Reactor 模型开发效率上比起直接使用 IO 复用要高，它通常是单线程的，设计目标是希望单线程使用一颗 CPU 的全部资源，但也有附带优点，即每个事件处理中很多时候可以不考虑共享资源的互斥访问。可是缺点也是明显的，现在的硬件发展，已经不再遵循摩尔定律，CPU 的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，当程序需要使用多核资源时，Reactor 模型就会悲剧, 为什么呢？<br>如果程序业务很简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开启多个反应堆，每个反应堆对应一颗 CPU 核心，这些反应堆上跑的请求互不相关，这是完全可以利用多核的。例如: Nginx 这样的 http 静态服务器。 </p>
<h3 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h3><p><img src="proactor_uml.jpg" alt=""></p>
<center>proactor模式uml图</center>

<p><img src="proactor_flow.png" alt=""></p>
<center>proactor模式时序图</center>

<p><code>Proactor</code>译作“前摄器模式”是设计模式中重要的一种，具体流程如下： </p>
<ol>
<li>处理器发起异步操作，并关注 I/O 完成事件 </li>
<li>事件分离器等待操作完成事件 </li>
<li>分离器等待过程中，内核并行执行实际的 I/O 操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成 </li>
<li>I/O 完成后，通过事件分离器呼唤处理器 </li>
<li>事件处理器处理用户自定义缓冲区中的数据 </li>
</ol>
<p>从上面的处理流程，我们可以发现 <code>proactor</code> 模型最大的特点就是使用异步 I/O。所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操 作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。       </p>
<blockquote>
<p><code>Proactor</code> 增加了编程的复杂度，但给工作线程带来了更高的效率。<code>Proactor</code> 可以在 系统态将读写优化，利用 I/O 并行能力，提供一个高性能单线程模型。在 <code>windows</code> 上， 由于没有 <code>epoll</code> 这样的机制，因此提供了 <code>IOCP</code> 来支持高并发， 由于操作系统做了较好的优化，<code>windows</code> 较常采用 <code>Proactor</code> 的模型利用完成端口来实现服务器。在 <code>linux</code> 上，在 2.6 内核出现了 <code>aio</code> 接口，但 <code>aio</code> 实际效果并不理想，它的出现，主要是解决 <code>poll</code> 性能不佳的问题，但实际上经过测试，<code>epoll</code> 的性能高于 <code>poll+aio</code>，并且 <code>aio</code> 不能处理 <code>accept</code>， 因此 linux 主要还是以 <code>Reactor</code> 模型为主。</p>
</blockquote>
<p>在不使用操作系统提供的异步 I/O 接口的情况下，还可以使用 <code>Reactor</code> 来模拟 <code>Proactor</code>， 差别是：使用异步接口可以利用系统提供的读写并行能力，而在模拟的情况下，这需要在用户态实现。具体的做法如下： </p>
<ol>
<li>注册读事件（同时再提供一段缓冲区） </li>
<li>事件分离器等待可读事件 </li>
<li>事件到来，激活分离器，分离器（立即读数据，写缓冲区）调用事件处理器 </li>
<li>事件处理器处理数据，删除事件(需要再用异步接口注册)            </li>
</ol>
<p>我们知道，<code>Boost.asio</code> 库采用的即为 <code>Proactor</code> 模型。不过 <code>Boost.asio</code> 库在 <code>Linux</code> 平台采用 <code>epoll</code> 实现的 <code>Reactor</code> 来模拟 <code>Proactor</code>，并且另外开了一个线程来完成读写调度。 </p>
<h3 id="同步-I-O-模拟-Proactor-模型"><a href="#同步-I-O-模拟-Proactor-模型" class="headerlink" title="同步 I/O 模拟 Proactor 模型"></a>同步 I/O 模拟 Proactor 模型</h3><p><img src="11.png" alt=""></p>
<center>proactor模式流程图</center>

<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 </li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。 </li>
<li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据， 直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后 往 epoll 内核事件表中注册 socket 上的写就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 可写。 </li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户 请求的结果。 </li>
</ol>
<p>两个模式的相同点，<font color=red>都是对某个 IO 事件的事件通知(即告诉某个模块，这个 IO 操作可以进行或已经完成)。在结构上两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、 查询设备是否可操作(同步)，然后当条件满足时，就回调注册处理函数。</font> </p>
<p>不同点在于，<font color=red>异步情况下(Proactor)，当回调注册的处理函数时，表示 IO 操作已经完成；同步情况下(Reactor)，回调注册的处理函数时，表示 IO 设备可以进行某个操作(can read or can write)，注册的处理函数这个时候开始提交操作。 </font></p>
<p><strong>本文参考链接</strong></p>
<p>本文reactor/proactor盗图自<a href="https://tech.youzan.com/yi-bu-wang-luo-mo-xing/" target="_blank" rel="noopener">xieshuang-异步网络模型</a></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>epoll</tag>
        <tag>iocp</tag>
        <tag>socket</tag>
        <tag>c/c++</tag>
        <tag>io</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式计算</title>
    <url>/2019/12/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="题：计算数学表达式-color-green-1-2-times-3-5-2"><a href="#题：计算数学表达式-color-green-1-2-times-3-5-2" class="headerlink" title="题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$"></a>题：计算数学表达式 $\color{green}1+2\times(3-(5+2))=?$</h2><a id="more"></a>
<h2 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h2><h3 id="我们先了解两个概念"><a href="#我们先了解两个概念" class="headerlink" title="我们先了解两个概念"></a>我们先了解两个概念</h3><p>   任意一个数学表达式都可以用二叉树来表示，根节点表示运算符，叶子节点表示数值。</p>
<p><img src="image.png" alt=""></p>
<p>根据二叉树遍历方式，那么就有<code>前缀表达式</code>，<code>中缀表达式</code>与<code>后缀表达式</code>三种，人们常习惯用中缀表达式来表示，是因为其较好的可阅读性比较符合人类的思维习惯。但后缀表达式更有利于我们使用计算机来运算。</p>
<ul>
<li>中缀表达式：<br>   $a+b$</li>
<li>后缀表达式：<br>   $ab+$<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3>遍历将中缀表达式，<span style=color:red><strong>准备一个队列和一个临时空栈–&gt;遍历表达式–&gt;数值入队列–&gt;运算符入栈–&gt;匹配右边括号符`)`的时候需要将栈依次出栈到队列中直至出现左边括号符`(`-&gt;最后将栈2的所有符号都出栈到队列</strong></span>，最后就会得到一个队列即为后缀表达式，操作流程如下图，注意<code>括号是不入队列表达式的也就是说待计算的后缀表达式中是没有括号的</code>。<br><img src="image-1.png" alt=""><br><img src="image-2.png" alt=""><br><img src="image-3.png" alt=""><br><img src="image-4.png" alt=""><h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3>后缀表达式计算就比较简单了，如下图：<br><span style=color:red><strong>准备一个空栈–&gt;表达式依次入栈–&gt;数值直接入栈–&gt;遇到运算符就出栈两个数运算-&gt;将计算出新的数值入栈</strong></span>，最后就会得到一个数值即为运算结果。<br><img src="image-5.png" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu及QT注意事项-笔记</title>
    <url>/2019/11/25/Ubuntu%E5%8F%8AQT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li>E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系</li>
</ol>
<p>Ubuntu关闭软件更新，会导致网络安装软件失败，要想安装新软件，需打开网络更新。</p>
<a id="more"></a>
<ol start="2">
<li>安装ftp服务器vsftpd，配置完后，系统重启服务器用不了</li>
</ol>
<p>禁用ipv6即可</p>
<ol start="3">
<li>系统断电记录关机</li>
</ol>
<p>这个问题其实没有根本解决办法，拿系统关机日志很麻烦，所以只能另辟蹊径了，加定时器每秒写时间到文件，下次软件启动时先读取文件是否是正常关机，如果不是，则补充断电关机日志，时间可以保持在文件也可以直接取文件修改时间，建议前者。</p>
<ol start="4">
<li>qt如何失去焦点关闭窗口</li>
</ol>
<p>在主窗口中重写event事件，关机代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event-&gt;type() == QEvent::ActivationChange)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(QApplication::activeWindow() != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> QWidget::event(event);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>qt调用shell,比如启用Ubuntu的虚拟键盘</li>
</ol>
<p>使用QProcess类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QProcess::execute(<span class="string">"onboard"</span>);<span class="comment">//静态调用</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"onboard"</span>);<span class="comment">//C方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上两种都是在当前进程调用，会导致阻塞。若想多任务</span></span><br><span class="line"></span><br><span class="line">QProcess* proc = <span class="keyword">new</span> QProcess;</span><br><span class="line"></span><br><span class="line">proc-&gt;start(<span class="string">"onboard"</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>Model/View结构中表格可编辑问题</li>
</ol>
<p>view能直接setEditTriggers来设置可编辑模式及进入编辑状态的触发条件，单击，双击等。</p>
<p>需要注意的是Model是也可以控制的，在重写的<code>Qt::ItemFlags flags(const QModelIndex &amp;index) const;</code>函数中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> QAbstractItemModel::flags(index) | Qt::ItemIsEditable;<span class="comment">//即可设置item为可编辑项</span></span><br></pre></td></tr></table></figure>
<p>且model设置不可编辑的话，view的editTrigger是不会触发的。</p>
<ol start="7">
<li><p>Shell替换文件内容</p>
<p> 1、将当前目录下包含jack串的文件中，jack字符串替换为tom</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> `grep <span class="string">"jack"</span> -rl ./`</span><br></pre></td></tr></table></figure>
<p> 2、将某个文件中的jack字符串替换为tom</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">"s/jack/tom/g"</span> test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>访问不了串口COM问题</p>
</li>
</ol>
<p>当前用户不能访问串口，其实是Linux权限问题，将当前用户添加到dialout用户组即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpasswd --add yourname dialout</span><br></pre></td></tr></table></figure>
<p>添加完毕后可以用groups yourname查看是否添加成功</p>
<ol start="9">
<li><p>关闭系统错误报告</p>
<p> 临时关闭：<code>sudo service apport stop</code></p>
<p> 永久关闭：将<code>/etc/default/apport</code>文件中的enable=1改成0即可。</p>
<p> 移除该功能：<code>sudo apt-get purge apport</code> （感觉没必要，常用第二种）</p>
</li>
<li><p>关闭/启用系统图形显示服务lightdm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span>/<span class="built_in">enable</span> lightdm.service</span><br></pre></td></tr></table></figure>
<p>lightdm是一个全新的轻量级的显示管理器，在Ubuntu16.04上面已经使用。</p>
</li>
</ol>
<p>从图形界面进入到命令行界面 <code>systemctl disable lightdm.service</code></p>
<p>从命令行进入到图形界面 <code>systemctl enable lightdm.service</code> 然后 <code>systemctl start lightdm.service</code></p>
<ol start="11">
<li>Qt数据模型Model与组件委托（delegate）数据同步问题</li>
</ol>
<p>在model中又setData，data两个接口需要重写的。参数role==Qt::EditorRole时，即是同步两种数据交互的时期，比如：comboBox与model：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">CMyModel::data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> QVariant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Implement me!</span></span><br><span class="line">    QString strTemp;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::DisplayRole)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步显示数据到combo的currenIndex</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nIndex = m_data[index.row()].DeviceAddr - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> nIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QVariant();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMyModel::setData</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">const</span> QVariant &amp;value, <span class="keyword">int</span> role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(role == Qt::EditRole)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index.column() == <span class="number">1</span>)<span class="comment">//同步combo的currenIndex到显示数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[index.row()].DeviceAddr = value.toInt() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>qt工具栏按钮无法隐藏</li>
</ol>
<p><code>QAction *QToolBar::addWidget(QWidget *widget)</code>，widget使用setVisible无效，若需隐藏，You should use QAction::setVisible() to change the visibility of the widget.</p>
<ol start="13">
<li>QListView移植到触屏下,手势上下翻滚实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QListView *p;</span><br><span class="line"></span><br><span class="line">QScroller-&gt;grabGesture(p, QScroller::TouchGesture);</span><br></pre></td></tr></table></figure></li>
<li>QListView设置行高</li>
</ol>
<p>某度搜了半天,qss啥都不好使,唯有这句有用,view,widget通杀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item-&gt;setSizeHint(QSize(item-&gt;sizeHint().<span class="built_in">width</span>(), <span class="number">32</span>));</span><br></pre></td></tr></table></figure>
<ol start="15">
<li>qt怎样做才能既可以执行那些耗时的操作，又不会阻塞事件循环呢？</li>
</ol>
<p>一般会有三种解决方案：第一，我们将任务移到另外的线程；第二，我们手动强制运行事件循环。想要强制运行事件循环，我们需要在耗时的任务中一遍遍地调用<code>QCoreApplication::processEvents()</code>函数(该函数是告诉系统不用等本事件返回了,系统可以处理其他的事件了,所以长时间事件处理时,时而调用该函数,可以清理消息队列,来达到系统不因某个事件而阻塞卡死的目的)。<code>QCoreApplication::processEvents()</code>函数会发出事件队列中的所有事件，并且立即返回到调用者。仔细想一下，我们在这里所做的，就是模拟了一个事件循环。另外一种解决方案：使用<code>QEventLoop</code>类重新进入新的事件循环。通过调用<code>QEventLoop::exec()</code>函数，我们重新进入新的事件循环，给<code>QEventLoop::quit()</code>槽函数发送信号则退出这个事件循环。通过“其它的入口”进入事件循环要特别小心：因为它会导致递归调用！现在我们可以看看为什么会导致递归调用了。回过头来看看按钮的例子。当我们在<code>Worker::doWork()</code>槽函数中调用了<code>QCoreApplication::processEvents()</code>函数时，用户再次点击按钮，槽函数<code>Worker::doWork()</code>又一次被调用,<code>doWork-&gt;processEvents-&gt;doWork-&gt;....</code></p>
<p>当然，这种情况也有解决的办法：我们可以在调用<code>QCoreApplication::processEvents()</code>函数时传入<code>QEventLoop::ExcludeUserInputEvents</code>参数，意思是不要再次派发用户输入事件（这些事件仍旧会保留在事件队列中）。参考链接</p>
<ol start="16">
<li>设置窗口border宽度及颜色<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有solid，显示不出来，QDialog为作用域，不加会影响所有子窗口</span></span><br><span class="line">setStyleSheet(<span class="string">"QDialog&#123;border: 1px solid rgb(185,185,185);&#125;"</span>);</span><br></pre></td></tr></table></figure></li>
<li>QMessageBox定制图标及文字样式</li>
</ol>
<p>常用的静态函数如果不满足要求，可以使用QMessageBox dlgMsg；dlgMsg.exec();来定制。</p>
<ol start="18">
<li>修改用户名密码过短提示时</li>
</ol>
<p>使用：<code>sudo passwd 用户名</code></p>
<p>可以解决密码过简单设置不成功的问题。</p>
<ol start="19">
<li>&amp; 放在命令后面表示设置此进程为后台进程</li>
</ol>
<p>默认情况下，进程是前台进程，这时此进程（命令执行相当于本质是开启一个进程）就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。</p>
<ol start="20">
<li>自动更新检测不出，命令行检测升级系统：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo   update-manager   -c</span><br></pre></td></tr></table></figure></li>
<li>sudo不能执行gui程序，报不能使用XDG_RUNTIME_DIR错误<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dmg3</span><br></pre></td></tr></table></figure>
重启可解决</li>
</ol>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>run文件打包</title>
    <url>/2019/11/09/run%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>run程序安装包实质上是一个安装脚本+程序，为了简单起见，要安装的程序就是helloworld程序，安装它的过程就是把它拷贝到<code>/bin</code>目录下.</p>
<a id="more"></a>
<p>install.sh代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">cp helloworld /bin</span><br></pre></td></tr></table></figure>
<p><code>tar cvf helloworld.tar.gz helloworld</code><br>现在修改一个安装脚本<code>install.sh</code>改为： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">lines=7 <span class="comment">#这个值是指这个脚本的行数加1，这个脚本共有6行 </span></span><br><span class="line">tail +<span class="variable">$lines</span> <span class="variable">$0</span> &gt;/tmp/helloworld.tar.gz <span class="comment"># $0表示脚本本身，这个命令用来把从$lines开始的内容写入一个/tmp目录的helloworld.tar.gz文件里。 </span></span><br><span class="line">tar xvf /tmp/hellowrold.tar.gz </span><br><span class="line">cp helloworld /bin  <span class="comment">#该行代码不变</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>然后使用cat命令连接安装脚本<code>install.sh</code>和<code>helloworld.tar.gz</code>。<br><code>cat install.sh helloworld.tar.gz &gt; myinstall.run</code><br>这样就得到了<code>myinstall.run</code>文件，它的结构如下：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string">------------------</span>|<span class="string"> 第1行 </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> install.sh </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第6行 </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> 第7行 </span></span><br><span class="line">|<span class="string">helloworld.tar.gz</span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">------------------</span>|<span class="string"> 结尾</span></span><br></pre></td></tr></table></figure>
<p>运行<code>myinstall.run</code>时，运行到第6行的<code>exit 0</code>脚本就退出了，所以不会去运行第7行以下的二进制数据(即 <code>helloworld.tar.gz</code>文件)，而我们用了<code>tail</code>巧妙地把第7行以下的数据重新生成了一个<code>helloworld.tar.gz</code>文件。再执行安装。<br><code>run</code>安装包制作较小的程序包是很好的选择，但是它也有缺点，做逻辑比较复杂的安装包，写的安装脚本将会很麻烦。因此此时还是用其他的安装包更好。 </p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>打包</tag>
        <tag>run</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux gdb 调试core dump</title>
    <url>/2019/10/18/Linux%20gdb%20%E8%B0%83%E8%AF%95core%20dump/</url>
    <content><![CDATA[<p>gdb使用两个推荐链接：<a href="https://www.cnblogs.com/mister-lv/p/6022841.html" target="_blank" rel="noopener">GDB中文手册</a> <a href="https://www.jianshu.com/p/b7896e9afeb7" target="_blank" rel="noopener">GDB常用命令</a></p>
<a id="more"></a>
<ol start="0">
<li>关于core文件的设置</li>
</ol>
<p>两种方式设置core文件名，默认系统是生成名为core的文件，但是当我们为了方便调试，需要生成带pid，time等信息的core文件时候，就需要自己设置一下了。以下命令一般都要root权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/kernel/core_uses_pid</span><br></pre></td></tr></table></figure>
<p>如果以上命令执行无权限，可以使用下列命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.core_uses_pid=1</span><br></pre></td></tr></table></figure>
<p>都是一个意思，设置core文件名带进程id。另外我们也可以修改core文件统一生成到一个自定义默认路径，比如：“<code>/corefile</code>”更详细可以参考下面说明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行如下命令的一条即可</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/corefile/core-%e-%p-%t"</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment">#标识生成的core文件格式是 core-%e-%p-%t,保存路径为/corefile</span></span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%p - insert pid into filename 添加pid(进程id)<br>%u - insert current uid into filename 添加当前uid(用户id)<br>%g - insert current gid into filename 添加当前gid(用户组id)<br>%s - insert signal that caused the coredump into the filename 添加导致产生core的信号<br>%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间<br>%h - insert hostname where the coredump happened into filename 添加主机名<br>%e - insert coredumping executable name into filename 添加导致产生core的命令名</p>
</blockquote>
<ol>
<li><p>在终端使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c</span><br></pre></td></tr></table></figure>
<p>查看你当前终端是否打开了core dump。系统一半默认输出0，此时我们需要设置一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>
<p>将终端设置成无限dump文件大小。也可以设置成一个值比如1000，dump文件超过1000字节就不会继续生成。所以通常使用无限制大小。</p>
</li>
<li><p>编写测试demo,text.cpp文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	*p = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>g++ -o text text.cpp</code>，生成text可执行文件，然后运行，就会得到<code>core.*</code>文件了。</p>
</li>
<li><p>gdb调试</p>
</li>
</ol>
<p>当我们发布程序后，拿到core文件了，怎么调试？答案就是gdb。</p>
<p>使用源代码，如果是用makefile的话也一样，编译的时候加 -g 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">g++ -g -o textd text.cpp</span><br><span class="line"><span class="comment">#调试</span></span><br><span class="line">gdb textd core.*</span><br></pre></td></tr></table></figure>
<p>此时我们就会发现输出信息很直观了，如下图。<br><img src="20191018112559275.png" alt=""></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gdb</tag>
        <tag>core dump</tag>
      </tags>
  </entry>
  <entry>
    <title>用Qt5编写压缩解压缩文件(夹)</title>
    <url>/2019/08/02/%E7%94%A8Qt5%E7%BC%96%E5%86%99%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6(%E5%A4%B9)/</url>
    <content><![CDATA[<p>全网居然没找到一个能直接压缩整个文件夹的c/c++库,就算找到了zlib，karchive，archive等开源库，基本也是在Linux下支持的较好，在win下只有zlib还算是编译过了。而且不能全文件夹压缩的，都是buffer或者单文件压缩，这就好奇了，标准zip怎么搞？原来zip是有一个特定archive的，<a href="http://www.fileformat.info/format/zip/corion.htm" target="_blank" rel="noopener">链接在此</a>。</p>
<a id="more"></a>
<p>由此思路，如果自己要压缩文件夹，那就自己遍历，然后自己定义压缩文件的格式就好了，当然不是标准化的压缩格式而已了。但是够自己使用就行。这么理解，实现文件夹的压缩就显得不那么重要了，重要的是压缩算法，而提供压缩算法的库就多了去了，也容易找到。下面就用qt5简单实现一个文件的压缩与解压缩。注意，没有全文件一次读取再压缩，是考虑到文件太大，比如4g，会直接冲爆你的内存。下面测试代码已使用MD5验证通过。show code：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUFFER 10240</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;output)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            QByteArray <span class="built_in">read</span> = file.<span class="built_in">read</span>(READ_BUFFER);</span><br><span class="line">            QByteArray comp = qCompress(<span class="built_in">read</span>);</span><br><span class="line">            <span class="keyword">int</span> nsize = comp.<span class="built_in">size</span>();</span><br><span class="line">            ds&lt;&lt;nsize&lt;&lt;comp;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"Input:"</span>&lt;&lt;nsize;</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uncompress</span><span class="params">(QString ifile, QString ofile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(ifile)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">output</span><span class="params">(ofile)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly) &amp;&amp;</span><br><span class="line">            output.<span class="built_in">open</span>(QFile::WriteOnly|QFile::Truncate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        QByteArray <span class="built_in">read</span>;</span><br><span class="line">        <span class="keyword">while</span>(!file.atEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">            ds&gt;&gt;<span class="built_in">size</span>&gt;&gt;<span class="built_in">read</span>;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"out:"</span>&lt;&lt;<span class="built_in">size</span>;</span><br><span class="line">            QByteArray comp = qUncompress(<span class="built_in">read</span>);</span><br><span class="line">            output.<span class="built_in">write</span>(comp);</span><br><span class="line">        &#125;</span><br><span class="line">        output.<span class="built_in">close</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"compress...."</span>;</span><br><span class="line">    compress(<span class="string">"data.db"</span>, <span class="string">"data.zip"</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"uncompress...."</span>;</span><br><span class="line">    uncompress(<span class="string">"data.zip"</span>, <span class="string">"dt.db"</span>);</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>压缩</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步</title>
    <url>/2019/07/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>关于线程同步主要有四种方式：临界区/互斥量/信号量/事件</p>
<a id="more"></a>
<h2 id="临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"><a href="#临界区（Critical-Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）" class="headerlink" title="临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）"></a>临界区（Critical Section）（同一个进程内，实现互斥，但，无法实现同步，因为其具有“线程所有权”）</h2><p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p>
<p>可以将临界区比作旅馆的房卡，调用<code>EnterCriticalSection()</code>即申请房卡，得到房卡后自己当然是可以多次进出房间的，在你调用<code>LeaveCriticalSection()</code>交出房卡之前，别人自然是无法进入该房间,在经典线程同步问题上，主线程正是由于拥有“线程所有权”即房卡，所以它可以重复进入关键代码区域从而导致子线程在接收参数之前主线程就已经修改了这个参数。所以关键段可以用于线程间的互斥，但不可以用于同步。</p>
<h2 id="互斥量（Mutex）（可以跨进程，实现互斥）"><a href="#互斥量（Mutex）（可以跨进程，实现互斥）" class="headerlink" title="互斥量（Mutex）（可以跨进程，实现互斥）"></a>互斥量（Mutex）（可以跨进程，实现互斥）</h2><p>互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。<br>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</p>
<h2 id="信号量（Semaphores）（主要是实现同步，可以跨进程）"><a href="#信号量（Semaphores）（主要是实现同步，可以跨进程）" class="headerlink" title="信号量（Semaphores）（主要是实现同步，可以跨进程）"></a>信号量（Semaphores）（主要是实现同步，可以跨进程）</h2><p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出</p>
<h2 id="事件（Event）（实现同步，可以跨进程）"><a href="#事件（Event）（实现同步，可以跨进程）" class="headerlink" title="事件（Event）（实现同步，可以跨进程）"></a>事件（Event）（实现同步，可以跨进程）</h2><p>事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。</p>
<p>互斥量也是一个特殊的信号量（无计数能力或者说计数就是1的信号量）。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>临界区</tag>
        <tag>互斥量</tag>
        <tag>信号量</tag>
        <tag>事件</tag>
        <tag>线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>使用windeployqt打包</title>
    <url>/2019/06/11/%E4%BD%BF%E7%94%A8windeployqt%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>使用QT5自带的windeployqt打包程序</p>
<a id="more"></a>
<ol>
<li>从开始菜单找到qt程序目录如下图，我安装了vs版和mingw版本，根据需要选择即可。<br><img src="20190611132725707.png" alt=""></li>
</ol>
<ol start="2">
<li>执行两条关键命令</li>
</ol>
<p>cd 到exe所在的目录</p>
<p>执行<code>windeployqt *.exe</code></p>
<p>会在当前目录生成exe依赖的所有文件（含库，语言包，插件等信息，部分非必须文件也会被拷贝过来）。<br>此时程序即可打包了。</p>
<p><img src="20190611133144365.png" alt=""></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>qt</tag>
        <tag>windeployqt</tag>
      </tags>
  </entry>
  <entry>
    <title>deb文件打包</title>
    <url>/2019/04/10/deb%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/drfxiaoliuzi/p/4873670.html" target="_blank" rel="noopener">参考链接</a></p>
<p><strong>deb包结构的目录以及文件：</strong></p>
<a id="more"></a>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">mydeb</span><br><span class="line"></span><br><span class="line">|<span class="params">----DEBIAN</span></span><br><span class="line"></span><br><span class="line">       |<span class="params">-------control</span></span><br><span class="line">       |<span class="params">-------postinst</span></span><br><span class="line"></span><br><span class="line">       |<span class="params">-------postrm</span></span><br><span class="line"></span><br><span class="line">|<span class="params">----App</span>'s path1</span><br><span class="line"></span><br><span class="line">       |<span class="params">----App</span>'s file1</span><br><span class="line"></span><br><span class="line">|<span class="params">----App</span>'s path2</span><br><span class="line"></span><br><span class="line">       |<span class="params">----App</span>'s file2</span><br><span class="line"></span><br><span class="line"><span class="string">.............</span></span><br></pre></td></tr></table></figure>
<p>在任意目录下创建如上所示的目录以及文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir   -p /root/mydeb                <span class="comment"># 在该目录下存放生成deb包的文件以及目录</span></span><br><span class="line">mkdir -p /root/mydeb/DEBIAN           <span class="comment">#目录名必须大写</span></span><br><span class="line">mkdir -p /root/mydeb/App<span class="string">'s path       # 将文件安装到目标目录下,路径从/根目录开始</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/control    # 必须要有该文件</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/postinst  # 软件安装完后，执行该Shell脚本</span></span><br><span class="line"><span class="string">touch /root/mydeb/DEBIAN/postrm    # 软件卸载后，执行该Shell脚本</span></span><br></pre></td></tr></table></figure>

<p>control文件内容：<br>Package: my-deb   （软件名称，中间不能有空格）<br>Version: 1                  (软件版本)<br>Section: utils            （软件类别）<br>Priority: optional        （软件对于系统的重要程度）<br>Architecture: amd64   （软件所支持的平台架构）<br>Maintainer: xxxxxx <a href="mailto:&#120;&#120;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#64;&#120;&#x78;&#x78;&#120;&#x2e;&#x78;&#x78;">&#120;&#120;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#64;&#120;&#x78;&#x78;&#120;&#x2e;&#x78;&#x78;</a> （打包人和联系方式）<br>Description: my first deb （对软件所的描述）</p>
<p>postinst文件内容（ 软件安装完后，执行该Shell脚本，一般用来配置软件执行环境，必须以“<code>#!/bin/sh</code>”为首行，然后给该脚本赋予可执行权限：<code>chmod +x postinst</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my deb"</span> &gt; /root/mydeb.log</span><br></pre></td></tr></table></figure>
<p>postrm文件内容（ 软件卸载后，执行该Shell脚本，一般作为清理收尾工作，必须以“#!/bin/sh”为首行，然后给该脚本赋予可执行权限：<code>chmod +x postrm</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">rm -rf /root/mydeb.log</span><br></pre></td></tr></table></figure>
<p>给mydeb目录打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -b   mydeb   mydeb-1.deb      </span><br><span class="line"><span class="comment"># 第一个参数为将要打包的目录名，</span></span><br><span class="line"><span class="comment"># 第二个参数为生成包的名称。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>deb</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04随机启动应用程序</title>
    <url>/2019/03/14/Ubuntu16.04%E9%9A%8F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>由于项目需要，开发的应用程序需要系统开机启动，本文例子都是基于Ubuntu16.</p>
<a id="more"></a>
<p>网上方法基本是两种：</p>
<p>1.在<code>/etc/rc.local</code>中添加命令执行</p>
<p>在<code>exit 0</code>前面添加命令行。</p>
<p>2.在<code>/etc/init.d/</code> 目录下添加执行文件或脚本或软链接</p>
<p>引用例子（非笔者代码），随便搜索使用步骤如下：</p>
<p>1、新建个脚本文件<code>new_service.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># command content</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>2、设置权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 new_service.sh</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">sudo chmod +x new_service.sh</span><br></pre></td></tr></table></figure>
<p>3、把脚本放置到启动目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv new_service.sh /etc/init.d/</span><br></pre></td></tr></table></figure>
<p>4、将脚本添加到启动脚本</p>
<p>执行如下指令，在这里90表明一个优先级，越高表示执行的越晚</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">sudo update-rc.d new_service.sh defaults 90</span><br></pre></td></tr></table></figure>
<p>5、移除Ubuntu开机脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-rc.d -f new_service.sh remove</span><br></pre></td></tr></table></figure>
<p>6、通过sysv-rc-conf来管理上面启动服务的启动级别等，还是开机不启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sysv-rc-conf</span><br></pre></td></tr></table></figure>
<p>本质上方式1是方式2的一个子集（特例）。由于要进入<code>/etc</code>该目录操作，所以需要<code>root</code>权限，<code>sudo</code>也是可以的。笔者照此方式流程做了一个QT5应用程序启动脚本，发现根本不能执行啊。</p>
<p>然而，回忆整个过程出错的地方也就是在执行<code>update-rc.d</code> 的时候报了一个 <code>miss tag</code>警告，不是错误。该警告只是一个bash格式警告而已啊（该有的注释项没有），所以理论上是不产生影响的。</p>
<p>后来尝试换台机子一试，新建脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！ /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my test_service.sh beging......"</span> &gt; /home/my/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>意思就是在我的工作目录建立一个test空文件夹，让开机启动脚本往里面写这么一段文字。照如上操作一遍，意外发现，执行无误。如此说来Ubuntu开机启动机制没问题啊，那就是区别在启动程序了。继续在<code>test_service.sh</code>中添加调用应用程序的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行我的Qt应用程序启动脚本</span></span><br><span class="line"></span><br><span class="line">/home/my/bin/myApp.sh</span><br></pre></td></tr></table></figure>
<p>重启果然没启动起来，那问题就来了，<span style=color:red>以上方法不能启动图形应用</span>，所以其定位就是启动服务程序。那就另找启动图形应用的方法，请确信这种方法是有的。输入法不就是典型吗？</p>
<p>3.开机启动图形应用方法</p>
<p>在<code>/etc/xdg/autostart</code>目录添加一个配置文件，名称自定义，后缀必须是<code>.desktop</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version&#x3D;1.0</span><br><span class="line">Name&#x3D;qtApp.sh</span><br><span class="line">Exec&#x3D;&#x2F;home&#x2F;my&#x2F;qtApp.sh</span><br><span class="line">StartupNotify&#x3D;false</span><br><span class="line">NoDisplay&#x3D;true</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Categories&#x3D;System;Utility;Archiving;</span><br></pre></td></tr></table></figure>
<p>保存，重启，意外惊喜就出现了。另外如果我想开机直接启动程序跳过系统ui，怎么设置呢？</p>
<p>4.开机直接启动应用，跳过Ubuntu系统登录及相关UI</p>
<p>首先在Ubuntu系统中设置成锁定用户，并自动登录。</p>
<p>然后在<code>/etc/profile</code>文件中添加执行qt程序的命令即可（但是该方法，会默认使分辨率变成800x600<span style=color:red>补充:后来发现可以修改,直接在软件中设置窗口大小即可,也可通过获取屏幕分辨率控制全屏显示,注意fullscreen函数不起效.</span>）。如果想退出软件自动关机可以在最后加上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure>
<p>5.关闭Ubuntu的载入画面<br>ubuntu启动时，会有一个ubuntu字样出现在屏幕，文字下方有闪烁的点，这时按ESC可以在动画和文字界面之间切换。这一步骤不属于lightdm，而是一个叫 plymouth 的进程在起作用。实际上，plymouth的意义就在于，在开机到图形桌面 (lightdm)起来这段时间里展示出一个动画，从而提高用户体验。</p>
<p>屏蔽的方法：</p>
<p>一、编辑 /etc/default/grub 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet splash"</span> </span><br><span class="line"></span><br><span class="line">去掉”splash“，改后：</span><br><span class="line"></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet"</span></span><br></pre></td></tr></table></figure>
<p>二、执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudu updat-grub</span><br></pre></td></tr></table></figure>
<p>重启，即可看到，不再有载入画面出现了。</p>
<p>6.另参考网上方法</p>
<p>方法一:</p>
<p>能成功运行,缺点:<br>    1.没有了其他的tty控制,除了图形tty2,其他tty全部成了终端输出,失去了tty的意义.</p>
<pre><code>2.QT插件键盘输入用不了.

3.没了tty,也就不能掉其他的终端,执行不了其他的基本命令.</code></pre><p>方法二:文中4所说的方法缺点就一个,系统不操作十分钟后关闭屏幕,无论什么</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xset s</span><br><span class="line"></span><br><span class="line">xset -dpms</span><br></pre></td></tr></table></figure>
<p>都是无效的,X都没启动,怎么能设置有效呢?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setterm --blank 0</span><br></pre></td></tr></table></figure>
<p>无效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">"\\033[32m\\033[8]"</span> &gt; /dev/tty1</span><br></pre></td></tr></table></figure>
<p>也无效</p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5 Linux远程调试</title>
    <url>/2019/02/27/Qt5%20Linux%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>当我们程序发布到新机时,难免会遇到意料之外的情况,在目标机安装编译环境虽不失为一种方式,但安装环境耗时耗力,远程调试一定会让你觉得神清气爽.</p>
<a id="more"></a>
<ol>
<li>目标机需要有<code>gdb gdbserver</code>.</li>
</ol>
<p>没有就安装,Ubuntu是自带有,</p>
<blockquote>
<p><code>gdbserver --version</code>可以查看版本信息</p>
</blockquote>
<ol start="2">
<li><p>目标机执行debug版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdbserver 127.0.0.1:1234 myApp</span><br></pre></td></tr></table></figure>
<p>ip:port说明:ip地址本机可以使用环路地址,或者本机ip,端口是自定义的,该命令是建立一个可供连接的服务器.</p>
</li>
<li><p>开发环境配置</p>
</li>
</ol>
<p>打开qtcreate ,选择debug菜单中的start debug选远程调试</p>
<blockquote>
<p>Override server channel:<strong>目标机ip:端口1234</strong></p>
</blockquote>
<blockquote>
<p>Local executable:<strong>myApp的输出路径</strong></p>
</blockquote>
<p><strong>点击ok,此时你会发现目标机的终端开始出现输出信息,软件正常启动了,在开发环境打断点试试,完美执行中断.</strong></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>远程调试</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机Ubuntu局域网联网问题</title>
    <url>/2019/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>对于虚拟机的网络有多种模式：</p>
<a id="more"></a>
<ol>
<li><p><strong>桥接模式</strong>，该模式直接使虚拟机连接物理网卡，与主机保持同一局域网。但与主机ip地址不同。该模式下，<span style=color:red>局域网内的其它主机可以与该虚拟机相互ping通</span>。可以使用外网。</p>
</li>
<li><p><strong>nat模式</strong>，默认模式，该模式是与主机共用一个ip，但虚拟了一个新的子网，故<span style=color:red>局域网内的其它主机不能ping该虚拟机，但该虚拟机可以ping通其它的主机</span>，可以使用外网。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>vm</tag>
        <tag>联网</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈qt5程序发布时依赖库问题追踪</title>
    <url>/2018/12/24/%E5%86%8D%E8%B0%88qt5%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83%E6%97%B6%E4%BE%9D%E8%B5%96%E5%BA%93%E9%97%AE%E9%A2%98%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>程序打包后，发布到新的Ubuntu18，又出现了依赖库的问题。</p>
<a id="more"></a>
<p>使用<code>ldd</code>显示的所有依赖库都已经存在了，一切正常，然而一运行就发现<code>qxcb no found</code>，这。。。。难道plugins路径不对？之前在其他环境都布了完全能运行啊，怎么可能plugins会不起效呢？设置一下环境变量/拷贝qxcb库到应用程序路径，还是不起效，所以路径不对也基本可以排除了。</p>
<p>这时，使用qt自带的一个调试插件的宏就起到了至关重要的角色，它能报软件运行时，插件加载的错误。</p>
<p>设置Ubuntu环境变量,添加这行代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">export</span> QT_DEBUG_PLUGINS=1</span><br></pre></td></tr></table></figure>
<p>在<code>~/.profile</code>或者<code>/etc/profile</code>都行。</p>
<p>别忘了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> .profile</span><br></pre></td></tr></table></figure>
<p>然后直接运行程序就会打印相关的加载错误信息了，发现qxcb库依赖的<code>libQt5Dbus</code> <code>libQt5Xcb</code> 库加载失败，于是又去之前的编译环境拷贝一下，替换，果然可以了。那问题就很明显了，不是程序找不到qxcb，而是qxcb的依赖库加载失败！！！</p>
<p>吐槽一下qt这个错误提示是真的。。。。恶心。。。定位也太不准了。又想起了windows开发的舒服了。唉!</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>qxcb</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS7升级python3.7</title>
    <url>/2018/12/08/centOS7%E5%8D%87%E7%BA%A7python3.7/</url>
    <content><![CDATA[<p>1.python2不要卸载，因为yum依赖python2，谁叫Google不向下兼容</p>
<a id="more"></a>
<p>2.保留2，安装python3.7依赖的第三方库，</p>
<p>  wget 下载地址</p>
<p>  <del>./configure prefix=/usr/local/python3</del></p>
<p>  （请使用此命令代替上述命令./configure –with-ssl如果不带ssl安装会导致后面pip链接网络失败，也就安装不了python的其他的包了。而使用ssl之前一定要先安装openssl-devel，不设置prefix，默认安装路径是/usr/local/bin）</p>
<p>  make</p>
<p>  必须在make install之前用yum安装好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install zlib-devel ncurses-devel libffi-devel openssl-devel</span><br></pre></td></tr></table></figure>

<p>3.安装成功是没有任何报错的而且会安装pip如下图</p>
<p>4.<code>sudo make install</code></p>
<p><img src="20181208152331367.png" alt="img"></p>
<p>5.安装成功后，在<code>/usr/local/python3</code>目录下会有相应的安装文件</p>
<p>  配置环境变量即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/python3 /usr/bin/python</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/pip3 /usr/bin/pip（方便pip升级需要sudo，还是建议添加改行代码）</span><br></pre></td></tr></table></figure>

<p>  记得修改yum的python依赖版本为python2.看下图：</p>
<p><img src="20181208153114446.png" alt=""></p>
<p>yum如果不能用，报错如下</p>
<blockquote>
<p>  File “/usr/bin/yum”, line 30<br>    except KeyboardInterrupt, e:</p>
<p>SyntaxError: invalid syntax<br>  File “/usr/libexec/urlgrabber-ext-down”, line 28<br>    except OSError, e:</p>
</blockquote>
<p>解决办法：<code>vim /usr/bin/yum</code> 将第一行的 <code>#!/usr/bin/python</code> ————-&gt;改成 <code>#!/usr/bin/python2</code>即可，其他文件同理！</p>
<p>6.python3安装成功了，但是当时有pip安装python库的时候又有问题</p>
<p>要安装scrapy，Django时报错，Twisted&gt;=13.原因是没安装Twisted，去官网下载版本链接如下：</p>
<p><a href="https://twistedmatrix.com/Releases/Twisted/" target="_blank" rel="noopener">https://twistedmatrix.com/Releases/Twisted/</a></p>
<p>至此，centos7终于能顺利完成python3的配置操作了。</p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centOS7</tag>
      </tags>
  </entry>
  <entry>
    <title>QT将事件执行moveToThread槽函数不响应问题</title>
    <url>/2018/11/27/QT%E5%B0%86%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8CmoveToThread%E6%A7%BD%E5%87%BD%E6%95%B0%E4%B8%8D%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近遇到这么个问题，想将写日志信息放到一个单独的线程中去执行，然而添加<code>movetothread</code>后程序就不进入槽函数了，</p>
<a id="more"></a>代码如下图：
<p><img src="2018112717484772.png" alt=""><br>第一想到的就是检查语法规范，然而，注释图中第三行代码发现，可以执行，显然，语法是没任何问题的了。这就有点奇怪了，于是单步调试发现如下图<br><img src="20181127175317582.png" alt=""><br>这个提示就很明显了，原来是参数未注册元对象的问题。那好注册一下试试呗，成功了，打印下线程信息安心呗，果然意料之中。<br><img src="20181127175559889.png" alt=""><br><img src="20181127175633539.png" alt=""><br><strong>总结</strong><br>qt的这个信号槽，坑还是有的，要想避免还是得多调试，不怕编译错误就怕运行错误啊。</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>moveToThread</tag>
      </tags>
  </entry>
  <entry>
    <title>linux的ssh免密登录</title>
    <url>/2018/11/21/linux%E7%9A%84ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>ssh免密登录在很多运维环境都需要用到<br>FTP,SCP,SSH远程登录等。。。</p>
<a id="more"></a>
<p>暂且假想客户端为B，服务器为S。我们需要从B远程登录S的时候，总是需要登录S端的用户密码，很麻烦。那么如何利用ssh免密登录？以rsa加密为例，本质是利用rsa加密算法对登录密码做了加密处理，来使得服务器自动接受客户机的认证。1.公钥 2.私钥，本文不做赘述。<br>直接上代码，首先确保B-S联通，且S启动了ssh服务。进入主题，在B机上，打开终端，执行<br><code>ssh-keygen</code><br>此时会提示你输入生成文件名称，直接回车，生成默认id_rsa*文件<br>然后提示输入密码，确认，一直回车即可。<br>此时，~/.ssh/目录下会生成id_rsa及id_rsa.pub两个文件，前者为私钥，后者为公钥。<br>接下来就是将密钥推送到S机<br><code>ssh-copy-id -i ~/.ssh/id_rsa username@remoteIP</code><br><code>username@remoteIP</code>格式如：<code>zhangsan@192.168.1.110</code></p>
<p>成功后，后续在B端执行ssh相关登录S操作无需再认证了。</p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>老毛桃制作LinuxU盘启动盘</title>
    <url>/2018/11/19/%E8%80%81%E6%AF%9B%E6%A1%83%E5%88%B6%E4%BD%9CLinuxU%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98/</url>
    <content><![CDATA[<p>如果usb-hdd+的写入方式，系统制作完后，启动失败，所以需要在“便捷启动”中手动写入引导扇区即可，选择syslinux。<a id="more"></a><br><img src="20181119095951146.png" alt=""><br>如果写引导总是提示u盘被占用，实际并未被占用，改用RAW方式重做即可<br><img src="20181119101633157.png" alt=""></p>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>U盘启动盘</tag>
      </tags>
  </entry>
  <entry>
    <title>linux修改因软件版本升级不能使用的命令</title>
    <url>/2018/11/14/linux%E4%BF%AE%E6%94%B9%E5%9B%A0%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>linux部分版本会内置一些常用软件命令，如python /qt等。</p>
<a id="more"></a>
<p>Ubuntu自带python2，qt4，如果我们安装了python3 ，qt5</p>
<p>发现python命令调的还是python2，而qt命令还是调用的qt4，这时候我们需要找到该命令链接点，从新链接即可</p>
<p>而当前用户的命令通常所在目录是<code>/usr/bin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入用户命令所在目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line"><span class="comment">#查看python命令</span></span><br><span class="line">ls -l python</span><br><span class="line"><span class="comment">#查看qt的翻译器</span></span><br><span class="line">ls -l linguist</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">sudo rm -rf python</span><br><span class="line"><span class="comment">#重新建立软链接</span></span><br><span class="line">sudo ln -s /opt/python3/bin/python3 ./python</span><br><span class="line"> </span><br><span class="line">sudo ln -s /opt/Qt5.9.4/5.9.4/gcc_64/bin/linguist ./linguist</span><br><span class="line">或者</span><br><span class="line">sudo ln -snf /opt/Qt5.9.4/5.9.4/gcc_64/bin/linguist ./linguist</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>软连接</tag>
        <tag>系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Gnome隐藏上边栏，Ubuntu18 hide top bar</title>
    <url>/2018/10/30/Gnome%E9%9A%90%E8%97%8F%E4%B8%8A%E8%BE%B9%E6%A0%8F%EF%BC%8CUbuntu18%20hide%20top%20bar/</url>
    <content><![CDATA[<p>Ubuntu18LTS，UI已经回归gnome了。Unity被弃！</p>
<p>那么本文就将已Ubuntu18为例讲解怎么隐藏顶部状态栏及任务栏。</p>
<a id="more"></a>
<p>任务栏其实没啥讲的Ubuntu18/16都是在系统设置里面就支持自动隐藏了，还有停靠位置（左，右，下）。但是自动隐藏18与16不同的是，18只有软件界面与dock界面有交汇碰撞，dock才隐藏，否则，dock是一直显示的，可以参考本文最后效果图。而16的隐藏是只有光标覆盖才激活显示。</p>
<p>1.css修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/share/gnome-shell/theme/ubuntu.css</span><br></pre></td></tr></table></figure>

<p>在文件末尾添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#panel</span>,<span class="selector-id">#panel</span> *&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人说可以，但是本人的现象是：状态栏透明了，但是如果软件最大化，或者拖动到状态栏边缘，状态栏会变成标题栏的黑色。还是隐藏不了。（后来发现需要重启系统才能看出效果！）</p>
<p>2.使用<code>gnome</code>的<code>hide top bar</code>插件</p>
<p>这是一个浏览器插件，chrome/firefox都是可以用的。</p>
<p>首先，使用firefox打开<a href="https://extensions.gnome.org/extension/545/hide-top-bar/" target="_blank" rel="noopener">gnome插件地址</a>，<br><img src="20181030152556379.png" alt=""><br>根据提示，单击蓝色链接，安装gnome-shell插件。 安装完之后，浏览器菜单栏有一个gnome图标<br><img src="20181030152740399.png" alt=""><br>点击这个图标，就会跳转到gnome插件管理界面 ，插件安装完了，我们可以刷新以上hide-top-bar链接，还有一个错误提示，这是系统本地与插件通信失败，系统还需要安装一个库，chrome-gnome-shell.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure>
<p>安装成功后，再刷新地址即可，若错误消失，即为成功。<br><img src="20181030154031787.png" alt=""><br>这就是成功的了。讲off切成on即可。旁边的设置图标，会有更详细的设置信息。最后上一张Gnome效果图。<br><img src="20181030154046179.png" alt=""></p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>gnome</tag>
        <tag>hide top bar</tag>
        <tag>ubuntu18</tag>
      </tags>
  </entry>
  <entry>
    <title>vm14卡顿及安装linux黑屏问题</title>
    <url>/2018/10/30/vm14%E5%8D%A1%E9%A1%BF%E5%8F%8A%E5%AE%89%E8%A3%85linux%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>因工作需要按照了vm运行Linux，当然按照64位系统了，vm14+Ubuntu18/16LTS都有，安装很简单默认点击下一步就完了，也很顺利。但是发现奇慢无比，我将系统移到C盘固态硬盘会好很多。<a id="more"></a></p>
<p>我就纳闷了，vm又不是第一次用，怎么会如此慢，单击系统任何地方都得等几秒钟才勉强响应，硬件配置是完全够的4核CPU+8G内存+128g固态+500g机械硬盘等。好过以前的电脑配置太多了。所以直接排除”带不动“的原因！</p>
<p>于是b度，呵呵，果然没什么卵用，改vm配置什么的都是耍流氓，都是默认安装的需要改啥？？？</p>
<p>那就自己另找原因，一边打开任务管理器，一边操作linux，cpu/内存占比没毛病，开始还没发现硬盘读写那么频繁，在此一定要表扬一下win10，监控的很完美，比win7更细更直观。虽然硬盘没显示跑满的速度，但是看到vm的io读写都是10m/s左右，最低都是4m/s显然是不正常的，如此频繁的io，肯定是拖累系统的直接原因了。</p>
<p>后来查看虚拟机的配置信息，默认就是1cpu+1g内存，感觉我cpu，内存一直空闲着呢，那我就手动修改一下2cpu+2g内存重启系统，果然soso的了。任务管理器io速度也下来了</p>
<p><strong>总结：加内存（其他都是废话）</strong></p>
<p>现在的64位系统，还用以前的老配置1cpu+1g内存是不够的了，尤其内存太低导致虚拟机为满足系统内存需求一直在做内存映射，才导致硬盘io速度上升。如此带来严重卡顿效果。另1cpu+2g内存笔者也试了，简单操作还是很流畅的。至于vm为啥没将内存2g作为默认配置，这个就不知道了，可能是为了尽量不浪费用户资源的前提下对老32位系统支持吧，只能这样想了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>vm14安装centos，Ubuntu等Linux出现黑屏，但是缩略图中有时能看到系统安装界面。</p>
<p><strong>原因</strong>：安装系统的时候安装tools</p>
<p><strong>解决方式</strong>：以管理员身份运行“命令提示符”， 输入命令：<code>netsh winsock reset</code> </p>
<p>重置Windowssock网络即可，重新安装linux的过程中还会提示安装tools，别点，点就黑屏，又得重来，也正是因为如此，我才判断的是tools引起的网络更改出错，导致安装不了。</p>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vm</tag>
        <tag>黑屏</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令及解析</title>
    <url>/2018/10/26/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>本文是基于<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">原教程地址</a>学习后的一个笔记记录，感谢原作者的无私分享！github遵守开源协议，fork后的仓库代码可以读写，甚至可以pull request给官方仓库来贡献代码。 </p>
<a id="more"></a>
<ol>
<li><code>git config</code>命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line"> </span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></li>
<li>初始化一个Git仓库，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>添加文件，并提交，与svn不一样每次修改都要add，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line"> </span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面一行相当于上面两行</span></span><br><span class="line">git commit -a -m &lt;message&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看文件状态<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li>比较文件不同<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li>
<li>查看提交日志<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li>
<li>版本重置/及跳转<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></li>
<li>查看历史命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li>
<li>用版本库文件替换工作区文件（撤销修改）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li>
<li>删除文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm</span><br></pre></td></tr></table></figure></li>
<li>关联远程库（注意：与github交互需要ssh支持，rsa加密的）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure>
origin是一个默认用户名 </li>
</ol>
<p>另：当远程库路径（如：ip）更改后，可通过下面命令重新设置路径，或者直接更改当前目录./.git/config文件中的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地库不需要用.git，路径必须是绝对路径</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin ssh://zhum@ip:/home/zhum/gitpath</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>push到远程库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li>
</ol>
<p>注意：服务器要设置变量，默认是拒绝接收push的。在服务器执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config receive.denyCurrentBranch ignore</span><br></pre></td></tr></table></figure>
<p>另外，客户端push成功了，服务器也有了日志，但是服务器文件是不会自动更新的，被修改的文件显示modify状态。发现用checkout切换分支可以自动更新（?）。</p>
<ol start="13">
<li>克隆<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;project-address&gt;</span><br></pre></td></tr></table></figure>
GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="noopener">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></li>
</ol>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<ol start="14">
<li>分支<br>Git鼓励大量使用分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看分支：</span></span><br><span class="line">git branch</span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建分支：</span></span><br><span class="line">git branch &lt;name&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#切换分支：</span></span><br><span class="line">git checkout &lt;name&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建+切换分支：</span></span><br><span class="line">git checkout -b &lt;name&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#合并某分支到当前分支：</span></span><br><span class="line">git merge &lt;name&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#删除分支：</span></span><br><span class="line">git branch -d &lt;name&gt;</span><br><span class="line"><span class="comment">#强制删除：</span></span><br><span class="line">git branch -D &lt;name&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看分支合并图<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure></li>
<li>bug分支处理</li>
</ol>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</p>
<ol start="17">
<li>新模块/特征分支处理</li>
</ol>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<ol start="18">
<li>多人开发注意项</li>
</ol>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<ol start="19">
<li>变基<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase</span><br></pre></td></tr></table></figure>
rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
</ol>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<ol start="20">
<li>标签管理</li>
</ol>
<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p><strong>Git有commit，为什么还要引入tag？</strong></p>
<p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt;<span class="comment">#用于新建一个标签，默认为HEAD，也可以指定一个commit id；</span></span><br><span class="line"> </span><br><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">"blablabla..."</span><span class="comment">#可以指定标签信息；</span></span><br><span class="line"> </span><br><span class="line">git tag<span class="comment">#可以查看所有标签。</span></span><br><span class="line"> </span><br><span class="line">git push origin &lt;tagname&gt;<span class="comment">#可以推送一个本地标签；</span></span><br><span class="line"> </span><br><span class="line">git push origin --tags<span class="comment">#可以推送全部未推送过的本地标签；</span></span><br><span class="line"> </span><br><span class="line">git tag -d &lt;tagname&gt;<span class="comment">#可以删除一个本地标签；</span></span><br><span class="line"> </span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;<span class="comment">#可以删除一个远程标签。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt自己编写keyboad虚拟键盘</title>
    <url>/2018/10/24/Qt%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99keyboad%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>由于项目中有需要用到虚拟键盘，首先想到的是系统自带的，笔者是Ubuntu16 + Qt5.9。</p>
<a id="more"></a>
<ol>
<li>系统虚拟键盘的优缺点：</li>
</ol>
<p><strong>优点</strong>：直接可以脚本调起，功能完善，稳定。外观完美。</p>
<p><strong>缺点</strong>：定制麻烦（详情看onboard帮助文档，英文），要想像手机那样用时自动显示，不用时自动隐藏，需要先设置系统的输入法，而且需要GNome的辅助功能支持。<br><img src="20181024180737982.png" alt=""><br>2. Qt5已经有自带输入法了。Qt安装的时候就有一个virtualkeyboard选项，安装即可，编译生成完了，会在安装目录的plugins/plaforminputcontexts目录下。</p>
<p><strong>优点</strong>：美观，方便，功能完善，跨平台，支持中文</p>
<p><strong>缺点</strong>：定制的话在于改源代码的能力了，这是一个基于qml开发的插件，所以如果是widget使用的话需要用qquickwidget组件包装才能正常调出键盘。<br><img src="20181024181912328.png" alt=""></p>
<ol start="3">
<li>自己写一个plaforminputcontextsplugin</li>
</ol>
<p>这个呢，非常感谢下面两篇连接的作者，链接如下：</p>
<p><a href="https://blog.csdn.net/tracing/article/details/50617571" target="_blank" rel="noopener">QT5的软键盘实现</a>…</p>
<p><a href="https://blog.csdn.net/wzs250969969/article/details/78418725" target="_blank" rel="noopener">QT之全平台虚拟键盘</a>…</p>
<p><strong>优点</strong>：能实现简单定制键盘，可以了解并学习Qt插件开发规则</p>
<p><strong>缺点</strong>：该input插件依赖DBus通信，而windows对DBus支持有很多问题要解决，<br>所幸Ubuntu是没问题的（好像搜狗的拼音，也是有开发Qt插件的，在linux平台的Qtcreator支持上，否则搜狗也是不能用于QtCreator的中文输入）<a href="https://download.csdn.net/download/evil_119/10742059" target="_blank" rel="noopener">源代码链接</a><br><img src="20181024184023154.png" alt=""></p>
<ol start="4">
<li>在3的基础上自己封装定制dll</li>
</ol>
<p>在应用程序中添加本地库到当前工程，在pro文件中加以下类似代码：</p>
<p><code>LIBS += -L$$OUT_PWD/../keyboard/debug/ -lkeyboard</code><br>然后在主程序中调用即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Keyboard</span> objKeyboard;<span class="comment">//创建对象</span></span><br><span class="line">    objKeyboard.showDigital();<span class="comment">//显示数字键盘</span></span><br><span class="line"> </span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：自由定制，重复利用，跨平台。最后上个效果图。<br><img src="20181024184526544.png" alt=""><br>美化一下也是可以的：<br><img src="20200218103458.png" alt=""></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>keyboad</tag>
        <tag>虚拟键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt想用QLibrary动态加载库</title>
    <url>/2018/10/24/Qt%E6%83%B3%E7%94%A8QLibrary%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
    <content><![CDATA[<p>最近写了一个小组件没错就是虚拟键盘，打包成动态库了，但发现一个小问题，就是QLibrary动态加载总有问题当然，在做下面测试的之前，肯定是需要保证自己的dll是ok的，右击工程添加本地库是正常执行了的。</p>
<a id="more"></a>
<p>首先在pro文件中即使添加库路径如下</p>
<p><code>LIBS += -L$$OUT_PWD/../keyboard/debug/</code><br>当然我删除了<code>-lkeyboard</code>，因为我要用<code>QLibrary::load()</code>,然而还是如下图：<br><img src="20181024174727161.png" alt=""><br>但这是一个编译中的link错误，显然包含.h文件是成功了的，目前猜测应该是解析lib*.a失败的原因吧，解析函数接口失败。</p>
<p>load是一个运行态的，所以在此还看不到效果，但是如果要是在pro中加上 -lkeyboard 静态加载了那我还load干啥，不是？</p>
<p>有点懵逼，以后有时间再研究了，可能与我的库导出的类也有一定关系吧，我的导出类是一个继承自QObject的子类。</p>
<p>最后：<br>后面用resolve()配合load()可以解决，但是麻烦。</p>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 16.04 关闭开启图形界面之systemctl命令</title>
    <url>/2018/10/23/ubuntu%2016.04%20%E5%85%B3%E9%97%AD%E5%BC%80%E5%90%AF%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%B9%8Bsystemctl%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>ubuntu16.04关掉图形界面启动，命令：<code>systemctl disable lightdm.service</code></p>
<p>确实生效了，但是由于不能显示笔者的应用程序（QT界面程序），系统一直卡死在启动界面，还不如进gnome界面了，故又想恢复，发现恢复之路坑太多了。</p>
<a id="more"></a>
<ol>
<li><p>因为界面卡死，是不能用输命令的，所以只能且系统模式，好在ctrl+alt+f1还是能用的，进入文本模式。</p>
</li>
<li><p>百度systemctl enable lightdm.service之后reboot你以为有用？</p>
</li>
<li><p>没用，那再加一行：<code>sudo service lightdm start</code> ，reboot还是无用</p>
</li>
<li><p>但是发现从文本模式能使用startx进入图形界面，reboot，呵呵空欢喜</p>
</li>
<li><p>还有人进入图形界面后查看service status lightdm，当然正常了。不然怎么可能进入图形界面？所以最后猜测是系统启动程序没有调用lightdm，</p>
</li>
</ol>
<p>很有幸猜对了，只剩最后一个问题，因为Ubuntu系统启动有多种方式，我们要如何处理</p>
<p>跳过以上看重点：</p>
<p>正确的开启图形界面命令：<br><code>sudo ln -s /lib/systemd/system/lightdm.service /etc/systemd/system/display-manager.service</code></p>
<p>之后执行 : <code>reboot</code><br>即可恢复界面显示。</p>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title>QT5中Model,View模型的使用</title>
    <url>/2018/09/30/QT5%E4%B8%ADModel,View%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>该文章不对model/view的初级使用做解释。qt引入Model/view结构，目的是为了提高传统QTabelWidget等的大数据刷新的效率。既然是为高效率显示而设计的，我们使用时就需要对其设计思路做了解。</p>
<a id="more"></a>
<p>view的继承模型如下图：<br><img src="QT5%E4%B8%ADModel,View%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/20180930140558515.png" alt=""></p>
<p>model继承模型如下图：<br><img src="QT5%E4%B8%ADModel,View%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/2018093016103156.png" alt=""></p>
<p>结合两个类继承图，我们可以看出<code>Model/view</code>是完全分开设计的，目的就是解耦合，Model只做数据管理，view只做显示，view与model之间的通信，就是一个重要函数了<code>setModel</code>,大可猜出该函数建立起了<code>model/view</code>之间的信号槽连接（因为笔者是win系统，没有下载源码，从严谨性来说只能说是猜测了，里面肯定有一堆connect()….），选择什么view，及view的使用其实比较简单（通过继承关系图也可以看出来），我们重点说Model，常用的Model大体可分为两类：一类是抽象接口分支下的常用数据模型，二类是数据委托，Delegate结尾的，这一类主要解决的是我们在view中显示的方式的问题，如：</p>
<p><img src="QT5%E4%B8%ADModel,View%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/20180930142909340.png" alt=""></p>
<p>这类型列表，通常结合数据编辑器使用以达到较优的用户体验。</p>
<p>最后说一下数据代理模型，qt原生提供的就两个实例（<code>QIdenityProxyModel/QSortFilterProxyModel</code>)，前者是唯一索引代理，后者是排序筛选代理，前者可能sqlModel用的较多一点，后者其实更普遍，当表格需要排序时，筛选部分数据显示时即可使用后者，另，如果两者皆不满足需求，我们可以直接继承<code>QAbstractProxyModel</code>实现自己的<code>proxyModel</code>。</p>
<p>笔者最近就是有一个多view使用同一个Model的情景。使用ProxyModel即可优雅的解决。各个view通过设置各自的QSortFilterProxyModel即可，而各ProxyModel只需setSourceModel成同一个Model即可。某个view对model数据更改后，只需</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">emit m_model-&gt;dataChanged(index,index);</span><br></pre></td></tr></table></figure>
<p>即可同步所有的view更新。注意，更新时，如果有selectionModel该selectionModel是不会立马更新的，通过继承图可以看到selectionModel也是独立的。所以如果我们需要更新view的选择项，可以执行这句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">view-&gt;selectionModel()-&gt;<span class="built_in">clear</span>();<span class="comment">//清除选中项</span></span><br></pre></td></tr></table></figure>
<p>这样就间接的更新了选中项了，qt的选中项作为一个独立模块，当我们需要遍历列表中所有选中项的时候也是需要先拿到selectionModel对象的，代码是：<code>view-&gt;selectionModel()</code>.然后就可以用该对象获取<code>selectedRows()/selectionIndexs()</code>等函数了。</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>model</tag>
        <tag>view</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>QT状态机的使用</title>
    <url>/2018/09/18/QT%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>状态机定义本文不做叙述，qt内核中已经封装了状态机，状态机编程主要应用的类有QStateMachine，该类封装了状态机的入口start及出口stop接口。QState封装了两种种状态模型（互斥，并行)，即<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q_CORE_EXPORT</span> <span class="title">QState</span> :</span> <span class="keyword">public</span> QAbstractState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ChildMode &#123;</span><br><span class="line">        ExclusiveStates,</span><br><span class="line">        ParallelStates</span><br><span class="line">    &#125;;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类提供的是用户各种状态的定义。</p>
<p>QFinalState该类是一个特殊状态，负责终止状态机的运行。</p>
<p>QSignalTransition这是一个基于信号封装的状态变换。作用：可以绑定信号（含用户自定义信号），响应相应状态，使状态之间的切换通过信号/槽（含私有信号/槽）传递。</p>
<p>QPropertyAnimation动画中的一种，这个是属性动画，动画的作用是使状态之间过渡顺畅一些不至于太生硬。</p>
<blockquote>
<p>最后使用状态机程序必须有事件循环。</p>
</blockquote>
<p>下面看一个简单的应用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWidget::createStateMachine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建状态机</span></span><br><span class="line">    m_machine = <span class="keyword">new</span> QStateMachine;</span><br><span class="line">    <span class="comment">//2.创建状态</span></span><br><span class="line">    m_State1 = <span class="keyword">new</span> QState(QState::ExclusiveStates, m_machine);</span><br><span class="line">    m_State2 = <span class="keyword">new</span> QState(QState::ExclusiveStates, m_machine);</span><br><span class="line">    m_FinalState = <span class="keyword">new</span> QFinalState(m_machine);</span><br><span class="line">    <span class="comment">//3.各状态属性赋值</span></span><br><span class="line">    m_State1-&gt;assignProperty(m_titleWidget, <span class="string">"maximumHeight"</span>, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    m_State2-&gt;assignProperty(m_titleWidget, <span class="string">"maximumHeight"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.各状态绑定逻辑变换</span></span><br><span class="line">    m_transition1 = m_State1-&gt;addTransition(<span class="keyword">this</span>, SIGNAL(startStateMachine()), m_State2);</span><br><span class="line">    m_transition2 = m_State2-&gt;addTransition(<span class="keyword">this</span>, SIGNAL(startStateMachine()), m_State1);</span><br><span class="line"><span class="comment">//想结束就绑定下面这行代码</span></span><br><span class="line"><span class="comment">//    m_State2-&gt;addTransition(m_State1, SIGNAL(propertiesAssigned()), m_FinalState) ;</span></span><br><span class="line">    <span class="comment">//5.绑定状态进入后的处理逻辑，该部分可以省略</span></span><br><span class="line">    <span class="built_in">connect</span>(m_State1, &amp;QState::entered, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        m_bStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(m_State2, &amp;QState::entered, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        m_bStatus = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//6.创建过渡动画</span></span><br><span class="line">    m_pAnimation_top = <span class="keyword">new</span> QPropertyAnimation(m_titleWidget, <span class="string">"maximumHeight"</span>);</span><br><span class="line">    <span class="comment">//设置动画时长</span></span><br><span class="line">    m_pAnimation_top-&gt;setDuration(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">//7.绑定个动画到变换</span></span><br><span class="line">    m_transition1-&gt;addAnimation(m_pAnimation_top);</span><br><span class="line">    m_transition2-&gt;addAnimation(m_pAnimation_top);</span><br><span class="line">    <span class="comment">//8.设置初始状态</span></span><br><span class="line">    m_machine-&gt;setInitialState(m_StartState);</span><br><span class="line">    <span class="comment">//9.启动状态机</span></span><br><span class="line">    m_machine-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">void</span> ~MainWidget()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_machine)</span><br><span class="line">    m_machine-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>QT5如何打包到Ubuntu16</title>
    <url>/2018/06/20/QT5%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E5%88%B0Ubuntu16/</url>
    <content><![CDATA[<p>最近一个跨平台的项目打包折腾的够呛，所以记录一波。没有用打包工具也正好从原理层分析讲解。qt自带的打包工具其实会方便但是冗余依赖库也挺多。具体看需求了。</p>
<a id="more"></a>
<p><code>ldd 应用程序名</code></p>
<p>可以查看该应用程序名下面的所有依赖库，所以该命令很重要。网上有人利用该命令去导出所以依赖库，附代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">exe=<span class="string">"./appname"</span></span><br><span class="line"><span class="comment">#发布的程序名</span></span><br><span class="line">des=<span class="string">"/home/myname/Qt5.9/"</span></span><br><span class="line"><span class="comment">#目标路径</span></span><br><span class="line"> </span><br><span class="line">deplist=$(ldd <span class="variable">$exe</span> | awk <span class="string">'&#123;if (match($3,"/")) &#123; printf("%s "),$3 &#125; &#125;'</span>)</span><br><span class="line">cp <span class="variable">$deplist</span> <span class="variable">$des</span></span><br></pre></td></tr></table></figure>
<p>看上去很完美，当程序依旧运行不了的时候，才发现人家的东西毕竟不是自己的，所以追本溯源才是重要的。根据程序报错来解决呗。</p>
<ol>
<li>报错QT_5库no found：</li>
</ol>
<p>进入开发机的qt安装目录如：<code>/opt/qt5.9.4/5.9.4/gcc_64/（本人是64位系统）</code>，几个目录简要说明：</p>
<p><code>bin/</code>    属于qt的一些运行文件如qmake,moc,designer等等</p>
<p>（附加说明一下，该目录下有一个qt.conf文件，该文件是用来指定程序路径结构的）</p>
<p><code>include/</code>    包含了所有qt的头文件</p>
<p><code>doc/</code>    帮助文档等</p>
<p><code>translation/</code>    qtcreate支持的所有语言语种</p>
<p><code>mkspecs/</code>    qt支持的所有编译器</p>
<p><code>phrasebooks/</code>    qt常用语手册，多国语言</p>
<p><code>qml/</code>    qml相关</p>
<p><code>lib/</code>    所有qt程序依赖库</p>
<p><code>plugins/</code>    所有qt插件</p>
<p>有平台相关，图片相关，多媒体，qml，sql，xcb等等。</p>
<p>拷贝lib目录下的程序依赖库到lib文件夹，到时候直接拷贝整个文件夹到目标机中即可。</p>
<p>根据错误提示，基本</p>
<p><code>cp -a libQt5Core.so* libQt5Widget.so* libQt5Gui.so* libQt5Netword.so* libQt5Svg.so* libQt5Sql.so* libQt5SerialPort.so* 目标路径/lib</code></p>
<p>为什么要用*结尾，目的是连软链接一起拷贝走，否则，系统还是用自带的qt库，所以我们需要<code>libQt5Core.so.5</code>这样的软链接被新版本覆盖掉，还有一种方式就是重命名所有的依赖库，linux下的动态库可是有一串的版本相关，这点上windows显得更精简。</p>
<p>最后将目标路径/lib拷贝到目标机的 <code>/usr/lib/x86...(64位机)</code>，运行报错不一样了，说明依赖的qt库有作用了。</p>
<ol start="2">
<li>继续报错qt5，但库明显不一样了。</li>
</ol>
<p>步骤同上：</p>
<p><code>cp -a libicui18n.so* libicuuc.so* libicudata.so* 目标路径/lib</code></p>
<p>这次报错不一样了</p>
<ol start="3">
<li>“xcb”平台相关xcb no found</li>
</ol>
<p>xcb相关的东西是真多，好在系统已经自带了一部，我们只需拷贝qt相关的就好了</p>
<p><code>cp -a libQt5DBus.so* libQt5XcbQpa.so.5*目标路径/lib</code></p>
<p><code>cp -a plugins/platforms plugins/xcbglintegrations 目标路径/plugins</code>（将qt的xcb插件拷贝到目标机，目标路径为运行文件所在路径）</p>
<p>此处花费时间最长，网上各种说法，真是五花八门。其实很简单就能解决的。linux就是很多这种看似很复杂实际很简单的操作，被人们用的太乱导致的。</p>
<p>此时程序终于可以爬起来了。但是</p>
<ol start="4">
<li>程序图标不显示</li>
</ol>
<p>第一反应是images/目录没拷贝过来，是不是像win程序那样要加载资源，cp，然而一样，才醒悟过来，编译的时候就已经编译进去了。后面这点在开发机得以证实，是不需要images的。仔细查看运行中的程序发现是部分图片没显示，对比发现ico能显示正常，png显示不了，发现qt插件中还有个imageformats文件夹呢，一试，果然好了，此时程序基本ok了。</p>
<p><code>cp -a plugins/imageformats 目标路径/plugins</code>（这里发现iconengines与sqldrivers等居然可以不要拷贝？嗯，后续遇到再拷贝过来吧。本程序是有用ico，sql的哦）</p>
<ol start="5">
<li>不能播放声音</li>
</ol>
<p>呵，简单了，<code>cp -a plugins/mediaservice playlistformats 目标路径/plugins</code></p>
<p>然而并没有用！！！baidu。果然没什么卵用。基本就是说gstreame/dsengine,后面才知道这两个一个是linux的开源多媒体引擎，一个是win平台的多媒体引擎。对比两平台的mediaservice插件，果然win是<code>dsengine.dll</code>. linux是<code>libgst*.so.</code>那就看看这些库依赖的库呗。目标机执行</p>
<p><code>ldd libgst*.so.</code>    呵呵，no found <code>libQt5MultiMedia</code> 。。等等。统统cp一下。GAME START!完美！</p>
<p><strong>补充：</strong></p>
<ol>
<li>linux系统提供的共享库目录是<code>/lib</code>，<code>/usr/lib (64位是/usr/lib/x86_64-linux-gun)</code>。如何添加新的搜索目录？</li>
<li>添加的搜索路径默认是放在<code>/etc/ld.so.conf.d/</code>目录下的所有文件中的，所以只需要在该目录下新建一个文件比如说<code>opencv.conf</code>，然后在该文件中加入.so文件的路径，比如<code>/usr/local/lib</code> 就可以了。切记，添加完后执行<code>ldconfig</code>使命令生效。</li>
</ol>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>qt5.9中虚拟键盘的中文使用</title>
    <url>/2018/05/04/qt5-9%E4%B8%AD%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>qtvirtualkeyboard是qt基于qtquick的一个项目，源代码目录如下图：<a id="more"></a><br><img src="20180504113659381.png" alt=""><br>为何要提到这个呢，是因为本文想解释中文输入。否则只需在安装qt的过程中将qtvirtualkeyboard插件打上勾就能在qml工程中使用了<br>qtvirtualkeyboard工程包含例程，库，插件等。例程是basic一个简单的qml项目，<br>库有多个语言库，在目录<code>qtvirtualkeyboard\src\virtualkeyboard\3rdparty</code>中找到<code>pinyin</code>文件夹，包含了中文拼音输入法的依赖库项目，编译后会生成相应的静态库文件<code>libqtpinyin.a/libqtpinyind.a</code> (本人是win+mingw32环境)。</p>
<p><strong>重点：</strong></p>
<ol>
<li><p><code>cd ~/qtvirtualkeyboard目录</code></p>
</li>
<li><p><code>qmake CONFIG+=&quot;lang-en_GB lang-zh_CN&quot;</code><br>注意：要带引号，如果没找到qmake命令是系统环境变量没设置</p>
</li>
</ol>
<p>这一步会生成两个文件<code>.qmake.cache</code>和<code>.qmake.stash</code></p>
<ol start="3">
<li><code>mingw32-make.exe</code>如果是vs编译器<code>nmake.exe</code></li>
</ol>
<p>这一步要一段时间编译</p>
<ol start="4">
<li><code>mingw32-make.exe install</code>    如果是vs编译器<code>nmake.exe install</code></li>
</ol>
<p>安装语言包</p>
<ol start="5">
<li>重新打开basic工程，运行即可得到带中文的虚拟键盘了。且该键盘是对所有键盘程序都影响的不是只针对某一个App.最后上个其他测试程序的图，尽量截了一个含中英文切换的图片<br><img src="20180504115735851.png" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>虚拟键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu/Windows使用glog</title>
    <url>/2018/04/03/Ubuntu-Windows%E4%BD%BF%E7%94%A8glog/</url>
    <content><![CDATA[<p>本文glog版本位0.3.5。</p>
<h2 id="glog获取"><a href="#glog获取" class="headerlink" title="glog获取"></a>glog获取</h2><pre><code>`git clone [https://github.com/google/glog.git](https://github.com/google/glog.git)`
或者直接网页下载下来，`tar -xzvf google-master*.gz`</code></pre><a id="more"></a>
<h2 id="glog编译生成"><a href="#glog编译生成" class="headerlink" title="glog编译生成"></a>glog编译生成</h2><pre><code>如果是window平台，得使用CMake工具生成解决方案并编译生成相应的libglog.dll,libglog.lib本文不作赘述。前面以说过CMake的使用。

Ubuntu生成库还是很方便的，基本命令流程就是

`./autogen.sh` 该工具如果没安装会报错，安装命令`sudo apt-get install autoconf automake libtool`，必须是三个包都安装

`./configure` 生成配置信息，可以在此改变生成路径，否则默认是`/usr/local/lib`目录

`make`

`make install` 这里可能需要sudo，执行无报错，会生成相应的库文件：libglog.a,libglog.so....

可以将生成的动态库放到系统lib目录`cp libglog.so* /usr/lib`</code></pre><h2 id="glog使用"><a href="#glog使用" class="headerlink" title="glog使用"></a>glog使用</h2><pre><code>库已经生成了，头文件结构如下图（这是我的qt中引用的结构）：</code></pre><p><img src="20180403195638667.png" alt=""><br>    测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	google::InitGoogleLogging(argv[<span class="number">0</span>]);<span class="comment">//初始化</span></span><br><span class="line">        google::SetLogDestination(google::GLOG_INFO,<span class="string">"./aTestInfo"</span>);<span class="comment">//设置日志文件路径，默认+时间作为生成的日志文件名</span></span><br><span class="line">	LOG(INFO)&lt;&lt;<span class="string">"HELLO"</span>&lt;&lt;<span class="string">" WORLD!"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ Test.cpp -L库目录 -lglog</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<p><img src="20180403200506539.png" alt=""><br>顺便附上qt工程配置</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += ./<span class="number">3</span>rdParty/glog-master/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">LIBS += -L./<span class="number">3</span>rdParty/glog-master/<span class="class"><span class="keyword">lib</span> -<span class="title">lglog</span></span></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><span style=color:red>注意</span></h2><p>你可以使用以下的日志等级（日志等级从低到高）：INFO. WARNING. ERROR和FATAL。使用FATAL打印日志的时候，程序会在打印该日志后终止。需要注意的是，一个给定的日志等级日志信息不仅会记录到当前的日志等级文件，还会记录到所有比他等级低的日志文件内（就是说，WARNGING的日志不仅会打印到日志文件warnging中，还会打印到INFO日志文件中），比如FATAL的日志会打印到所有的日志文件中，包括INFO. WARNING. ERROR和FATAL。</p>
<h2 id="Windows使用glog（0-3-5）"><a href="#Windows使用glog（0-3-5）" class="headerlink" title="Windows使用glog（0.3.5）"></a>Windows使用glog（0.3.5）</h2><p>此版本glog在window下CMake会生成一系列项目，如图glog只生成lib库<br><img src="20180404171239399.png" alt=""><br>这在之前的版本会生成dll，lib等几个工程，现在就只有一个工程了也只需要使用这一个静态库，换句话说可能是考虑到项目本来就轻巧，不需要dll，直接lib足够了。</p>
<p>下面说使用注意点：</p>
<ol>
<li><p>在需要的地方<code>#include &quot;glog/logging.h&quot;</code>。建议添加到stdafx.h中。 </p>
</li>
<li><p>使用静态库必须添加<code>#define GOOGLE_GLOG_DLL_DECL</code>。动态库不必添加。</p>
</li>
<li><p>因windows.h中定义的宏ERROR，与glog中定义的宏ERROR冲突，所以如果<code>#include &lt;windows.h&gt;</code>后要添加<code>#define GLOG_NO_ABBREVIATED_SEVERITIES</code>，并且代码中要用<code>google::GLOG_ERROR</code>来代替原来的<code>google::ERROR</code>，相应的其他也改为：GLOG_INFO. GLOG_WARNING. GLOG_FATAL。</p>
</li>
<li><p>添加库文件：<code>#pragma comment(lib,&quot;glog/libglog_static.lib&quot;)</code><br><img src="20180404173834859.png" alt=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>glog</tag>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>CEF3的使用说明及CMake使用</title>
    <url>/2017/12/08/CEF3%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%8F%8ACMake%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="CEF简介"><a href="#CEF简介" class="headerlink" title="CEF简介"></a>CEF简介</h2><p>Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。</p>
<a id="more"></a>
<p>简单说就是Chrome的开源版，目前很多所谓的双核浏览器，实质就是chrome+IE的双核。基于HTML5的支持，以及v8引擎的效率，在软<br>件中嵌入chromium是个不错的选择，而且目前市面上应用及其广泛，如：tx系软件。spy++一抓就知道了，如下图<br><img src="20171208150431090.jpg" alt=""></p>
<h2 id="cef下载"><a href="#cef下载" class="headerlink" title="cef下载"></a>cef下载</h2><p><a href="http://opensource.spotify.com/cefbuilds/index.html" target="_blank" rel="noopener">下载地址</a>下载速度是不快，但总算下载下来了，由于本人是vs2013，遇到的坑就是3.3以上的版本至少要vs2015以上才能编译，总之搞了很久最后下了一个3.27版本才成功，提示：如果不打算放弃32位就建议下载32位版本吧，不然64位软件在32位系统是跑不起来的。<br>由于新下载的标准开发包解压就是如下图了，<br><img src="20171208150453786.jpg" alt=""><br>文件目录结构在此做下说明，很是重要。笔者在此花费了很多时间。</p>
<ol>
<li>首先建议先阅读Readme.txt，该文件对项目结构做了简要说明。当然看一遍肯定不可能完全理解。但随着对项目的熟悉了解，发现该文件说的还是挺清晰的。</li>
<li>licence.txt没啥说的，就是关于版权的说明。<br>几个gyp/gypi文件是不能手动修改的，是GYP（Generate Your Projects）工具自动生成的相当于工程配置文件。插入一段GYP说明：<blockquote>
</blockquote>
GYP结构<br>GYP的输入是.gyp和.gypi文件，.gypi文件是用于.gyp文件include使用的。.gyp文件就是符合特定格式的json文件。<br>gyp文件中包含target，Visual C++下，gyp生成sln，target生成vcproj或vxcproj。<br>chromium中GYP结构是，通过命令行统一使用build/common.gypi的公共文件，工程的配置，选项的处理，编译选项的使用，都是在这个文件中配置。</li>
</ol>
<blockquote>
<p>生成一个总工程all.gyp，这个工程依赖于其他所有的工程，这个工程生成，所有工程都生成完成。而且有一个总工程也方便开发。<br>如果要使用GYP，建议依照chromium的结构，common.gypi也用chromium的进行裁剪，毕竟各种选项的选择也是需要经验的。</p>
</blockquote>
<blockquote>
<p>使用GYP<br>chromium工程中的方法是使用build/gyp_chromium这个Python脚本来调用，这个脚本实现添加公共配置，侦测附加配置，添加需要的编译选项。</p>
</blockquote>
<ol start="3">
<li>然后就是介绍CMakeList.txt文件了，该文件非常重要。这里要引入CMake的一些知识，下载地址：<br><a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake下载地址</a><br>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(目前很多开源跨平台库都使用此方式如：ProtoBuf，cef)。</li>
</ol>
<p>CMake脚本本文不做介绍，由于当前用的win平台所以直接下载免安装版解压运行cmake-gui.exe,（说句废话，这是一个qt程序，</p>
<p>跨平台还是选择了qt，呵呵）。<br><img src="20171208155106665.png" alt=""></p>
<p>需要注意的就是源代码目录和生成工程文件的目录了，<code>configue</code>没错误就<code>Generate</code>生成相应vs版本工程文件，然后<code>OpenProject</code>，<br><img src="20171208155909895.jpg" alt=""><br>正常情况就是所有的项目（包括库和测试程序）都包含在这个工程中。<br><code>libcef_dll_wrapper</code>会生成一个库，<code>cefclient</code>和<code>cefsimple</code>则会生成测试程序，对应下面两张图。<br><img src="20171208160252696.jpg" alt=""><br><img src="20171208160332354.jpg" alt=""></p>
<ol start="4">
<li>文件夹介绍</li>
</ol>
<p>（1）cmake，该文件夹包含Cmake的一些宏定义，配置信息。<br>（2）include，使用该库的所有头文件<br>（3）libcef_dll，库的源代码<br>（4）tests，测试程序demo源代码<br>（5）Resource,资源文件<br>该资源文件是程序运行需要依赖的资源文件，含语言包，unicode支持等<br>（6）Debug/Release，程序依赖的动态库/静态库。但不包括C++库：libcef_dll_wrapper.lib。</p>
<p><strong>1. 必须文件，缺少任意一个CEF将无法运行：</strong><br>libcef.dll<br>    这个不用多说，CEF的核心库文件，js引擎、网页加载渲染逻辑等都在其中，也是size最大的一个文件（Release版将近50M，Debug版超过500M）。<br>icudtl.dat<br>    用来支持unicode，缺少这些文件虽然编译能通过，但是执行CefInitialize();的时候就会崩溃，在这个坑趴了很久还以为是代码问题。<br>natives_blob.bin<br>snapshot_blob.bin<br>    V8引擎快照数据。<br><strong>2. 可选文件：</strong><br>locales/<br>    该目录包含CEF，Chromium和Blink使用的本地化资源。 CefSettings.locale指定需要加载的.pak文件。 只需要发布配置的区域对应的.pak文件。</p>
<p>如果没有区域设置将配置默认语言环境“en-US”。如果没有这些文件任意Web组件可能显示不正确。<br>cef.pak<br>cef_100_percent.pak<br>cef_200_percent.pak<br>    这些文件包含了供CEF使用的区域无关资源，缺少这些文件任意Web组件可能显示不正确。（笔者当时缺少cef_100_percent.pak，</p>
<p>cef_200_percent.pak两文件，导致视频控件不显示音量和最大化按钮）。<br>cef_extensions.pak<br>    此文件包含扩展加载所需的非本地化资源传递<code>--disable-extensions</code>命令行标志来禁止使用文件。没有这个文件，依赖于扩展系统的组件将不起作用，</p>
<p>如PDF查看器。<br>devtools_resources.pak<br>    此文件包含Chrome开发者工具所需的非本地化资源，缺少这个文件，Chrome开发者工具将无法运行。<br>d3dcompiler_43.dll (Windows XP需要该文件)<br>d3dcompiler_47.dll (Windows Vista和更高版本的系统需要该文件)<br>libEGL.dll<br>libGLESv2.dll<br>    Direct3D支持文件，如果缺少这些文件，HTML5在渲染2D画布，3D CSS，WebGL时将不起作用。<br>wow_helper.exe<br>    用来支持Windows Vista 64位沙箱。如果没有这个文件，32位的CEF将无法在开启了沙箱的64位的Vista机器上运行。</p>
<p><a href="https://bitbucket.org/chromiumembedded/cef/src/816f700d3ea42bedc5ca5a2314c27b761b69abc5/tools/distrib/win/README.redistrib.txt?at=master&fileviewer=file-view-default" target="_blank" rel="noopener">英文原文</a></p>
<p>附MFC使用CEF3简单Demo代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCDlgCefTestDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化代码</span></span><br><span class="line">	<span class="function">CefRefPtr&lt;CSimpleClient&gt; <span class="title">client</span><span class="params">(<span class="keyword">new</span> CSimpleClient())</span></span>;</span><br><span class="line">	m_simpleClient = client;</span><br><span class="line"></span><br><span class="line">	CefSettings settings;</span><br><span class="line">	CefSettingsTraits::init(&amp;settings);</span><br><span class="line">	settings.multi_threaded_message_loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	CefMainArgs mainArgs;</span><br><span class="line">	CefRefPtr&lt;CefApp&gt; cefApp;</span><br><span class="line">	CefInitialize(mainArgs, settings, cefApp, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	RECT <span class="built_in">rect</span>;</span><br><span class="line">	GetClientRect(&amp;<span class="built_in">rect</span>);</span><br><span class="line">	RECT rectnew = <span class="built_in">rect</span>;</span><br><span class="line">	CefWindowInfo winInfo;</span><br><span class="line">	winInfo.SetAsChild(GetSafeHwnd(), rectnew);</span><br><span class="line"></span><br><span class="line">	CefBrowserSettings browserSettings;</span><br><span class="line">	CefBrowserHost::CreateBrowser(winInfo, client, _T(<span class="string">"http://www.lofter.com"</span>), browserSettings, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCDlgCefTestDlg::OnClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">	m_simpleClient-&gt;Release();</span><br><span class="line">	CefShutdown();<span class="comment">//其实这行代码如果没有设置cefApp的话，是会崩溃的，测试完全可以注释。但切记，该函数只能在主线程中调用。后续深入学习后，还需解一下惑</span></span><br><span class="line">	CDialogEx::OnClose();</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">	m_simpleClient-&gt;Release();</span><br><span class="line">	CefShutdown();<span class="comment">//其实这行代码如果没有设置cefApp的话，是会崩溃的，测试完全可以注释。但切记，该函数只能在主线程中调用。后续深入学习后，还需解一下惑</span></span><br><span class="line">	CDialogEx::OnClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="20171208164157983.jpg" alt="lofter"><br>推荐一个不错的文档地址：</p>
<p><a href="https://github.com/fanfeilong/cefutil" target="_blank" rel="noopener">github文档</a></p>
<p><a href="http://download.csdn.net/download/evil_119/10151078" target="_blank" rel="noopener">csdn下载</a></p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>cef</tag>
        <tag>cmake</tag>
        <tag>chromium</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>开发界面之窗口边框重绘</title>
    <url>/2017/11/24/%E5%BC%80%E5%8F%91%E7%95%8C%E9%9D%A2%E4%B9%8B%E7%AA%97%E5%8F%A3%E8%BE%B9%E6%A1%86%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<p>基于上篇已经解决了富图软件窗口child的效果。这边主要仿照其重绘边框——即活动窗口边框高亮，本文不讲标题栏与border重绘（难度是比Client绘制要难，但是社区也有人做了相应的demo），基于富图考虑，它不要标题栏，我们也用无边框窗口绘制就好了。</p>
<a id="more"></a>
<h2 id="边框及标题栏绘制"><a href="#边框及标题栏绘制" class="headerlink" title="边框及标题栏绘制"></a>边框及标题栏绘制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgFrm::OnPaint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">// device context for painting</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此处添加消息处理程序代码</span></span><br><span class="line">	<span class="comment">// 不为绘图消息调用 CDialogEx::OnPaint()</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//画边框</span></span><br><span class="line">	HPEN newPen = CreatePen(PS_SOLID, <span class="number">2</span>, m_colFrm);</span><br><span class="line">	HPEN oPen = (HPEN)dc.SelectObject(newPen);</span><br><span class="line">	CRect rc, rc2;</span><br><span class="line">	GetClientRect(rc);</span><br><span class="line">	rc.left = rc.top = <span class="number">2</span>;</span><br><span class="line">	dc.Rectangle(rc);</span><br><span class="line">	dc.SelectObject(oPen);</span><br><span class="line">	<span class="comment">//画标题栏</span></span><br><span class="line">	oPen = (HPEN)dc.SelectObject(GetStockObject(NULL_PEN));</span><br><span class="line">	HBRUSH newBrsh = CreateSolidBrush(RGB(<span class="number">130</span>, <span class="number">130</span>, <span class="number">130</span>));</span><br><span class="line">	HBRUSH oldBrsh = (HBRUSH)dc.SelectObject(newBrsh);</span><br><span class="line">	dc.Rectangle(<span class="number">3</span>, <span class="number">3</span>, rc.Width()+<span class="number">1</span>, <span class="number">33</span>);</span><br><span class="line">	dc.SelectObject(oldBrsh);</span><br><span class="line">	::DeleteObject(newBrsh);</span><br><span class="line">	dc.SelectObject(oPen);</span><br><span class="line">	<span class="comment">//画标题文字</span></span><br><span class="line">	<span class="keyword">if</span> (m_strTitle.IsEmpty() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		rc = CRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">		dc.SetTextColor(RGB(<span class="number">255</span>, <span class="number">250</span>, <span class="number">250</span>));</span><br><span class="line">		dc.SetBkMode(TRANSPARENT);</span><br><span class="line">		dc.DrawText(m_strTitle, rc, DT_VCENTER | DT_CENTER | DT_SINGLELINE);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时还不能move/resize窗口.</p>
<h2 id="重写OnNcHitTest"><a href="#重写OnNcHitTest" class="headerlink" title="重写OnNcHitTest"></a>重写OnNcHitTest</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">CDlgFrm::OnNcHitTest</span><span class="params">(CPoint <span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">	UINT nHitTest = CDialogEx::OnNcHitTest(<span class="built_in">point</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="function">CPoint <span class="title">pt</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	ClientToScreen(&amp;pt);</span><br><span class="line">	<span class="keyword">if</span> (nHitTest == HTCLIENT &amp;&amp; <span class="built_in">point</span>.y - pt.y &lt; <span class="number">32</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		nHitTest = HTCAPTION;</span><br><span class="line">	&#125;</span><br><span class="line">	RECT rcWindow;</span><br><span class="line">	::GetWindowRect(m_hWnd, &amp;rcWindow);</span><br><span class="line">	<span class="comment">// 最好将四个角的判断放在前面  </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">point</span>.x &lt;= rcWindow.left + RESIZE_REGION_SIZE &amp;&amp; <span class="built_in">point</span>.y &lt;= rcWindow.top + RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTTOPLEFT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.x &gt;= rcWindow.right - RESIZE_REGION_SIZE &amp;&amp; <span class="built_in">point</span>.y &lt;= rcWindow.top + RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTTOPRIGHT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.x &lt;= rcWindow.left + RESIZE_REGION_SIZE &amp;&amp; <span class="built_in">point</span>.y &gt;= rcWindow.bottom - RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTBOTTOMLEFT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.x &gt;= rcWindow.right - RESIZE_REGION_SIZE &amp;&amp; <span class="built_in">point</span>.y &gt;= rcWindow.bottom - RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTBOTTOMRIGHT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.x &lt;= rcWindow.left + RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTLEFT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.x &gt;= rcWindow.right - RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTRIGHT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.y &lt;= rcWindow.top + RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTTOP;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">point</span>.y &gt;= rcWindow.bottom - RESIZE_REGION_SIZE)</span><br><span class="line">		<span class="keyword">return</span> HTBOTTOM;</span><br><span class="line">	<span class="keyword">return</span> nHitTest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里本人发现一个有趣的问题，当窗口为子窗口的时候，至此，是可以实现move和resize了。但是如果你modify成popup了，只能移动，不能resize。实质是popup会丢失消息，于是手动加上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgFrm::OnNcLButtonDown</span><span class="params">(UINT nHitTest, CPoint <span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"> </span><br><span class="line">	CDialogEx::OnNcLButtonDown(nHitTest, <span class="built_in">point</span>);</span><br><span class="line">	<span class="keyword">if</span> (nHitTest == HTTOP)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_TOP, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTBOTTOM)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_BOTTOM, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTLEFT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_LEFT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTRIGHT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_RIGHT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTTOPLEFT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_TOPLEFT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTTOPRIGHT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_TOPRIGHT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTBOTTOMLEFT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_BOTTOMLEFT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nHitTest == HTBOTTOMRIGHT)</span><br><span class="line">		SendMessage(WM_SYSCOMMAND, SC_SIZE | WMSZ_BOTTOMRIGHT, MAKELPARAM(<span class="built_in">point</span>.x, <span class="built_in">point</span>.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是popup窗口resize也ok了。</p>
<h2 id="窗口resize阴影严重需要update"><a href="#窗口resize阴影严重需要update" class="headerlink" title="窗口resize阴影严重需要update"></a>窗口resize阴影严重需要update</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgFrm::OnSize</span><span class="params">(UINT nType, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CDialogEx::OnSize(nType, cx, cy);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此处添加消息处理程序代码</span></span><br><span class="line">	<span class="keyword">if</span> (m_pDlg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//::SendMessage(m_pDlg-&gt;m_hWnd, WM_SIZE, nType, MAKELPARAM(cx, cy));</span></span><br><span class="line">		m_pDlg-&gt;SetWindowPos(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, cx - <span class="number">4</span>, cy - <span class="number">32</span> - <span class="number">2</span>, SWP_NOMOVE);</span><br><span class="line">		m_pDlg-&gt;Invalidate();</span><br><span class="line">	&#125;</span><br><span class="line">	Invalidate();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实至此，窗口绘制是完了，但是如果窗口中有子窗口或者控件，你会发现，当缩小到控件交叉时，会有边框被控件覆盖的效果如下图：<br><img src="20171124102142774.png" alt=""></p>
<p>解决上图有两种方法：</p>
<ol>
<li><p><strong>使用自己管理的透明对话框（边框不透明）去覆盖在窗口上，然后让该对话框跟着Active窗口移动，resize以及窗口非Active时隐藏。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRect rc;</span><br><span class="line">GetWindowRect(rc);</span><br><span class="line"><span class="keyword">if</span> (m_dlgBorder.Create(CDlgBorder::IDD, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">	m_dlgBorder.m_hWndOwner = m_hWnd;</span><br><span class="line">	m_dlgBorder.SetWindowPos(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>, rc.Width(), rc.Height(), SWP_NOZORDER);</span><br><span class="line">	m_dlgBorder.ModifyStyleEx(<span class="literal">NULL</span>, WS_EX_LAYERED | WS_EX_NOACTIVATE | WS_EX_TRANSPARENT;</span><br><span class="line">	SetWindowLong(m_dlgBorder.m_hWnd, GWL_EXSTYLE, </span><br><span class="line">		GetWindowLongPtr(m_dlgBorder.m_hWnd, GWL_EXSTYLE) | WS_EX_LAYERED);</span><br><span class="line">	m_dlgBorder.SetLayeredWindowAttributes(RGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), (<span class="number">255</span> * <span class="number">0</span>) / <span class="number">100</span>, LWA_COLORKEY<span class="comment">/*LWA_ALPHA*/</span>);</span><br><span class="line">	m_dlgBorder.ShowWindow(SW_SHOW);</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意该窗口要透明一定是popup属性，扩展属性必须有<code>LAYERED|NOACTIVATE|TRANSPARENT</code>,最后<br><code>SetLayeredWindowAttributes(...)</code><br>设置成透明。至于透明窗口中的代码就是绘制边框/重绘刷新了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgBorder::OnPaint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">// device context for painting</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此处添加消息处理程序代码</span></span><br><span class="line">	<span class="comment">// 不为绘图消息调用 CDialogEx::OnPaint()</span></span><br><span class="line">	<span class="keyword">if</span> (IsWindow(m_hWndOwner))</span><br><span class="line">	&#123;</span><br><span class="line">		HWND m_hOwnerParent = ::GetParent(m_hWndOwner);</span><br><span class="line">		HPEN newPen = CreatePen(PS_SOLID, <span class="number">2</span>, RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">		HPEN oPen = (HPEN)dc.SelectObject(newPen);</span><br><span class="line">		CRect rc,rc2;</span><br><span class="line">		GetClientRect(rc);</span><br><span class="line">		rc.left = rc.top = <span class="number">2</span>;</span><br><span class="line">		::GetClientRect(m_hOwnerParent, rc2);</span><br><span class="line">		ClientToScreen(rc2);</span><br><span class="line">		<span class="comment">//if (rc.TopLeft)</span></span><br><span class="line">		<span class="comment">//dc.MoveTo()</span></span><br><span class="line">		dc.Rectangle(rc);</span><br><span class="line">		dc.SelectObject(oPen);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDlgBorder::DoPaintBorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRect rc;</span><br><span class="line">	<span class="keyword">if</span> (IsWindow(m_hWndOwner))</span><br><span class="line">	&#123;</span><br><span class="line">		::GetWindowRect(m_hWndOwner, rc);</span><br><span class="line">		SetWindowPos(<span class="number">0</span>, rc.left, rc.top, rc.Width(), rc.Height(), SWP_NOZORDER);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次resize，move后调用DoPaintBorder更新窗口位置大小即可。<br><img src="20171124104913486.png" alt=""><br>但是当窗口移动到边框的时候因为popup属性还会显示出来，所以，还要将该窗口修复一下，方式两种，</p>
</li>
<li><p>自己计算边框控制绘图越界。</p>
</li>
<li><p>将透明窗口设置成该窗口的父窗口的子窗口（也是该窗口的兄弟窗口）即可。</p>
</li>
<li><p><strong>使用父窗口重绘边框，再在其客户区放置不可移动的子窗口，再在子窗口上放控件。相当于多嵌套一层子窗口。然后让子窗口跟着一起resize。</strong></p>
</li>
</ol>
<p>如文章开始提到的封装一个CDlgFrm当容器,但要注意的是OnSize中一定要将其子窗口一起resize。代码上面已经提供，否则还是会出现边框被子窗口遮挡的现象。最后上个效果图<br><img src="20171124105922934.jpg" alt=""><br>标题栏再加上关闭按钮：<br><img src="20171124172111062.jpg" alt=""><br><img src="20171124172117227.jpg" alt=""></p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>mfc</tag>
        <tag>窗口重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>子窗口与弹出窗口不可忽视的标题栏属性</title>
    <url>/2017/11/21/%E5%AD%90%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%BC%B9%E5%87%BA%E7%AA%97%E5%8F%A3%E4%B8%8D%E5%8F%AF%E5%BF%BD%E8%A7%86%E7%9A%84%E6%A0%87%E9%A2%98%E6%A0%8F%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>之前写过一篇日志说child窗口edit不能输入。虽然解决了，但并不完美，后面发现能输入了，但是鼠标不能选择文字，键盘却可以。</p>
<a id="more"></a>再加上以前遇到的一些问题，比如窗口透明，背景色，甚至子窗口的Z序也让人蒙圈（后创建的在后面去了）等都不顺利，换句话说是相对popup窗口而言。总之微软对于子窗口的实现就像个半成品。

<p>关于edit不能选择文字，还发现一个问题可以解决，就是去掉子窗口的标题栏，如果实在需要拖动窗口，可以自会标题栏。但前几天研究富图发现一个有趣的事情<br><img src="20171121182014112.png" alt=""><br><img src="20171121182021701.png" alt=""><br><img src="20171121182027595.png" alt=""><br>我就直接解析这个spy++看到的现象吧，窗口002413f4显然是一个子窗口，但窗口属性确是一个popup属性。但是基于微软的解析Child与popup是不能共用的，也是不建议共用的，那叫undocumented window.傻眼，不信,自己Create一个popup和图中效果不一样,用child也不对，那就popup|child这个更不对。最后那就避开Create函数，在create成功后修改成popup呗，于是<code>ModifyStyle(WS_CHILD, WS_POPUP)</code>;，得到了如下效果图：<br><img src="20171121182034323.png" alt=""></p>
<p>呵呵，差不多了，就是这个。也是我想要的结果。入坑很久才解决的问题，标记一下。至于修改成popup后，父窗口句柄或者owener句柄都是会变的。自己保存自己管理就好了,<strong>也由此可见Create传入的Style与ModifyStyle并不是相等的效果</strong>。</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>mfc</tag>
        <tag>子窗口</tag>
        <tag>弹出窗口</tag>
        <tag>标题属性</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC状态栏设置图标自动变高</title>
    <url>/2017/09/06/MFC%E7%8A%B6%E6%80%81%E6%A0%8F%E8%AE%BE%E7%BD%AE%E5%9B%BE%E6%A0%87%E8%87%AA%E5%8A%A8%E5%8F%98%E9%AB%98/</url>
    <content><![CDATA[<p>状态栏被自动变高，清除字体，ico等可恢复到原始状态。给mdi状态栏添加图标，以显示实时网络连接状态。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPaneIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> nIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">   HICON hIcon,</span></span></span><br><span class="line"><span class="function"><span class="params">   BOOL bUpdate=TRUE </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是MFC提供的设置图标的函数，ico文件支持透明所以就用了，但使用后发现无论你ico 是啥分辨率，都会被设置成32x32图片，而且透明支持的也不是很好，还有黑边。最重要的是状态栏被撑高了，原来就二十几的像素现在有38像素左右了，很难看。先不说CStatusBar没有设置高度的接口，还要重载才能实现高度重绘，即使设置高度成功了，图片还是32x32的哪怕你用16x16的也会被放大，然后显示一半。暂且就当是微软留下的一个bug吧。</p>
<p>解决办法：用这个函数的重载函数即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPaneIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> nIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">   HBITMAP hBmp,</span></span></span><br><span class="line"><span class="function"><span class="params">   COLORREF clrTransparent=RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">   BOOL bUpdate=TRUE </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数是使用bmp格式图片的，透明色默认是这个粉色（可能是因为这个颜色难看吧），当然可以自己更改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_wndStatusBar.SetPaneIcon(nIndex</span><br><span class="line">    , LoadBitmap(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDB_XXX)));</span><br></pre></td></tr></table></figure>
<p>搞定。</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>mfc</tag>
        <tag>状态栏高度</tag>
      </tags>
  </entry>
  <entry>
    <title>写MFC程序还是先注释写注册表或者先清理注册表吧！</title>
    <url>/2017/08/04/%E5%86%99MFC%E7%A8%8B%E5%BA%8F%E8%BF%98%E6%98%AF%E5%85%88%E6%B3%A8%E9%87%8A%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%88%96%E8%80%85%E5%85%88%E6%B8%85%E7%90%86%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%90%A7%EF%BC%81/</url>
    <content><![CDATA[<p>血的教训，浪费了大把时间调试找问题，然而却不知道MFC自动写注册带来的巨坑有多坑。</p>
<a id="more"></a>
<p>一次次让你怀疑人生，<br>微软这个设计老子真心想拍死你。</p>
<ol>
<li>自动写注册表，这里说自动是创建工程自带SetRegistryKey将巨坑埋下伏笔</li>
<li>注册信息不是空，讲道理应该为空，但老vc都知道软件保留用户操作习惯是默认的。</li>
<li>注册信息奇多，含菜单/工具栏/状态栏/停靠窗口，，，似乎除了main  client区域。（需要补充，不确定）<br>这些东西，如果你没注释，开发过程中受的苦就是：皮肤设置成功，显示还是原来的，菜单修改成功显示还是原来的，原因就是注册表里保存的是你的<strong>资源信息</strong>。各种接口调用成功了，显示出来的却不是你想要的是不是怀疑人生？<br>开发后，如果不注意，在你的电脑显示好好的，在人家的电脑上就是不一样，原因还是注册表。</li>
</ol>
<p>此次就是为了做多语言支持，修改菜单<code>ModifyMenu(hSubMenu,i, MF_STRING| MF_BYPOSITION,ID_FILE_SAVE,&quot;Save&quot;)</code>;总是不成功，实际调用是正确的，清除注册表就ok了。</p>
<p>好了，暂不吐槽了，处理问题才是关键：</p>
<ol>
<li>InitInstance（）中注释SetRegistryKey（）</li>
<li>ExitInstance（）中CleanState（）</li>
</ol>
<p>今天还遇到还有可能碰到以上两种方法不管用，第一种程序跑不起来，第二种清理不干净。原因：第一种会导致取资源失败自然创建MainFrame失败，第二种就真是清理不干净了，所以手动delRegist（自己写清理注册表函数，或者手动删除注册表）才行。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><span style=color:red>注意：</span></h2><p>在修改MDI的Mainfrm/ChildFrm菜单时，获取这两个菜单句柄然后修改<br><code>pDocTemplate-&gt;m_hMenuShared;//ChildFrm Menu</code><br><code>pMainFrame-&gt;m_hMenuDefault;//主框架Menu</code><br>如果是在MainFrm中获取MainMenu还有<code>m_wndMenuBar.GetHMenu()</code>和<code>GetMenu()</code><br>至于修改就是<code>ModifyMenu</code>了。<br>今天发现在InitInstance中可以初始化ChrildFrmMenu的修改，但不能对MainFrmMenu修改。<br>在MainFrm中OnCreat()中初始化MainFrmMenu的修改又能成功，于是我对比<code>pMainFrame-&gt;m_hMenuDefault ？= m_wndMenuBar.GetHMenu()</code>。是相等的，也就是说Menu是同一个，都正确取到了，但是更改只能在Mainfrm中完成！！！</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>mfc</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title>mfc非模态对话框Child窗口CEdit控件获取不到焦点问题</title>
    <url>/2017/07/25/mfc%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86Child%E7%AA%97%E5%8F%A3CEdit%E6%8E%A7%E4%BB%B6%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%84%A6%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>遇到的问题就是创建一个非模态的子窗口。发现子窗口上的edit控件总是不能被激活.</p>
<a id="more"></a>
<p><img src="20170725155838473.png" alt=""><br>开始担心自己工程出问题了，于是新建了一个sdi，如图问题依然存在，既然如此那就在新工程中找问题，先设置对话框style，popup/overlap都能正常使用，再试试模式对话框（有点没必要，因为模式对话框不能是child）依然没问题，为了保守起见，还是多托几个控件靠谱，发现只有edit无效，尴尬。那就只能对edit下手了，于是spy++追踪，发现控件是能响应鼠标的LBUTTONDOWN消息的。<br><img src="20170725155854049.png" alt=""><br>仔细看图，其实edit边框黑色是有加深的。再一次确认了并不是edit没被激活而是丢失了某些消息。对于edit，当然是鼠标单击的时候就该获取焦点，显示光标。</p>
<p>思路：拦截消息/设置控件焦点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CDlgChild::PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="keyword">if</span> ( pMsg-&gt;message == WM_LBUTTONDOWN)<span class="comment">//这里让每个控件都响应，如果是针对某个控件，可以使用pMsg-&gt;hwnd与控件句柄比较删选。</span></span><br><span class="line">    &#123;</span><br><span class="line">        ::SetFocus(pMsg-&gt;hwnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CDialogEx::PreTranslateMessage(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F5，正常了。<del>~ 最后吐槽一句，总觉得这是微软留的一个坑，说大也不大。虽然这中情况用的不多。但毕竟还是遇到了。</del></p>
<p><strong>今天是来修改本文最后一句的，不删除原文主要也是想起到提醒左右。其实这个是窗口的标题属性（WS_TITLE）所致。当我们把子窗口的标题栏置false就不会有这个问题了。而且上述解决方式还存在一个问题就是CEdit/CCombox等需要输入的控件鼠标不能定位已输入文本，只能键盘定位，很不便。当我们业务需要标题栏咋办呢？不妨重绘对话框客户区，自己绘标题栏，顺便代码也上来吧。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">CDlgNoTitle::OnNcHitTest</span><span class="params">(CPoint <span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    UINT nHitTest = CDialogEx::OnNcHitTest(<span class="built_in">point</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function">CPoint <span class="title">pt</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    ClientToScreen(&amp;pt);</span><br><span class="line">    <span class="keyword">if</span> (nHitTest == HTCLIENT &amp;&amp; <span class="built_in">point</span>.y - pt.y &lt; <span class="number">32</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nHitTest = HTCAPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nHitTest;</span><br><span class="line">    <span class="comment">//return CDialogEx::OnNcHitTest(point);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>mfc</tag>
        <tag>child</tag>
        <tag>focus</tag>
      </tags>
  </entry>
  <entry>
    <title>由Create一个Child窗口，导出的z序问题</title>
    <url>/2017/07/17/%E7%94%B1Create%E4%B8%80%E4%B8%AAChild%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%AF%BC%E5%87%BA%E7%9A%84z%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>首先遇到的情况，直接看图<br><img src="20170717165411414.png" alt=""></p>
<a id="more"></a>
<p>看到这现象有点怀疑人生，Windows默认Create顺序是按照Z序依次递增的，然而为何会出现如此现象？</p>
<p>首先和窗口类型确实有关：用的是Child，如果使用popup/overlapped都正常，我们通常非模态对话框用overlapped最多，这次要做子窗口管理，才发现有如此问题。考虑在窗口类型上选择：层叠/弹出/子窗口。选择Child类型是必须的（根据需求）。于是想办法改变窗口Z序，windowsZ序说明并不多，看来也是不复杂的原因，搜索相关函数</p>
<p>BOOL SetWindowPos(  const CWnd* pWndInsertAfter,  int x,  int y,  int cx,  int cy,  UINT nFlags  );<br>pWndInsertAfter<br>Identifies the CWnd object that will precede (be higher than) this CWnd object in the Z-order. This parameter can be a pointer to a CWnd or a Pointer to one of the following values:</p>
<p>wndBottom   Places the window at the bottom of the Z-order. If this CWnd is a topmost window, the window loses its topmost status; the system places the window at the bottom of all other windows.</p>
<p>wndTop   Places the window at the top of the Z-order.</p>
<p>wndTopMost   Places the window above all non-topmost windows. <em>重点The window maintains its topmost position even when it is deactivated</em>.</p>
<p>wndNoTopMost   Repositions the window to the top of all non-topmost windows (that is, behind all topmost windows). <em>重点This flag has no effect if the window is already a non-topmost window</em>.</p>
<p>换句话说，就此4中Z序：底部/顶部/最顶/非最顶，这都是相对你要插入的窗口指针的</p>
<blockquote>
<p>看微软注释：<br> static AFX_DATA const CWnd wndTop; // SetWindowPos’s pWndInsertAfter<br> static AFX_DATA const CWnd wndBottom; // SetWindowPos’s pWndInsertAfter<br> static AFX_DATA const CWnd wndTopMost; // SetWindowPos pWndInsertAfter<br> static AFX_DATA const CWnd wndNoTopMost; // SetWindowPos pWndInsertAfter</p>
</blockquote>
<p><img src="20170717181216290.jpg" alt=""></p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>vc</tag>
        <tag>WindowsZ序</tag>
        <tag>子窗口管理</tag>
      </tags>
  </entry>
  <entry>
    <title>由花屏引出的WS_CLIPCHILDREN，WS_CLIPSIBLINGS理解</title>
    <url>/2017/07/16/%E7%94%B1%E8%8A%B1%E5%B1%8F%E5%BC%95%E5%87%BA%E7%9A%84WS-CLIPCHILDREN%EF%BC%8CWS-CLIPSIBLINGS%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>WS_CLIPCHILDREN，使得父窗体在绘制时留出其上的子窗体的位置不去画它，而那片区域留着子窗体去画。<a id="more"></a><br>WS_CLIPSIBLINGS，必须用于子窗体(Child)，使得该子窗体在收到WM_PAINT时同时令其兄弟窗体（MSDN讲必须不在该区域，即不与之重叠）也会被PAINT。</p>
<p>所有的overlapped窗口和popup窗口，都有WS_CLIPSIBLINGS 属性，这些窗口<strong>不能</strong>在它的兄弟窗口上绘图</p>
<p>对于child窗口，如果没有这个属性，它能在它的兄弟窗口上绘图<br><img src="20170716162535135.jpg" alt=""><br>图例说明：<br>如果A, B都是child窗口，<br>如果A具有WS_CLIPSIBLINGS属性，<br>那么A重绘时不会重绘C部分</p>
<p>clip是裁减，去除的意思<br>WS_CLIPCHILDREN和WS_CLIPSIBLING都是为了减少重画，减少闪动，保证窗口的重叠部分只有一个窗口来实现PAINT。</p>
<p>最近在做一个多非模态对话框程序，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pDlg = <span class="keyword">new</span> CDlgHKMarket();</span><br><span class="line">		pDlg-&gt;Create(IDD_DLG_HKMARKET, <span class="keyword">this</span>);</span><br><span class="line">		SetWindowLong(pDlg-&gt;m_hWnd, GWL_STYLE, WS_CAPTION|WS_CHILD <span class="comment">/*|WS_CLIPSIBLINGS*/</span>);</span><br><span class="line">		SetWindowPos(pDlg, x, y, <span class="number">300</span>, <span class="number">200</span>, SWP_SHOWWINDOW|SWP_NOACTIVATE);</span><br><span class="line">		x += <span class="number">10</span>;</span><br><span class="line">		y += <span class="number">30</span>;</span><br><span class="line">		pDlg-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果：<br><img src="20170716162654405.jpg" alt=""><br>花屏明显，原因就在于画到兄弟窗口去了，我不需要，于是对CDlgMarket加属性WS_CLIPSIBLINGS让兄弟窗口间互不影响,再run，ok.<br><img src="20170716162700866.jpg" alt=""></p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>vc</tag>
        <tag>花屏</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>ScreenToClient与ClientToScreen</title>
    <url>/2017/07/14/ScreenToClient%E4%B8%8EClientToScreen/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>The ClientToScreen function replaces the <code>client-area coordinates</code> in the POINT structure with the <code>screen coordinates</code>. The screen coordinates are relative to the upper-left corner of the screen.<a id="more"></a>Note, a screen-coordinate point that is above the window’s client area has a negative y-coordinate. Similarly, a screen coordinate to the left of a client area has a negative x-coordinate.<br>The <code>ScreenToClient</code> member function replaces the screen coordinates given in <em>lpPoint</em> or <em>lpRect</em> with client coordinates. The new coordinates are relative to the upper-left corner of the CWnd <strong>client area</strong>.</p>
<p>实际就是一个屏幕坐标，一个客户区坐标，这两个坐标系统的转换</p>
<p><code>GetWindowRect</code>得到的是screen coordinates.  <code>GetClientRect</code>得到的是client-area coordinates，所以GetClientRect得到的总是以（0，0）为左上的点。</p>
<p>The dimensions are given in screen coordinates relative to the upper-left corner of the <code>display screen</code>. The dimensions of the caption, border, and scroll bars, if present, are included.</p>
<p>如果我们要获取一个窗口pWnd相对于父窗口parent客户区的位置应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rect rc;</span><br><span class="line"></span><br><span class="line">pWnd-&gt;GetWindowRect(&amp;rc);</span><br><span class="line"></span><br><span class="line">parent-&gt;ScreenToClient(&amp;rc);</span><br></pre></td></tr></table></figure>
<p>如果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pWnd-&gt;GetWindowRect(&amp;rc);</span><br><span class="line"></span><br><span class="line">pWnd-&gt;ScreenToClient(&amp;rc);</span><br></pre></td></tr></table></figure>
<p>得到的rc左顶坐标会出项负数，因为将自己的窗口往客户区映射，会出现标题栏/边框等的位置差错。</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>vc</tag>
        <tag>ScreenToClient</tag>
        <tag>ClientToScreen</tag>
        <tag>windows坐标系统</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Windows. linux跨平台的一些建议</title>
    <url>/2016/10/11/%E5%85%B3%E4%BA%8EWindows%E3%80%81linux%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>在你做跨平台开发时，难免会遇到一些因操作系统特性带来的麻烦。本文集聚部分，并以Windows，linux为目标平台分析。由于java，Python等语言基本锁定自家编译器. IDE，也就没有C/C++这样的麻烦了，本文还是以C/C++为主。<a id="more"></a></p>
<ol>
<li>关于路径和头文件路径分隔符的问题</li>
</ol>
<p>在Windows中，正斜杠和反斜杠都可以，但是在Linux中，只能是/。</p>
<p>在Windows中，路径大小写无所谓，在Linux中严格区分大小写。</p>
<ol start="2">
<li>关于宽字符的问题。</li>
</ol>
<p>在Windows中，wchar_t占两个字节，Linux中占四个字节，所以尽量用C/C++自带的字符类型或者第三方跨平台库类型如：qchar。</p>
<ol start="3">
<li>与平台相关的调用</li>
</ol>
<p>尽量用宏隔离开来，一般用不同的目录代表不同平台，BOOST. OGRE等是这样做。也可以再一个类或者文件中，这样会导致到处都是操作系统和编译器相关宏的定义。</p>
<ol start="4">
<li>关于头文件包含</li>
</ol>
<p>在Windows下某些C标准库的头文件不用显式包含，但是在linux下需要显式包含。所以在.c和.cpp文件中尽量包含这个文件中需要的头文件。</p>
<ol start="5">
<li>注意机器大尾端和小尾端的区别</li>
</ol>
<p>大小尾端对文件的读写会有很大影响，要编写跨平台c++程序，大小尾端是必须要考虑的问题。比如，你在大尾端机器上写了一个文件，然后在小尾端机器上读取，那么结果肯定是错误的，所以，我们设计文件格式时，都需要规定文件是大尾端存储还是小尾端存储，或者一个文件中规定某些部分是大尾端某些部分是小尾端。</p>
<ol start="6">
<li>使用<code>std::exception</code>时需要注意</li>
</ol>
<p>LINUX下是不支持抛出异常的，如果继承自标准库的异常类写自己的异常类的时候，在Linux下，子类的析构函数中就需要表明不抛出异常，所以析构函数后面加上<code>throw()</code>就可以了。</p>
<ol start="7">
<li>当继承模板类时需要谨慎</li>
</ol>
<p>在自己的代码中，需要继承模板类时，如果需要访问基类模板类的成员函数或者成员变量，前面加上<code>this-&gt;</code>。另外，构造函数需要用到基类进行构造时。基类的类型需要需要用该类的类型参数初始化，否则在linux下会提示找不到基类的这个名字。</p>
<ol start="8">
<li><p>尽量使用标准C和C++的函数以及STL，使用C语言中定义的类型。</p>
</li>
<li><p>头文件重复包含的问题</p>
</li>
</ol>
<p>尽量用保卫宏去实现防止头文件的重复包含，很多代码在Windows下直接用#pragma once，这不能保证跨平台需要。</p>
<ol start="10">
<li>关于结构体对齐的问题。</li>
</ol>
<p>CPU为了简化内存和CPU之间的处理以及加快CPU从内存中取数据的速度，往往都会做一定的对齐，即结构体的各个成员并不是紧凑存储的，往往在成员中间填充一些字节。所以，我们一般不推荐用结构体直接读取和写入数据，这样在不同系统或者计算机之间进行移植时，会出现错误的结果。</p>
<ol start="11">
<li>注意BOM的陷阱（字节顺序标记）</li>
</ol>
<p>如果你在Windows用记事本创建一个源文件，那么Windows会在文件最前面加上一个BOM标记，即所谓的字节顺序标记，这样的源码在Windows下没问题，但是在Linux下就编译不过，所以需要用其他的文本编辑器或者直接在VS里面创建源文件。Linux下gcc/g++不认带BOM标记的源文件。</p>
<ol start="12">
<li>结束符问题</li>
</ol>
<p>Linux/UNIX:    ‘\n’  (LF)</p>
<p>Mac  :    ‘\r’   (CR)</p>
<p>DOS(Windows):     ‘\r\n’  (CR-LF)</p>
<p>所以从linux拷贝文件到windows，用记事本打开.h/.cpp时，是没有换行效果的。</p>
<ol start="13">
<li>注意调用函数时的形参类型和函数声明中参数列表的类型不匹配</li>
</ol>
<p>这里特指有无const或者是否是引用参数。在Windows下的cl编译器没问题，linux下GCC/G++会报错。</p>
<ol start="14">
<li>注意两个尖括号不要连着写</li>
</ol>
<p>例如<code>std::vector&lt;std::vector&lt;int&gt;&gt; vec</code>;在Windows下这么写完全没问题，那么在linux下就是编译不过，所以linux下可以在连续两个尖括号符号之间留一个空格，即<code>std::vector&lt;std::vector&lt;int&gt;  &gt; vec</code>;</p>
<ol start="15">
<li>关于库引用</li>
</ol>
<p>windows引用动态库默认从当前目录取，Linux必须将动态库添加到库目录（注册系统环境变量）。</p>
<ol start="16">
<li>尽量不要使用内嵌汇编</li>
</ol>
<p>不同平台，应该说编译器，gcc与cl对汇编的语法要求是不一样的。</p>
<ol start="17">
<li>谨慎使用浮点数</li>
</ol>
<p>不同硬件. 编译器和编写代码的方式都可以影响结果的精确性。</p>
]]></content>
      <categories>
        <category>防坑笔记</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>QT多语言翻译工作</title>
    <url>/2016/08/10/QT%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>QT多语言翻译工作解决方式多样，但考虑多语言支持。</p>
<a id="more"></a>
<p>建议做法如下：</p>
<ol>
<li><p>在工程文件(.pro)里加入TRANSLATIONS标签，例如：TRANSLATIONS += myproject_zh.ts</p>
</li>
<li><p>在命令行下调用: lupdate myproject.pro，生成.ts文件（lupdate命令如果提示不存在，说明该lupdate.exe文件路径没配到系统的环境变量path，该目录是qt安装的bin）</p>
</li>
<li><p>启动Qt Linguist进行翻译。</p>
</li>
<li><p>在命令行下调用：lrelease myproject.pro，生成.qm文件（多语言可发布多个qm文件）</p>
</li>
<li><p>在需要切换语言的地方写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTranslator *translator = <span class="keyword">new</span> QTranslator(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>( translator-&gt;load(<span class="string">"myproject_zh.qm"</span>))</span><br><span class="line">    qApp-&gt;installTranslator(translator);</span><br></pre></td></tr></table></figure>
<p>如果要实时切换，可以关闭并重新创建窗体，或者干脆重新启动进程。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>多语言</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title>QT中文乱码关键几点强调</title>
    <url>/2016/08/10/QT%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%85%B3%E9%94%AE%E5%87%A0%E7%82%B9%E5%BC%BA%E8%B0%83/</url>
    <content><![CDATA[<p>QT,相信使用的人很多用在跨平台上，然而要保证Windows、Linux同用一份源码，就不得不考虑源代码编码问题了，在编码发展上，我打赌未来肯定是要舍弃Ansi转向Unicode编码的，Unicode又有多种编码方式GBK(GB2312的升级版)，BIG5，utf8，utf16等。</p>
<a id="more"></a>
<p>Win下默认GBK,Linux（ubuntu）默认utf8，然而QT呢？QTCreator文本编辑器默认也是utf8文件格式,BOM目前存在则保留。所以通常设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextCodec *codec = TextCodec::codecForName(<span class="string">"utf8"</span>);</span><br><span class="line">QTextCodec::setCodecForTr(codec);</span><br><span class="line">QTextCodec::setCodecForCStrings(codec);</span><br><span class="line">QTextCodec::setCodecForLocale(codec);</span><br></pre></td></tr></table></figure>
<p>就能解决大部分问题，通常很多人犯的错误，包括我接触过的别人写的项目都是各种文件格式Ansi、utf8、gbk糅合在一个项目中（估计都是直接从网上download的代码，自己没整理就直接使用文件）。导致这里没乱码，那里有乱码，这种现象。<br>在某些情况下也是有问题的，因为程序可能读到系统的中文路径，或者调用中文路径下的外部程序，这时候如果系统是gb2312就有问题了。因为中文路径的编码是采用utf-8存到QString里的，系统读中文路径解码的时候采用的却是系统的gb2312，所以会调不起带中文路径的外部程序。</p>
<p>以上问题下面方法可以解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextCodec *codec =QTextCodec::codecForName(<span class="string">"UTF-8"</span>);</span><br><span class="line">QTextCodec::setCodecForTr(codec);</span><br><span class="line">QTextCodec::setCodecForLocale(QTextCodec::codecForLocale());</span><br><span class="line">QTextCodec::setCodecForCStrings(QTextCodec::codecForLocale());</span><br></pre></td></tr></table></figure>
<p>对于外部字符串编码解码全部采用本地编码。</p>
<p>还有一种乱码叫编码乱码，比如说，源代码utf8编码，<br><code>QTextCodec *codec =QTextCodec::codecForName(&quot;GBK&quot;);</code><br>就会导致乱码，反之亦然，故源代码与程序中使用必须统一，其实这一点是所有编译器都应该遵循的原则。因此，</p>
<p>Windows环境下,Qt Creator+VS编译器</p>
<p>1、如果该工程不需要跨平台使用(只在win),那么工程设置请使用GBK的编码方式.</p>
<p>2、如果该工程要跨平台使用(win+linux),那么工程设置请使用UTF-8+BOM的编码方式.</p>
<p>Linux环境下,Qt Creator+gcc,</p>
<p>默认是UTF-8(无BOM)编码方式,</p>
<p>综上：<strong>不考虑跨平台的话可以用默认设置，考虑到跨平台,建议选择UTF-8+BOM的编码方式.</strong>具体设置如下图<br><img src="20160902135607560.png" alt=""></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell的使用</title>
    <url>/2016/08/04/Powershell%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>由于最近项目需要使用windows脚本编程，发现普通批处理又不太好使，习惯了linux的命令行ls，cp等，总觉得windows的命令行太难玩，可编程性还不如linux的shell（本来linux shell 可编程性就不是很好）。于是上网查找资料发现powershell这个东西。研究了一天也算是达到了项目的要求，power本来就是一个很不低调的词，微软敢这么取名，肯定不是几天能完全掌握的，功能强大就不多说了。记录一下以供入门的人学习。</p>
<a id="more"></a>
<p><code>Windows PowerShell</code> 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 <code>.NET Framework</code>的强大功能。它引入了许多非常有用的新概念，<br>从而进一步扩展了您在 Windows 命令提示符和 Windows Script Host 环境中获得的知识和创建的脚本。通过解决长期存在的问题并添加一些新的功能，<br>Windows PowerShell 旨在改进命令行和脚本环境。PowerShell以.NET Framework为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。<br>在Windows 操作系统里，点击开始-&gt;运行-&gt;输入PowerShell，进入windows PowerShell。在Windows 7中内置了PowerShell2.0, Windows 8中内置了PowerShell3.0。<br>如果本机没有添加，可在网上下载安装包进行安装，或者下载WebPI，通过WebPI安装PowerShell。</p>
<ol>
<li><a href="http://www.pstips.net/powershell-online-tutorials/" target="_blank" rel="noopener">在线教程</a>中文的还带例子，本人也是看这个学的，powershell社区也有了，总之很nice的一个网站。</li>
<li>个人写的一个小<a href="http://download.csdn.net/detail/evil_119/9595255" target="_blank" rel="noopener">demo</a>源码提供并附了注释，可自由下载。</li>
<li>C程序中调用脚本<br>powershell脚本文件以<code>*.sh1</code>命名，有点奇怪，后缀而已没关系。执行命令是：<code>system(&quot;powershell yourshell.ps1&quot;)</code>;<br>普通批处理执行命令是：<code>system(&quot;yourshell.bat&quot;)</code>;</li>
<li>微软提供了一个很好的编辑器——<code>powershell_ise.exe</code><br>新建文本文件后，修改后缀为sh1，右击-》编辑即可打开。否则命令行输入<code>powershell_ise.exe</code>打开，如下图:<br><img src="20160804190244607.png" alt="powershell" title="powershell"></li>
</ol>
<p>这两天安装了个windows版本的github客户端，右击打开<code>git bash here</code>，发现一个有趣的现象，请看图不解释：<br><img src="20160810142045880.png" alt="gitbash" title="git bash"></p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>powershell</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>跨进程通信之WM_COPYDATA</title>
    <url>/2016/04/22/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8BWM_COPYDATA/</url>
    <content><![CDATA[<h2 id="MSDN提供："><a href="#MSDN提供：" class="headerlink" title="MSDN提供："></a>MSDN提供：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_COPYDATA                     0x004A</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>数据结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagCOPYDATASTRUCT</span> &#123;</span></span><br><span class="line">  ULONG_PTR dwData;</span><br><span class="line">  DWORD     cbData;</span><br><span class="line">  PVOID     lpData;</span><br><span class="line">&#125; COPYDATASTRUCT, *PCOPYDATASTRUCT;</span><br></pre></td></tr></table></figure>
<p><strong>dwData</strong><br>Type:** ULONG_PTR**</p>
<p>The data to be passed to the receiving application.</p>
<p><strong>cbData</strong><br>Type:** DWORD**</p>
<p>The size, <span style=color:red>in bytes（此处我用红色标示，就是重要警告）</span>, of the data pointed to by the <strong>lpData</strong> member.</p>
<p><strong>lpData</strong><br>Type:** PVOID**</p>
<p>The data to be passed to the receiving application. This member can be <strong>NULL</strong>.</p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>操作系统对该消息做了特殊处理。<br>1.只能使用<code>SendMessage</code>（不能使用<code>PostMessage</code>），阻塞，等待<code>bool OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)</code>执行后返回，故可以发送局部指针变量；<br>2.<code>::SendMessage(hWnd,WM_COPYDATA,NULL（该参数为发送端窗口句柄）,(LPARAM)&amp;dsSend(该参数为COPYDATASTRUCT*))</code>;</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><span style=color:red>注意：</span></h2><p>1.使用WCHAR<em>的时候，cbData不是WCHAR的个数，而是:`sizeof(WCHAR)</em>(wcslen(str)+1)` 解析：宽字符串的字节长度+‘\0’;<br>2.如果是发送结构体，成员变量是CString 或者LPWSTR等都是不合适的（除非自己计算sizeof），使用固定长度的char型数组，会使代码可读性，及效率上更好。<br>3.该消息与Clipborad不同，不是共享内存的，可以通过比较发送端首地址、接收端首地址发现并不一样。只是跨进程做了一个内存拷贝。所以cbData的值一定不能小于其实际sizeof的值，否则，接收端接收到的指针解析不出来。</p>
<p>而且MSDN中的事例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ************ Globals ************</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDISPLAY 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMYREC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  s1[<span class="number">80</span>];</span><br><span class="line">   <span class="keyword">char</span>  s2[<span class="number">80</span>];</span><br><span class="line">   DWORD n;</span><br><span class="line">&#125; MYREC;</span><br><span class="line">COPYDATASTRUCT MyCDS;</span><br><span class="line">MYREC MyRec;</span><br><span class="line">HRESULT hResult;</span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">InfoDlgProc</span><span class="params">( HWND, UINT, WPARAM, LPARAM )</span></span>;</span><br><span class="line"><span class="comment">// ************ Code fragment ****************</span></span><br><span class="line"><span class="comment">// Get data from user. InfoDlgProc stores the information in MyRec.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   DialogBox( ghInstance, <span class="string">"InfoDlg"</span>, hWnd, (DLGPROC) InfoDlgProc );</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copy data into structure to be passed via WM_COPYDATA.</span></span><br><span class="line"><span class="comment">// Also, we assume that truncation of the data is acceptable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   hResult = StringCbCopy( MyRec.s1, <span class="keyword">sizeof</span>(MyRec.s1), szFirstName );</span><br><span class="line">   <span class="keyword">if</span> (hResult != S_OK)</span><br><span class="line">   		<span class="keyword">return</span> False;</span><br><span class="line">   hResult = StringCbCopy( MyRec.s2, <span class="keyword">sizeof</span>(MyRec.s2), szLastName );</span><br><span class="line">   <span class="keyword">if</span> (hResult != S_OK)</span><br><span class="line">   		<span class="keyword">return</span> False;</span><br><span class="line">   MyRec.n = nAge;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Fill the COPYDATA structure</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">   MyCDS.dwData = MYPRINT;          <span class="comment">// function identifier</span></span><br><span class="line">   MyCDS.cbData = <span class="keyword">sizeof</span>( MyRec );  <span class="comment">// size of data</span></span><br><span class="line">   MyCDS.lpData = &amp;MyRec;           <span class="comment">// data structure</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Call function, passing data in &amp;MyCDS</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   hwDispatch = FindWindow( <span class="string">"Disp32Class"</span>, <span class="string">"Hidden Window"</span> );</span><br><span class="line">   <span class="keyword">if</span>( hwDispatch != <span class="literal">NULL</span> )</span><br><span class="line">      SendMessage( hwDispatch,</span><br><span class="line">                   WM_COPYDATA,</span><br><span class="line">                   (WPARAM)(HWND) hWnd,</span><br><span class="line">                   (LPARAM) (LPVOID) &amp;MyCDS );</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      MessageBox( hWnd, <span class="string">"Can't send WM_COPYDATA"</span>, <span class="string">"MyApp"</span>, MB_OK );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>WM_COPYDATA</tag>
        <tag>进程间通信</tag>
        <tag>clipborad</tag>
      </tags>
  </entry>
  <entry>
    <title>NSIS笔记</title>
    <url>/2015/12/23/NSIS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="关于-NSIS"><a href="#关于-NSIS" class="headerlink" title="关于 NSIS"></a>关于 NSIS</h2><p>在用户使用你的应用程序之前首先会体验到你的安装程序。慢慢悠悠的或不成功的软件安装是很恼人的问题。一个快速友好的安装程序是展示你的软件产品品质的一部分。<a id="more"></a></p>
<p>NSIS (Nullsoft Scriptable Install System) 是 Windows 下的一个工具，它允许程序员来创建这样的安装程序。它发布于一个开源的协议并且对于<a href="https://blog.csdn.net/evil_119/article/details/50385678" target="_blank" rel="noopener">任何使用者来说都是完全免费的</a>。</p>
<p>NSIS 创建的安装程序能够安装、卸载、设置系统设置、解压文件等等。因为它基于脚本文件，你可以完全的控制安装程序的每一部分。脚本语言支持变量、函数、字串操作，就像一个普通的程序语言一样 - 但是设计来创建安装程序。即使有那么多的特性，NSIS 仍然是最小的安装程序系统。在默认选项下，它仅增加了 34 KB 的开销。</p>
<p>总结：<br>    优点，开源 精巧含脚本向导灵活语法简单<br>    缺点，自己编码。</p>
<h2 id="NSIS脚本结构"><a href="#NSIS脚本结构" class="headerlink" title="NSIS脚本结构"></a>NSIS脚本结构</h2><p>一个NSIS脚本文件包括 安装属性（Installer Attributes）、区段（Sections）和函数（Functions），此外还可以使用编译命令来对编译过程进行控制。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>先通过“文件”-》新建脚本：向导-》完成。再修改脚本。很多命令是在区段、函数中使用的，当然编译过程也会提示。<br>编译成功会有exe生成。</p>
<p>暂未发现单步调试等任何Debug模式。</p>
<p>注意在执行命令时，文件路径最好用双引号，否则有可能因路径中含有空格等特殊符号导致命令执行失败。</p>
<p>语法规则等参考<a href="http://download.csdn.net/detail/evil_119/9373553" target="_blank" rel="noopener">使用手册</a></p>
<p>另外，微软有一款InstallShield，很图形化界面很微软风，只是收费，当然也可破解；现在用<code>inno setup</code>的也很多。</p>
<p>或者使用解压软件如winrar/好压等生成自解压文件。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>nsis</tag>
        <tag>inno</tag>
        <tag>installshield</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>mssoap与gsoap访问WebService的使用</title>
    <url>/2015/07/31/mssoap%E4%B8%8Egsoap%E8%AE%BF%E9%97%AEWebService%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="mssoap使用"><a href="#mssoap使用" class="headerlink" title="mssoap使用"></a>mssoap使用</h2><p>本人win7 x64 vs2010测试机，包含头，引用库，命名空间<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"msxml4.dll"</span></span></span><br><span class="line"><span class="comment">//using namespace MSXML2;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msxml.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"C:/Program Files (x86)/Common Files/MSSoap/Binaries/mssoap30.dll"</span> exclude(<span class="meta-string">"IStream"</span>, <span class="meta-string">"IErrorInfo"</span>, <span class="meta-string">"ISequentialStream"</span>, <span class="meta-string">"_LARGE_INTEGER"</span>, <span class="meta-string">"_ULARGE_INTEGER"</span>, <span class="meta-string">"tagSTATSTG"</span>, <span class="meta-string">"_FILETIME"</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MSSOAPLib30;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCTestDlg::OnBnClickedBtOutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">    ISoapSerializerPtr Serializer;</span><br><span class="line">    ISoapReaderPtr Reader;</span><br><span class="line">    ISoapConnectorPtr Connector;</span><br><span class="line"></span><br><span class="line">    HRESULT hr=Connector.CreateInstance(__uuidof(HttpConnector30)); <span class="comment">//创建连接实例</span></span><br><span class="line">    <span class="keyword">if</span>(!SUCCEEDED(hr))</span><br><span class="line">    &#123;  </span><br><span class="line">        MessageBox(_T(<span class="string">"error"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务所在地址和端口;</span></span><br><span class="line">    Connector-&gt;Property[<span class="string">"EndPointURL"</span>] = <span class="string">"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl"</span>;<span class="comment">//网上找到webservice网址</span></span><br><span class="line">    Connector-&gt;Connect();</span><br><span class="line"><span class="comment">//	Connector-&gt;Property["SoapAction"] = "http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl";</span></span><br><span class="line">    Connector-&gt;BeginMessage();</span><br><span class="line">    Serializer.CreateInstance(__uuidof(SoapSerializer30));</span><br><span class="line">    Serializer-&gt;Init(<span class="keyword">_variant_t</span>((IUnknown*)Connector-&gt;InputStream));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Serializer-&gt;StartEnvelope(<span class="string">"soap"</span>,<span class="string">""</span>,<span class="string">""</span>);<span class="comment">//</span></span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"xsi"</span>, <span class="string">""</span>, <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>, <span class="string">"xmlns"</span>);   </span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"xsd"</span>, <span class="string">""</span>, <span class="string">"http://www.w3.org/2001/XMLSchema"</span>, <span class="string">"xmlns"</span>);</span><br><span class="line"><span class="comment">//	Serializer-&gt;SoapAttribute("soap12", "", "http://schemas.xmlsoap.org/soap/envelope/", "xmlns");</span></span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"soapenc"</span>,<span class="string">""</span>,<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span>,<span class="string">"xmlns"</span>);</span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"tns"</span>,<span class="string">""</span>,<span class="string">"http://www.webxml.com.cn/"</span>,<span class="string">"xmlns"</span>);</span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"types"</span>,<span class="string">""</span>,<span class="string">"http://www.webxml.com.cn/encodedTypes"</span>,<span class="string">"xmlns"</span>);</span><br><span class="line">    Serializer-&gt;StartBody(<span class="string">L"NONE"</span>);</span><br><span class="line"></span><br><span class="line">    Serializer-&gt;StartElement(<span class="string">"getEnCnTwoWayTranslator"</span>,<span class="string">"http://WebXml.com.cn/"</span>,<span class="string">"NONE"</span>,<span class="string">"xmlns"</span>); <span class="comment">// 开放的接口</span></span><br><span class="line"></span><br><span class="line">    Serializer-&gt;StartElement(<span class="string">"Word"</span>,<span class="string">"http://WebXml.com.cn/"</span>,<span class="string">"NONE"</span>,<span class="string">""</span>);<span class="comment">//参数</span></span><br><span class="line">    Serializer-&gt;SoapAttribute(<span class="string">"xsi:type"</span>,<span class="string">""</span>,<span class="string">"xsd:string"</span>,<span class="string">""</span>);</span><br><span class="line">    Serializer-&gt;WriteString(<span class="string">"hello"</span>); <span class="comment">//传参</span></span><br><span class="line">    Serializer-&gt;EndElement();</span><br><span class="line"></span><br><span class="line">    Serializer-&gt;EndElement();</span><br><span class="line"></span><br><span class="line">    Serializer-&gt;EndBody();</span><br><span class="line">    Serializer-&gt;EndEnvelope();</span><br><span class="line"></span><br><span class="line">    Connector-&gt;EndMessage(); </span><br><span class="line"></span><br><span class="line">    Reader.CreateInstance(__uuidof(SoapReader30));</span><br><span class="line"></span><br><span class="line">    Reader-&gt;Load(<span class="keyword">_variant_t</span>((IUnknown*)Connector-&gt;OutputStream),<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    SetDlgItemText(IDC_EDIT1, Reader-&gt;RpcResult-&gt;xml);<span class="comment">//(const char*)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gsoap使用"><a href="#gsoap使用" class="headerlink" title="gsoap使用"></a>gsoap使用</h2><p>首先官网下载windows版zip解压，在bin目录下有两个exe，命令行中使用<code>wsdl2h</code>或<code>soapcpp2 -h</code>可查看可使用命令。<br><code>wsdl2h.exe</code>  解析WebService的wsdl文件或者相应的URL ,本测试-o导出到*.h.（-s 不指定这个需要有stlvector.h头文件，多个wsdl文件用空格隔开）</p>
<blockquote>
<p>例：<code>wsdl2h.exe -s -o out.h a.wsdl b.wsdl</code></p>
</blockquote>
<p><code>soapcpp2.exe</code> 编译WebService代码,编译解析后得到的*.h文件.<br>生成文件较多。如果是客户端使用可加参数 -C编译。</p>
<blockquote>
<p>例：<code>soapcpp2.exe -C out.h</code></p>
</blockquote>
<p>（-h查看更多命令）<br>包含头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sf/soapStub.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sf/soapH.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sf/procSMSSoapBinding.nsmap"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCTestDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    soap sService;</span><br><span class="line">    _ns1__getEnCnTwoWayTranslator *pTrans = <span class="keyword">new</span> _ns1__getEnCnTwoWayTranslator;</span><br><span class="line">    <span class="function">CString <span class="title">strWord</span><span class="params">(_T(<span class="string">"word"</span>))</span></span>;</span><br><span class="line">    pTrans-&gt;Word = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(UnicodeToUTF8(strWord));</span><br><span class="line">    _ns1__getEnCnTwoWayTranslatorResponse TransResp;</span><br><span class="line">    soap_init(&amp;sService);</span><br><span class="line">    soap_set_mode(&amp;sService,SOAP_C_UTFSTRING);<span class="comment">//SOAP_C_UTFSTRING,SOAP_C_MBSTRING</span></span><br><span class="line">    soap_call___ns1__getEnCnTwoWayTranslator(&amp;sService,</span><br><span class="line">        <span class="string">"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl"</span>,</span><br><span class="line">        <span class="string">"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx/"</span>,</span><br><span class="line">        pTrans,</span><br><span class="line">        TransResp);</span><br><span class="line">    ns1__ArrayOfString* pAS = TransResp.getEnCnTwoWayTranslatorResult;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strXml;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it = pAS-&gt;<span class="built_in">string</span>.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != pAS-&gt;<span class="built_in">string</span>.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        strXml += *it;</span><br><span class="line">        strXml += <span class="string">"\n"</span>;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">CString <span class="title">strMsg</span><span class="params">(UTF8ToUnicode(strXml.c_str()))</span></span>;</span><br><span class="line"></span><br><span class="line">    SetDlgItemText(IDC_EDIT1, strMsg);<span class="comment">//(const char*)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者调用都不复杂，但，个人表示，mssoap可封装性好过gsoap，当网址、接口更改时，gsoap需要重新编译生成接口文件，而mssoap只需相应调整参数即可。但mssoap往往需要自家的xml解析类，不如gsoap纯净的感觉。而且gsoap编译生成的接口文件是纯C/C++的文件，应该是跨平台的。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>mssoap</tag>
        <tag>gsoap</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveX控件编写</title>
    <url>/2015/06/24/ActiveX%E6%8E%A7%E4%BB%B6%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p>本文主要讲述用VS编写ActiveX控件。在工业自动化中，我们可能会经常遇到使用COM(组建对象模型)来编写插件的方式。COM提供了一套统一的编码规则，从而实现了一个跨语言组件框架。</p>
<a id="more"></a>
<h2 id="ActiveX控件编写："><a href="#ActiveX控件编写：" class="headerlink" title="ActiveX控件编写："></a>ActiveX控件编写：</h2><p>由MFC向导直接生成ActiveX控件。编译即可得<code>*.ocx</code>控件。并注册到系统。</p>
<h2 id="如需显示自定义对话框："><a href="#如需显示自定义对话框：" class="headerlink" title="如需显示自定义对话框："></a>如需显示自定义对话框：</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息处理程序 </span></span><br><span class="line"><span class="built_in">int</span> ::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (COleControl::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">	m_dlgMain.Create(IDD_DLG_MAIN,<span class="keyword">this</span>);<span class="comment">//创建</span></span><br><span class="line">	m_dlgMain.ShowWindow(SW_SHOW);</span><br><span class="line"> 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> CMyCtrl::OnDraw(</span><br><span class="line">			CDC* pdc, <span class="keyword">const</span> CRect&amp; rcBounds, <span class="keyword">const</span> CRect&amp; rcInvalid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pdc)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 用您自己的绘图代码替换下面的代码。</span></span><br><span class="line">	m_dlgMain.m_strTitle = m_StrTitleName;<span class="comment">//更改标题</span></span><br><span class="line">	m_dlgMain.MoveWindow(rcBounds);<span class="comment">//将自定义对话框Move到该控件视即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加自定义属性"><a href="#添加自定义属性" class="headerlink" title="添加自定义属性"></a>添加自定义属性</h2><p>本人不建议手动添加，除非对微软的封装了解的比较透彻，否则还是用向导吧如下图。孙鑫的书上写的是类向导，搞死我了，找到类视图，找到相应接口，右击添加属性、方法等。<br>​​​​<img src="20150625095431604.png" alt="img"></p>
<h2 id="属性页添加属性持久化及获取"><a href="#属性页添加属性持久化及获取" class="headerlink" title="属性页添加属性持久化及获取"></a>属性页添加属性持久化及获取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CMyCtrl* <span class="title">CMyPropPage::GetControlClass</span><span class="params">()</span><span class="comment">//获取控件类指针，这是微软官方给的代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CAlarmsDisplayCtrl *pMyCtrl;</span><br><span class="line">	ULONG Ulong;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Get the array of IDispatch pointers that is stored in the property page.</span></span><br><span class="line">	LPDISPATCH FAR *lpDispatch = GetObjectArray(&amp;Ulong);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Get the CCmdTarget object that is associated with any one of the previous</span></span><br><span class="line">	<span class="comment">// array elements.</span></span><br><span class="line">	pMyCtrl = (CAlarmsDisplayCtrl*)FromIDispatch(lpDispatch[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">	<span class="keyword">return</span> pMyCtrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://support.microsoft.com/zh-cn/kb/143432/en-us" target="_blank" rel="noopener">微软官方解决办法</a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void CMyPropPage::<span class="constructor">DoDataExchange(CDataExchange<span class="operator">*</span> <span class="params">pDX</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pDX-&gt;m_bSaveAndValidate==<span class="number">0</span>)<span class="comment">//初始化,load</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Get the array of IDispatchs stored in the property page</span></span><br><span class="line">		CMyCtrl *pCtrl = <span class="constructor">GetControlClass()</span>;</span><br><span class="line">		<span class="keyword">if</span> (pCtrl)</span><br><span class="line">		&#123;</span><br><span class="line">			m_strTitle = pCtrl-&gt;m_StrTitleName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="constructor">DDP_PostProcessing(<span class="params">pDX</span>)</span>;</span><br><span class="line">	<span class="constructor">DDX_Control(<span class="params">pDX</span>, IDC_EDIT_TITLE, <span class="params">m_edtTitle</span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="constructor">DDP_Text(<span class="params">pDX</span>,IDC_EDIT_TITLE,<span class="params">m_strTitle</span>,<span class="params">_T</span>(<span class="string">"StrTitleName"</span>)</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="constructor">DDX_Text(<span class="params">pDX</span>,IDC_EDIT_TITLE,<span class="params">m_strTitle</span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span>(pDX-&gt;m_bSaveAndValidate !=<span class="number">0</span>)<span class="comment">//结束保存</span></span><br><span class="line">	&#123;</span><br><span class="line">		CMyCtrl *pCtrl = <span class="constructor">GetControlClass()</span>;</span><br><span class="line">		<span class="keyword">if</span>(pCtrl)</span><br><span class="line">		&#123;</span><br><span class="line">			pCtrl-&gt;m_StrTitleName = m_strTitle;</span><br><span class="line">			pCtrl-&gt;<span class="constructor">SetModifiedFlag()</span>;</span><br><span class="line"> 			pCtrl-&gt;<span class="constructor">Invalidate()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果获取到的控件指针一直是NULL请在控件的构造函数中添加：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">CMyCtrl:</span>:CMyCtrl()</span><br><span class="line">&#123;</span><br><span class="line">	InitializeIIDs(<span class="variable">&amp;</span>IID_DMy, <span class="variable">&amp;</span>IID_DMyEvents);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此初始化控件的实例数据。</span></span><br><span class="line">	m_xInnerUnknown = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此ActiveX基本框架搭建就完成了，剩下的业务接口就是C++的事情了。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><span style=color:red>注意：</span></h2><p>如果控件中包含其他的ActiveX控件如<code>MS Web Browser</code>导致的<code>Create</code>失败，请在<code>InitInstance</code>中添加：<code>AfxEnableControlContainer()</code>。</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>ActiveX</tag>
        <tag>ocx</tag>
        <tag>vc</tag>
      </tags>
  </entry>
  <entry>
    <title>vs编写ActiveX控件，无法运行调试配置</title>
    <url>/2015/06/17/vs%E7%BC%96%E5%86%99ActiveX%E6%8E%A7%E4%BB%B6%EF%BC%8C%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在VS中开发MFC ActiveX控件，开发完后，通常使用VS自带的容器<code>ActiveX Control Test Container</code>来运行ActiveX控件。<a id="more"></a>此容器在VS安装后的文件中是找不到的，需要自己手动获取。如下所述：<br>    （1）按照你的VS所安装的路径，找到VCxxxxSamples.zip这个压缩文件，其在Samples下的名为2052文件夹中,如在我的电脑上，其所在路径为：<code>C:\Program Files\Microsoft Visual Studio 10.0\Samples\2052\VC2010Samples.zip</code>。<br>    （2）找到这个压缩文件后，将其减压得到一个C++项目目录。<br>    （3）进入\C++\MFC\ole找到TstCon这个文件夹。打开这个文件夹，打开*.sln解决方案,可发现有工程项目TCProps和TstCon。<br>    （4）编译完后，就可在TstCon文件夹下的Debug文件夹中看到TstCon.exe文件。该exe即是vc6下相同的那个ActiveX容器，可以打开你新项目中生成的ocx控件。</p>
<p>配置vs，2010为例：<br>该菜单开始是灰的，因为其路径，对应的exe不存在，将生成的TstCon.exe拷贝到其路径，修改该项对应的路径文件名即可。以后，只需直接点击该菜单。</p>
<p>另一种方式：<br>在对应项目中配置运行的exe，打开项目属性，配置工作目录为TstCon.exe的目录即可。</p>
]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>activex</tag>
        <tag>container</tag>
        <tag>com</tag>
      </tags>
  </entry>
  <entry>
    <title>VC将对话框缩小到托盘</title>
    <url>/2015/06/05/VC%E5%B0%86%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%BC%A9%E5%B0%8F%E5%88%B0%E6%89%98%E7%9B%98/</url>
    <content><![CDATA[<h2 id="一、托盘简介"><a href="#一、托盘简介" class="headerlink" title="一、托盘简介"></a>一、托盘简介</h2><p>所谓的“托盘”，在Windows系统界面中，指的就是windows系统任务条右侧，有系统时间等等的标志的那一部分。在程序最小化或挂起时，但有不希望占据任务栏的时候，就可以把程序放到托盘区。其实，托盘区的编程很简单，下面简要阐述。<a id="more"></a></p>
<h2 id="二、托盘编程相关函数"><a href="#二、托盘编程相关函数" class="headerlink" title="二、托盘编程相关函数"></a>二、托盘编程相关函数</h2><p>其实呢，把程序放到托盘上的本质就是先在托盘区绘制一个图标，然后把程序隐藏不见，再对托盘的图标进行消息处理，就可以了。<br>绘制图标以及确定图标所传送消息的函数只有一个，那就是————<code>WINSHELLAPI BOOL WINAPI Shell_NotifyIcon(
DWORD dwMessage, 
PNOTIFYICONDATA pnid);</code><br>这个函数呢，负责向系统传递消息，以添加、修改或删除托盘区的图标。她的返回值呢，是个布尔类型的。就是说，如果返回0，那就是成仁啦，非0才成功。<br>参数<code>dwMessage</code>是表示这个函数的应用功能是哪一方面，是添加、删除，还是修改图标。如果是添加，则它的值为<code>NIM_ADD</code>；删除则是<code>NIM_DELETE</code>；而修改是<code>NIM_MODIFY</code>。参数<code>pnid</code>就是具体的和程序在托盘区的图标有关系的结构了。它的定义如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NOTIFYICONDATA</span> &#123;</span> </span><br><span class="line">DWORD cbSize; </span><br><span class="line">HWND hWnd; </span><br><span class="line">UINT uID; </span><br><span class="line">UINT uFlags; </span><br><span class="line">UINT uCallbackMessage; </span><br><span class="line">HICON hIcon; </span><br><span class="line"><span class="keyword">char</span> szTip[<span class="number">64</span>]; </span><br><span class="line">&#125; NOTIFYICONDATA, *PNOTIFYICONDATA;</span><br></pre></td></tr></table></figure>

<h2 id="三、请看代码"><a href="#三、请看代码" class="headerlink" title="三、请看代码"></a>三、请看代码</h2><p>关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::ToTray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NOTIFYICONDATA nid;</span><br><span class="line">    nid.cbSize=(DWORD)<span class="keyword">sizeof</span>(NOTIFYICONDATA);</span><br><span class="line">    nid.hWnd=<span class="keyword">this</span>-&gt;m_hWnd;</span><br><span class="line">    nid.uID=IDR_MAINFRAME;</span><br><span class="line">    nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP ;</span><br><span class="line">    nid.uCallbackMessage=WM_SHOWTASK;<span class="comment">//自定义的消息名称，消息映射用：ON_MESSAGE(WM_SHOWTASK,onShowTask)</span></span><br><span class="line">    nid.hIcon=LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME));</span><br><span class="line">    <span class="built_in">strcpy</span>(nid.szTip,<span class="string">"程序正在工作"</span>);<span class="comment">//信息提示条为“计划任务提醒”</span></span><br><span class="line">    Shell_NotifyIcon(NIM_ADD,&amp;nid);<span class="comment">//在托盘区添加图标</span></span><br><span class="line">    ShowWindow(SW_HIDE);<span class="comment">//隐藏主窗口</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LRESULT <span class="title">CMyDlg::onShowTask</span><span class="params">(WPARAM wParam,LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wParam!=IDR_MAINFRAME)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(lParam)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONUP:<span class="comment">//右键起来时弹出快捷菜单，这里只有一个“关闭”</span></span><br><span class="line">        &#123; </span><br><span class="line">            </span><br><span class="line">            LPPOINT lpoint=<span class="keyword">new</span> tagPOINT;</span><br><span class="line">            ::GetCursorPos(lpoint);<span class="comment">//得到鼠标位置</span></span><br><span class="line">            CMenu menu;</span><br><span class="line">            menu.CreatePopupMenu();<span class="comment">//声明一个弹出式菜单</span></span><br><span class="line">            <span class="comment">//增加菜单项“退出”，点击则发送消息WM_DESTROY给主窗口（已</span></span><br><span class="line">            <span class="comment">//隐藏），将程序结束。</span></span><br><span class="line">            menu.AppendMenu(MF_STRING,WM_DESTROY,<span class="string">"退出"</span>); </span><br><span class="line">            <span class="comment">//确定弹出式菜单的位置</span></span><br><span class="line">            SetForegroundWindow();<span class="comment">//很重要，弹出菜单在失去焦点不能自动消失，这也是MSDN的官方解释</span></span><br><span class="line">            menu.TrackPopupMenu(TPM_LEFTALIGN,lpoint-&gt;x<span class="number">-120</span>,lpoint-&gt;y<span class="number">-30</span>,<span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//资源回收</span></span><br><span class="line">            HMENU hmenu=menu.Detach();</span><br><span class="line">            menu.DestroyMenu();</span><br><span class="line">            <span class="keyword">delete</span> lpoint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:<span class="comment">//单击恢复</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;ShowWindow(SW_SHOW);<span class="comment">//显示主窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg::OnClose</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your message handler code here and/or call default</span></span><br><span class="line">    ToTray();<span class="comment">//调用</span></span><br><span class="line">    <span class="comment">//CDialog::OnClose();不注释就直接退出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vc</category>
      </categories>
      <tags>
        <tag>vc</tag>
        <tag>托盘</tag>
      </tags>
  </entry>
</search>
